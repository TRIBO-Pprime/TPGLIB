var tipuesearch = {"pages":[{"title":" TPGLIB ","text":"TPGLIB Developer Info Arthur Francisco","tags":"home","loc":"index.html"},{"title":"moment_stat – TPGLIB ","text":"type, public :: moment_stat statistical moments Components Type Visibility Attributes Name Initial real(kind=R8), public :: Kk sixth moment real(kind=R8), public :: Ku kurtosis real(kind=R8), public :: Sk skewness real(kind=R8), public :: Ss fifth moment real(kind=R8), public :: mu mean real(kind=R8), public :: si standard deviation real(kind=R8), public :: va variance Source Code type moment_stat !! statistical moments real ( kind = R8 ) :: mu !! *mean* real ( kind = R8 ) :: va !! *variance* real ( kind = R8 ) :: si !! *standard deviation* real ( kind = R8 ) :: Sk !! *skewness* real ( kind = R8 ) :: Ku !! *kurtosis* real ( kind = R8 ) :: Ss !! *fifth moment* real ( kind = R8 ) :: Kk !! *sixth moment* endtype moment_stat","tags":"","loc":"type/moment_stat.html"},{"title":"random_normal – TPGLIB","text":"public  function random_normal() Arguments None Return Value real(kind=r8) Note Adapted from the following fortran 77 code\n     algorithm 712, collected algorithms from acm.\n     this work published in transactions on mathematical software,\n     vol. 18, no. 4, december, 1992, pp. 434-435. The function random_normal() returns a normally distributed pseudo-random\n    number with zero mean and unit variance. The algorithm uses the ratio of uniforms method of a.j. kinderman\n   and j.f. monahan augmented with quadratic bounding curves. Author: Alan Miller csiro division of mathematical & information sciences private bag 10, clayton south mdc clayton 3169, victoria, australia Source Code function random_normal () implicit none !================================================================================================ !< @note !< !< Adapted from the following fortran 77 code !<      algorithm 712, collected algorithms from acm. !<      this work published in transactions on mathematical software, !<      vol. 18, no. 4, december, 1992, pp. 434-435. !< !<  + The function random_normal() returns a normally distributed pseudo-random !<     number with zero mean and unit variance. !<  + The algorithm uses the ratio of uniforms method of a.j. kinderman !<    and j.f. monahan augmented with quadratic bounding curves. !< !<     Author: !< !<     + Alan Miller !<     + csiro division of mathematical & information sciences !<     + private bag 10, clayton south mdc !<     + clayton 3169, victoria, australia !< !< @endnote !------------------------------------------------------------------------------------------------ real ( kind = r8 ) :: random_normal real ( kind = r8 ) :: s , t , a , b , r1 , r2 , u , v , x , y , q s = 0.449871_r8 t = - 0.386595_r8 a = 0.19600_r8 b = 0.25472_r8 r1 = 0.27597_r8 r2 = 0.27846_r8 !     generate p = (u,v) uniform in rectangle enclosing acceptance region do call random_number ( u ) call random_number ( v ) v = 1.7156 * ( v - 0.5_r8 ) !     evaluate the quadratic form x = u - s y = abs ( v ) - t q = x ** 2 + y * ( a * y - b * x ) !     accept p if inside inner ellipse if ( q < r1 ) exit !     reject p if outside outer ellipse if ( q > r2 ) cycle !     reject p if outside acceptance region if ( v ** 2 < - 4.0 * log ( u ) * u ** 2 ) exit enddo !     return ratio of p's coordinates as the normal deviate random_normal = v / u return endfunction random_normal","tags":"","loc":"proc/random_normal.html"},{"title":"rnorm – TPGLIB","text":"public  function rnorm() result(fn_val) Generate a random normal deviate using the polar method. reference : marsaglia,g. & bray,t.a. ‘a convenient method for generating\n             normal variables’, siam rev., vol.6, 260-264, 1964. Arguments None Return Value real(kind=R8) Called by proc~~rnorm~~CalledByGraph proc~rnorm rnorm proc~rnorm_vec rnorm_vec proc~rnorm_vec->proc~rnorm program~test_stat test_stat program~test_stat->proc~rnorm_vec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function rnorm () result ( fn_val ) !================================================================================================ !! Generate a random normal deviate using the polar method. !! !! *reference*: marsaglia,g. & bray,t.a. 'a convenient method for generating !!              normal variables', siam rev., vol.6, 260-264, 1964. !! !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ) :: fn_val real ( kind = R8 ) :: u , sum real ( kind = R8 ), save :: v , sln logical ( kind = I4 ), save :: second = . false . real ( kind = R8 ), parameter :: one = 1.0_R8 , vsmall = tiny ( one ) if ( second ) then ! if second, use the second random number generated on last call second = . false . fn_val = v * sln else ! first call; generate a pair of random normals second = . true . do call random_number ( u ) call random_number ( v ) u = scale ( u , 1 ) - one v = scale ( v , 1 ) - one sum = u * u + v * v + vsmall ! vsmall added to prevent log(zero) / zero if ( sum < one ) exit enddo sln = sqrt ( - scale ( log ( sum ), 1 ) / sum ) fn_val = u * sln endif return endfunction rnorm","tags":"","loc":"proc/rnorm.html"},{"title":"rnorm_vec – TPGLIB","text":"public  function rnorm_vec(n, mu, sigma) result(variates) Vector of reals that follow a normal law source authors: Beliavsky, Miller Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n vector size real(kind=R8), intent(in), optional :: mu distribution mean real(kind=R8), intent(in), optional :: sigma distribution std Return Value real(kind=R8), dimension(1:n) output vector Calls proc~~rnorm_vec~~CallsGraph proc~rnorm_vec rnorm_vec proc~rnorm rnorm proc~rnorm_vec->proc~rnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rnorm_vec~~CalledByGraph proc~rnorm_vec rnorm_vec program~test_stat test_stat program~test_stat->proc~rnorm_vec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function rnorm_vec ( n , mu , sigma ) result ( variates ) !================================================================================================ !! Vector of reals that follow a normal law !! !! [source](https://fortran-lang.discourse.group/t/normal-random-number-generator/3724/2) !! !! authors: Beliavsky, Miller !------------------------------------------------------------------------------------------------ integer ( kind = I4 ), intent ( in ) :: n !! *vector size* real ( kind = R8 ), intent ( in ), optional :: mu !! *distribution mean* real ( kind = R8 ), intent ( in ) , optional :: sigma !! *distribution std* real ( kind = R8 ), dimension ( 1 : n ) :: variates !! *output vector* integer ( kind = I4 ) :: i do i = 1 , n variates ( i ) = rnorm () enddo if ( present ( sigma ) ) variates = sigma * variates if ( present ( mu ) ) variates = variates + mu return endfunction rnorm_vec","tags":"","loc":"proc/rnorm_vec.html"},{"title":"calc_median – TPGLIB","text":"public  subroutine calc_median(tab, mask, md) Function to calculate the median value of a series. Input array containing the values for which the median is to be calculated Optional mask to include/exclude certain values from the array Output: the calculated median value Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:) :: tab series 1D array logical(kind=I4), intent(in), optional, dimension(:) :: mask mask real(kind=R8), intent(out) :: md result: series median value Calls proc~~calc_median~~CallsGraph proc~calc_median calc_median sort_array2 sort_array2 proc~calc_median->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_median~~CalledByGraph proc~calc_median calc_median proc~count_cell count_cell proc~count_cell->proc~calc_median proc~median_filter median_filter proc~median_filter->proc~calc_median proc~median_smooth median_smooth proc~median_filter->proc~median_smooth proc~median_smooth->proc~calc_median program~test_stat test_stat program~test_stat->proc~calc_median proc~topology topology proc~topology->proc~count_cell program~test_morpho test_morpho program~test_morpho->proc~count_cell program~test_smooth test_smooth program~test_smooth->proc~median_filter program~test_smooth->proc~median_smooth Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_median ( tab , mask , md ) !================================================================================================ !! Function to calculate the median value of a series. !! !! + Input array containing the values for which the median is to be calculated !! + Optional mask to include/exclude certain values from the array !! + Output: the calculated median value !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:) :: tab !! *series 1D array* logical ( kind = I4 ), intent ( in ), dimension (:), optional :: mask !! *mask* real ( kind = R8 ), intent ( out ) :: md !! *result: series median value* integer ( kind = I4 ) :: lg , nz ! lg: size of the tab array; nz: number of elements to consider integer ( kind = I4 ) :: i , ii ! i: loop counter; ii: counter for tab_tmp real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp ! Temporary array to store filtered values md = 0._R8 ! Initialize the median value to 0 lg = size ( tab ) ! Get the size of the input array nz = lg ! Initialize the number of elements to lg if ( present ( mask ) ) then ! Check if a mask is provided nz = count ( mask ) ! Count the number of true elements in the mask allocate ( tab_tmp ( 1 : nz ) ) ! Allocate memory for the temporary array based on the number of elements to consider ii = 0 ! Initialize the counter for tab_tmp do i = 1 , lg ! Loop through each element of the input array if ( mask ( i ) ) then ! If the element is included in the mask ii = ii + 1 ! Increment the counter tab_tmp ( ii ) = tab ( i ) ! Copy the corresponding value into the temporary array endif enddo if ( ii /= nz ) stop 'error calc_median' ! Check if the number of copied elements matches nz; if not, stop the program else ! If no mask is provided tab_tmp = tab ! Copy the input array into tab_tmp endif if ( nz == 1 ) then ! If only one element is present md = tab_tmp ( 1 ) ! The median is the single element return ! Exit the subroutine endif if ( nz == 2 ) then ! If two elements are present md = 0.5_R8 * ( tab_tmp ( 1 ) + tab_tmp ( 2 )) ! The median is the average of the two elements return ! Exit the subroutine endif call sort_array2 ( tab_inout = tab_tmp ( 1 : nz ), n = nz ) ! Call a subroutine to sort the temporary array if ( mod ( nz , 2 ) == 0 ) then ! Check if the number of elements is even md = 0.5_R8 * ( tab_tmp ( nz / 2 ) + tab_tmp ( nz / 2 + 1 ) ) ! The median is the average of the two middle elements else ! If the number of elements is odd md = tab_tmp ( ( nz - 1 ) / 2 ) ! The median is the middle element endif deallocate ( tab_tmp ) ! Free the allocated memory for tab_tmp return ! Exit the subroutine endsubroutine calc_median","tags":"","loc":"proc/calc_median.html"},{"title":"calc_moments – TPGLIB","text":"public  subroutine calc_moments(tab, mask, mx, nb_mom) Note Function to calculate the statistical moments of an array with mask, of shape dim. 1 or 2 Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(..) :: tab 1D or 2D array logical(kind=I4), intent(in), optional, dimension(..) :: mask 1D or 2D mask type( moment_stat ), intent(out) :: mx moment_stat result integer(kind=I4), intent(in) :: nb_mom number of desired moments Calls proc~~calc_moments~~CallsGraph proc~calc_moments calc_moments proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_moments~~CalledByGraph proc~calc_moments calc_moments proc~abbott_param abbott_param proc~abbott_param->proc~calc_moments proc~acv acv proc~acv->proc~calc_moments proc~indice_fractal indice_fractal proc~indice_fractal->proc~calc_moments proc~median_filter median_filter proc~median_filter->proc~calc_moments program~test_morpho test_morpho program~test_morpho->proc~calc_moments program~test_stat test_stat program~test_stat->proc~calc_moments proc~correlation_parameters correlation_parameters proc~correlation_parameters->proc~acv program~test_abbott test_abbott program~test_abbott->proc~abbott_param program~test_asfc test_asfc program~test_asfc->proc~indice_fractal program~test_smooth test_smooth program~test_smooth->proc~median_filter program~test_anisotropy test_anisotropy program~test_anisotropy->proc~correlation_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_moments ( tab , mask , mx , nb_mom ) !================================================================================================ !< @note Function to calculate the statistical moments of an array with mask, of shape dim. 1 or 2 !< !< \\begin{align*} !<     mu &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}\\eta_{i,j} \\\\ !<     va &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}(\\eta_{i,j}-\\mu)&#94;2 \\\\ !<     Sk &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}\\left(\\frac{\\eta_{i,j}-\\mu}{\\sigma}\\right)&#94;3 \\\\ !<     Ku &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}\\left(\\frac{\\eta_{i,j}-\\mu}{\\sigma}\\right)&#94;4 !< \\end{align*} !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_mom !! *number of desired moments* real ( kind = R8 ), intent ( in ), dimension (..) :: tab !! *1D or 2D array* logical ( kind = I4 ), intent ( in ), dimension (..), optional :: mask !! *1D or 2D mask* type ( moment_stat ), intent ( out ) :: mx !! [[moment_stat]] *result* integer ( kind = I4 ) :: size_tab real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp logical ( kind = I4 ), allocatable , dimension (:) :: msk_tmp select rank ( tab ) rank ( 1 ) if ( present ( mask ) ) then select rank ( mask ) rank ( 1 ) call calc_moments_1D ( tab , mask , mx , nb_mom ) rank default stop \"bad rank in mask 'calc_moments'\" endselect else call calc_moments_1D ( tab = tab , mx = mx , nb_mom = nb_mom ) endif rank ( 2 ) size_tab = product ( shape ( tab ) ) allocate ( tab_tmp ( 1 : size_tab ) ) tab_tmp = reshape ( tab , [ size_tab ] ) if ( present ( mask ) ) then allocate ( msk_tmp ( 1 : size_tab ) ) select rank ( mask ) rank ( 2 ) msk_tmp = reshape ( mask , [ size_tab ] ) call calc_moments_1D ( tab_tmp , msk_tmp , mx , nb_mom ) deallocate ( msk_tmp ) rank default stop \"bad rank in mask 'calc_moments'\" endselect else call calc_moments_1D ( tab = tab_tmp , mx = mx , nb_mom = nb_mom ) endif deallocate ( tab_tmp ) rank default stop \"bad rank in 'calc_moments'\" endselect return endsubroutine calc_moments","tags":"","loc":"proc/calc_moments.html"},{"title":"calc_moments_1D – TPGLIB","text":"private  subroutine calc_moments_1D(tab, mask, mx, nb_mom) Function to calculate the statistical moments of a 1D array with mask, see calc_moments Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:) :: tab 1D array logical(kind=I4), intent(in), optional, dimension(:) :: mask 1D mask type( moment_stat ), intent(out) :: mx moment_stat result integer(kind=I4), intent(in) :: nb_mom number of desired moments Called by proc~~calc_moments_1d~~CalledByGraph proc~calc_moments_1d calc_moments_1D proc~calc_moments calc_moments proc~calc_moments->proc~calc_moments_1d proc~abbott_param abbott_param proc~abbott_param->proc~calc_moments proc~acv acv proc~acv->proc~calc_moments proc~indice_fractal indice_fractal proc~indice_fractal->proc~calc_moments proc~median_filter median_filter proc~median_filter->proc~calc_moments program~test_morpho test_morpho program~test_morpho->proc~calc_moments program~test_stat test_stat program~test_stat->proc~calc_moments proc~correlation_parameters correlation_parameters proc~correlation_parameters->proc~acv program~test_abbott test_abbott program~test_abbott->proc~abbott_param program~test_asfc test_asfc program~test_asfc->proc~indice_fractal program~test_smooth test_smooth program~test_smooth->proc~median_filter program~test_anisotropy test_anisotropy program~test_anisotropy->proc~correlation_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_moments_1D ( tab , mask , mx , nb_mom ) !================================================================================================ !! Function to calculate the statistical moments of a 1D array with mask, see [[calc_moments]] !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_mom !! *number of desired moments* real ( kind = R8 ), intent ( in ), dimension (:) :: tab !! *1D array* logical ( kind = I4 ), intent ( in ), dimension (:), optional :: mask !! *1D mask* type ( moment_stat ), intent ( out ) :: mx !! [[moment_stat]] *result* integer ( kind = I4 ) :: lg , nz integer ( kind = I4 ) :: i , ii real ( kind = R8 ) :: tmp real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp lg = size ( tab ) nz = lg if ( present ( mask ) ) then nz = count ( mask ) allocate ( tab_tmp ( 1 : nz ) ) ii = 0 do i = 1 , lg if ( mask ( i ) ) then ii = ii + 1 tab_tmp ( ii ) = tab ( i ) endif enddo if ( ii /= nz ) stop 'error calc_moments' else tab_tmp = tab endif mx % mu = 0 mx % si = 0 mx % va = 0 mx % Sk = 0 mx % Ku = 0 mx % Ss = 0 mx % Kk = 0 do i = 1 , nz mx % mu = mx % mu + tab_tmp ( i ) / nz enddo if ( nb_mom == 1 ) return do i = 1 , nz mx % va = mx % va + ( ( tab_tmp ( i ) - mx % mu ) ** 2 ) / nz enddo mx % si = sqrt ( mx % va ) if ( nb_mom == 2 ) return ! don't go further if ( mx % si < 1.e-15_R8 ) then ! if the standard deviation is too small, quit stop 'calc_moments, std too small' endif do i = 1 , nz tmp = ( tab_tmp ( i ) - mx % mu ) / mx % si mx % Sk = mx % Sk + ( tmp ** 3 ) / nz mx % Ku = mx % Ku + ( tmp ** 4 ) / nz enddo if ( nb_mom == 4 ) return do i = 1 , nz tmp = ( tab_tmp ( i ) - mx % mu ) / mx % si mx % Ss = mx % Ss + ( tmp ** 5 ) / nz mx % Kk = mx % Kk + ( tmp ** 6 ) / nz enddo deallocate ( tab_tmp ) return endsubroutine calc_moments_1D","tags":"","loc":"proc/calc_moments_1d.html"},{"title":"scramble – TPGLIB","text":"public  subroutine scramble(tab, lg) scramble a vector of reals Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(1:lg) :: tab integer(kind=i4), intent(in) :: lg Calls proc~~scramble~~CallsGraph proc~scramble scramble sort_array2 sort_array2 proc~scramble->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine scramble ( tab , lg ) !================================================================================================ !! scramble a vector of reals !------------------------------------------------------------------------------------------------ implicit none integer ( kind = i4 ), intent ( in ) :: lg real ( kind = r8 ) , intent ( inout ), dimension ( 1 : lg ) :: tab real ( kind = r8 ), dimension ( 1 : lg ) :: tmp integer ( kind = i4 ) :: i call random_number ( harvest = tmp ( 1 : lg ) ) call sort_array2 ( tab_inout = tmp ( 1 : lg ), & ! tab1 = tab ( 1 : lg ), n = lg ) ! return endsubroutine scramble","tags":"","loc":"proc/scramble.html"},{"title":"abbott_param – TPGLIB","text":"public  subroutine abbott_param(tab, lg, nom, curves, results, omp) Note Function that returns the Abbott’s curve in a svg file as well as smrk1, smrk2, spk, svk, sk Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:lg ) :: tab surface in a 1D vector integer(kind=I4), intent(in) :: lg surface total number of points character(len=*), intent(in) :: nom output generic name logical(kind=I4), intent(in), dimension(1:3) :: curves if true, generates a svg drawing 1: histogram 2: Abbott 3: tangent fit real(kind=R8), intent(out), dimension(1:11 ) :: results surface parameters output 1 smrk1 , iso 25178 2 smrk2 , iso 25178 3 spk , iso 25178 4 svk , iso 25178 5 off1 , ordonnée de spk 6 off2 , ordonnée de svk 7 sk , iso 25178 8 core slope 9 adjustment factor (tangent fit) 10 coeffa_tan (tangent fit) 11 coeffb_tan (tangent fit) logical(kind=I4), intent(in) :: omp if true, openmp used Calls proc~~abbott_param~~CallsGraph proc~abbott_param abbott_param get_unit get_unit proc~abbott_param->get_unit init pikaia_class%init proc~abbott_param->init moindres_carres_lineaire moindres_carres_lineaire proc~abbott_param->moindres_carres_lineaire proc~calc_moments calc_moments proc~abbott_param->proc~calc_moments run_gnuplot run_gnuplot proc~abbott_param->run_gnuplot solve pikaia_class%solve proc~abbott_param->solve sort_array2 sort_array2 proc~abbott_param->sort_array2 proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~abbott_param~~CalledByGraph proc~abbott_param abbott_param program~test_abbott test_abbott program~test_abbott->proc~abbott_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine abbott_param ( tab , lg , nom , curves , results , omp ) !================================================================================================ !< @note Function that returns the Abbott's curve in a svg file as well as smrk1, smrk2, spk, svk, sk ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *surface total number of points* character ( len =* ), intent ( in ) :: nom !! *output generic name* logical ( kind = I4 ), intent ( in ), dimension ( 1 : 3 ) :: curves !! *if true, generates a svg drawing* !! 1: histogram 2: Abbott 3: tangent fit real ( kind = R8 ), intent ( inout ), dimension ( 1 : lg ) :: tab !! *surface in a 1D vector* real ( kind = R8 ), intent ( out ), dimension ( 1 : 11 ) :: results !! *surface parameters output* !! !!  +  1 **smrk1**, iso 25178 !!  +  2 **smrk2**, iso 25178 !!  +  3 **spk**  , iso 25178 !!  +  4 **svk**  , iso 25178 !!  +  5 **off1** , ordonnée de spk !!  +  6 **off2** , ordonnée de svk !!  +  7 **sk**   , iso 25178 !!  +  8 **core slope** !!  +  9 **adjustment factor** (tangent fit) !!  + 10 **coeffa_tan**        (tangent fit) !!  + 11 **coeffb_tan**        (tangent fit) logical ( kind = I4 ), intent ( in ) :: omp !! *if true, openmp used* integer ( kind = I4 ), parameter :: nb_points = 4 * 4096 ! nb points kept for the curve integer ( kind = I4 ) :: i , ua , icat , ncat , nb_paquets , inc , reste integer ( kind = I4 ) :: len_reg , beg_reg , end_reg integer ( kind = I4 ) :: smrk1 , smrk2 , ios integer ( kind = I4 ) :: status ! PIKAIA: status real ( kind = R8 ) :: hmin , hmax , delt , seuil , reduction real ( kind = R8 ) :: tmp , off1 , off2 , spk , svk , sk real ( kind = R8 ) :: f ! PIKAIA: best cost type ( moment_stat ) :: mx real ( kind = R8 ), dimension ( 1 : 2 ) :: vec_reg real ( kind = R8 ), dimension ( 1 : 4 ) :: xx ! PIKAIA: chromosom real ( kind = R8 ), dimension ( 1 : 4 ) :: xl , xu ! PIKAIA: lower and upper bonds of xx integer ( kind = I4 ), allocatable , dimension (:) :: tab_abbott real ( kind = R8 ), allocatable , dimension (:) :: tab_moy real ( kind = R8 ), allocatable , dimension (:,:) :: jac_reg type ( pikaia_class ) :: p ! PIKAIA: class instanciation ! center heights call calc_moments ( tab = tab ( 1 : lg ), & ! mx = mx , & ! nb_mom = 2 ) ! tab ( 1 : lg ) = tab ( 1 : lg ) - mx % mu ! sort in decreasing order tab ( 1 : lg ) = - tab ( 1 : lg ) call sort_array2 ( tab_inout = tab ( 1 : lg ), & ! n = lg ) ! tab ( 1 : lg ) = - tab ( 1 : lg ) ! reduction factor to stay between 1 and 100 because there are ! too many points in array tab reduction = nb_points / 10 0. ! array of points for the curve allocate ( tab_moy ( 1 : nb_points ) ) ! nb heights of tab representing each point of the curve nb_paquets = lg / ( nb_points - 1 ) ! ... and remaining heights reste = lg - nb_paquets * ( nb_points - 1 ) ! array of points; the first point and the last one are ! the first and last height to keep the extrema. inc = 1 do i = 1 , nb_points - 1 tab_moy ( i ) = tab ( inc ) inc = inc + nb_paquets if ( i == nb_points / 2 ) inc = inc + reste - 1 ! the remaing heights are added to ! the middle points, where it makes less difference enddo tab_moy ( nb_points ) = tab ( lg ) if ( curves ( 1 ) ) then ! print histogram ? ncat = 100 !  nombre de \"classes\" pour l'histogramme allocate ( tab_abbott ( 1 : ncat ) ) ; tab_abbott ( 1 : ncat ) = 0 hmin = tab ( lg ) - 100 * EPS_R8 !  pour être sûr d'attraper le min hmax = tab ( 1 ) + 100 * EPS_R8 !  idem pour le max delt = ( hmax - hmin ) / ncat ! categories width (heights) seuil = hmax - delt i = 0 do icat = 1 , ncat do i = i + 1 ; if ( i > lg ) exit if ( tab ( i ) < seuil ) exit tab_abbott ( icat ) = tab_abbott ( icat ) + 1 enddo seuil = seuil - delt enddo call get_unit ( ua ) open ( unit = ua , file = trim ( nom ) // '_histo.txt' ) do icat = 1 , ncat write ( ua , * ) real ( hmax + delt / 2 - icat * delt , kind = R4 ), 100 * real ( tab_abbott ( icat ), kind = R4 ) / lg enddo close ( ua ) deallocate ( tab_abbott ) endif ! nb points for the line regression! between 30% and 60% of the curve len_reg = int ( 0.4 * nb_points ) beg_reg = int ( 0.3 * nb_points ) end_reg = beg_reg + len_reg - 1 allocate ( jac_reg ( 1 : len_reg , 1 : 2 ) ) ! jacobian regression : vec_reg(1) * Xi + vec_reg(2) * 1 jac_reg ( 1 : len_reg , 1 ) = [ ( beg_reg + i , i = 0 , len_reg - 1 ) ] jac_reg ( 1 : len_reg , 2 ) = 1._R8 call moindres_carres_lineaire ( nb_var = 2 , & ! number of parameters to be determined nb_pts = len_reg , & ! number of points for function evaluation hij = tab_moy ( beg_reg : end_reg ), & ! vector of evaluation points (1:nb_pts) beta = vec_reg ( 1 : 2 ), & ! parameters vector (1:nb_var) Jf = jac_reg ( 1 : len_reg , 1 : 2 ) ) ! Jacobian (1:nb_pts, 1:nb_var) ! f(smrk1) coordinates off1 = vec_reg ( 2 ) ! (0._R8, off1) do i = 1 , nb_points if ( tab_moy ( i ) < off1 ) exit enddo smrk1 = i ! (UN*smrk1, off1) tmp = 0. do i = 1 , smrk1 tmp = tmp + ( tab_moy ( i ) - off1 ) enddo spk = 2 * tmp / smrk1 ! areas equivalency spk = abs ( spk ) ! f(smrk2) coordinates off2 = vec_reg ( 1 ) * nb_points + vec_reg ( 2 ) ! (nb_points, off2) do i = nb_points , 1 , - 1 if ( tab_moy ( i ) > off2 ) exit enddo smrk2 = i ! (UN*smrk2, off2) tmp = 0. do i = smrk2 , nb_points tmp = tmp + ( tab_moy ( i ) - off2 ) enddo svk = 2 * tmp / ( nb_points - smrk2 + 1 ) ! areas equivalency sk = tab_moy ( smrk1 ) - tab_moy ( smrk2 ) if ( curves ( 2 ) ) then ! print Abbott ? call get_unit ( ua ) open ( unit = ua , file = trim ( nom ) // '.dat' ) do i = 1 , nb_points write ( ua , * ) 100 * real ( i - 1 , kind = R4 ) / ( nb_points - 1 ), & ! real ( tab_moy ( i ), kind = R4 ), & ! real ( vec_reg ( 1 ) * i + vec_reg ( 2 ), kind = R4 ) ! enddo close ( ua ) open ( unit = ua , file = trim ( nom ) // '.gpl' , status = 'replace' , iostat = ios ) write ( ua , '(a)' ) 'set terminal svg dashed size 350,262 font \"Verdana, 10\"' write ( ua , '(a)' ) 'set output \"' // trim ( nom ) // '.svg\"' write ( ua , '(a)' ) 'set title \"Abbott\"' write ( ua , '(a)' ) 'set xlabel \"%age\"' write ( ua , '(a)' ) 'set ylabel \"h\"' write ( ua , '(a)' ) \"set style line 1 lc rgb 'dark-green' lt 1 lw 1\" write ( ua , '(a)' ) \"set style line 2 lc rgb 'dark-green' lt 5 lw 1\" ! tracé du segment horizontal de A1 (cf norme 25178) write ( ua , * ) 'set arrow 1 from ' , 0._R8 / reduction , ',' , off1 , ' to ' , UN * smrk1 / reduction , ',' , off1 , ' nohead front ls 1' ! tracé du segment incliné de A1 write ( ua , * ) 'set arrow 2 from ' , UN * smrk1 / reduction , ',' , off1 , ' to ' , 0._R8 / reduction , ',' , spk + off1 , ' nohead front ls 1' ! tracé de la droite haute horizontale write ( ua , * ) 'set arrow 5 from ' , 0._R8 / reduction , ',' , off1 , ' to ' , UN * nb_points / reduction , ',' , off1 , ' nohead front ls 2' ! tracé du segment horizontal de A2 (cf norme 25178) write ( ua , * ) 'set arrow 3 from ' , UN * smrk2 / reduction , ',' , off2 , ' to ' , UN * nb_points / reduction , ',' , off2 , ' nohead front ls 1' ! tracé du segment incliné de A2 write ( ua , * ) 'set arrow 4 from ' , UN * smrk2 / reduction , ',' , off2 , ' to ' , UN * nb_points / reduction , ',' , svk + off2 , ' nohead front ls 1' ! tracé de la droite basse horizontale write ( ua , * ) 'set arrow 6 from ' , UN * nb_points / reduction , ',' , off2 , ' to ' , 0._R8 / reduction , ',' , off2 , ' nohead front ls 2' ! tracé du segment vertical correspondant à sk write ( ua , * ) 'set arrow 7 from ' , 5 0. , ',' , off2 , ' to ' , 5 0. , ',' , off2 + sk , ' nohead front ls 1' write ( ua , '(a)' ) 'plot \"' // trim ( nom ) // '.dat\" ' // 'using 1:2  title \"Abbott-Firestone curve\" with lines,\\' write( ua, ' ( a ) ' )     ' \"' // trim(nom)//'.dat\" ' // ' using 1 : 3 notitle with lines ls 1 ' close(unit = ua) call run_gnuplot (trim(nom)//' . gpl ') endif deallocate( jac_reg ) !----------------------------------------------------------- call sort_array2( tab_inout = tab_moy(1:nb_points), &  ! n         = nb_points )              ! xx(1:4) = 0.0_R8 ! vector of parameters xl(1:4) = 0.0_R8 ! lower bound xu(1:4) = 1.0_R8 ! upper bound !initialize the class: call p%init(           n = 4,                   &  ! IN           ; the parameter space dimension, i.e., the number of !                adjustable parameters (size of the x vector). xl = xl,                  &  ! IN, DIM(n)   ; vector of lower bounds for x xu = xu,                  &  ! IN, DIM(n)   ; vector of upper bounds for x f = cost,                &  !              ; user-supplied scalar function of n variables, which !                must have the pikaia_func procedure interface. status = status,              &  ! OUT          ; status output flag (0 if there were no errors) np = 100,                 &  ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000,                &  ! IN, OPT      ; maximum number of iterations nd = 9,                   &  ! IN           ; number of significant digits (i.e., number of genes) !                retained in chromosomal encoding pcross = 0.85_R8,             &  ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85) !                If crossover takes place, either one or two splicing points are used, !                with equal probabilities pmutmn = 0.0005_R8,           &  ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8,             &  ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8,            &  ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) !                (Note: the mutation rate is the probability that any one gene !                 locus will mutate in any one generation.) imut = 2,                   &  ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !                1=one-point mutation, fixed rate. !                2=one-point, adjustable rate based on fitness. !                3=one-point, adjustable rate based on distance. !                4=one-point+creep, fixed rate. !                5=one-point+creep, adjustable rate based on fitness. !                6=one-point+creep, adjustable rate based on distance. fdif = 1._R8,               &  ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). !                (default is 1.0) irep = 3,                   &  ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/ !                                         Steady-state-replace-random/ !                                         Steady- state-replace-worst (default is 3) ielite = 0,                   &  ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) !                (Applies only to reproduction plans 1 and 2) ivrb = 0,                   &  ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8,           &  ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 400,                 &  ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive !                solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8,              &  ! IN, OPT      ; raction of the initial population to set equal to the initial guess. !                Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999)                    ! IN, OPT      ; random seed value; must be > 0 (default is 999) !Now call pikaia: call p%solve(      x = xx(1:4),     &  ! INOUT, DIM(*) ; f = f,           &  !   OUT         ; status = status,      &  !   OUT         ; omp = omp )           ! IN xx(3:4) = xx(3:4) * mx%si if ( curves(3) ) then ! print tangent fit ? call get_unit(ua) open( unit = ua, file = trim(nom)//' _ tan . datt ') do i = 1, nb_points write(ua, *) 100 * real( i - 1, kind = R4) / (nb_points - 1),                                      &  ! real( tab_moy(i), kind = R4 ),                                                  &  ! real( tg( real( i - 1, kind = R8) / ( nb_points - 1 ), xx(1:4) ), kind = R4 )      ! enddo close(ua) open( unit = ua, file = trim(nom)//' _ tan . gplt ', status = ' replace ', iostat = ios ) write( ua, ' ( a ) ' ) ' set terminal svg size 350 , 262 font \"Verdana, 10\" ' write( ua, ' ( a ) ' ) ' set output \"'//trim(nom)//'_tan.svgt\" ' write( ua, ' ( a ) ' ) ' set title \"Abbott-Firestone curve\" ' write( ua, ' ( a ) ' ) ' set xlabel \"%age\" ' write( ua, ' ( a ) ' ) ' set ylabel \"h\" ' write( ua, ' ( a ) ' ) ' plot \"' // trim(nom)//'_tan.datt\" ' // ' using 1 : 2 title \"Abbott-Firestone\" with lines , \\ ' write( ua, ' ( a ) ' )     ' \"' // trim(nom)//'_tan.datt\" ' // ' using 1 : 3 title \"tangent regression\" with lines ' close(unit = ua) call run_gnuplot (trim(nom)//' _ tan . gplt ' ) endif results ( 1 : 11 ) = [ real ( smrk1 , kind = R8 ) * 100 / nb_points , & !  1 smrk1, iso 25178 real ( smrk2 , kind = R8 ) * 100 / nb_points , & !  2 smrk2, iso 25178 spk , & !  3 spk , iso 25178 abs ( svk ), & !  4 svk , iso 25178 spk + off1 , & !  5 off1, ordonnée de spk abs ( svk + off2 ), & !  6 off2, ordonnée de svk sk , & !  7 sk  , iso 25178 vec_reg ( 1 ) * nb_points / 10 0. , & !  8 core slope f , & !  9 adjustment factor (tangent fit) xx ( 1 ), & ! 10 coeffa_tan        (tangent fit) xx ( 2 ) ] ! 11 coeffb_tan        (tangent fit) deallocate ( tab_moy ) contains subroutine cost ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = 1. / ( 1. + diff_abb_tan ( chrom = x ( 1 : 4 ))) return endsubroutine cost real ( kind = R8 ) function diff_abb_tan ( chrom ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 4 ) :: chrom integer ( kind = I4 ) :: i ! the height array is standardize to avoid too small values diff_abb_tan = sum ( [ ( ( tg ( real ( i - 1 , kind = R8 ) / ( nb_points - 1 ), chrom ) - tab_moy ( i ) / mx % si ) ** 2. , i = 1 , nb_points , 8 ) ] ) return endfunction diff_abb_tan real ( kind = R8 ) function tg ( xi , chrom ) implicit none real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ), dimension ( 1 : 4 ) :: chrom tg = chrom ( 3 ) * tan ( ( PI_R8 / 2 ) * ( - ( 1._R8 - chrom ( 1 )) + xi * ( 2._R8 - ( chrom ( 1 ) + chrom ( 2 ) ) ) ) ) + chrom ( 4 ) return endfunction tg endsubroutine abbott_param","tags":"","loc":"proc/abbott_param.html"},{"title":"df_boltz – TPGLIB","text":"private  function df_boltz(xi, beta, n_beta, ivar) Fitting function partial derivatives. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi data point real(kind=R8), intent(inout), dimension(1:n_beta) :: beta parameter vector integer(kind=I4), intent(in) :: n_beta number of parameters integer(kind=I4), intent(in) :: ivar parameter number Return Value real(kind=r8) Called by proc~~df_boltz~~CalledByGraph proc~df_boltz df_boltz proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~df_boltz proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc_lin_all->proc~df_boltz proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc_spl_all->proc~df_boltz proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite proc~calcul_asfc->proc~calcul_asfc_lin_all proc~calcul_asfc->proc~calcul_asfc_spl_all program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/df_boltz.html"},{"title":"dn_i – TPGLIB","text":"private  function dn_i(xi, i) 1D shape function derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi integer(kind=I4), intent(in) :: i Return Value real(kind=r8) Called by proc~~dn_i~~CalledByGraph proc~dn_i dn_i proc~dnq_et_i dnq_et_i proc~dnq_et_i->proc~dn_i proc~dnq_xi_et_i dnq_xi_et_i proc~dnq_xi_et_i->proc~dn_i proc~dnq_xi_i dnq_xi_i proc~dnq_xi_i->proc~dn_i proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~dnq_et_i proc~calcul_asfc_hermite->proc~dnq_xi_i proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dn_i.html"},{"title":"dnq_et_i – TPGLIB","text":"private  function dnq_et_i(xi, et, i, j) 2D shape function derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Calls proc~~dnq_et_i~~CallsGraph proc~dnq_et_i dnq_et_i proc~dn_i dn_i proc~dnq_et_i->proc~dn_i proc~n_i n_i proc~dnq_et_i->proc~n_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dnq_et_i~~CalledByGraph proc~dnq_et_i dnq_et_i proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~dnq_et_i proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dnq_et_i.html"},{"title":"dnq_xi_et_i – TPGLIB","text":"private  function dnq_xi_et_i(xi, et, i, j) 2D shape function , derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Calls proc~~dnq_xi_et_i~~CallsGraph proc~dnq_xi_et_i dnq_xi_et_i proc~dn_i dn_i proc~dnq_xi_et_i->proc~dn_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dnq_xi_et_i.html"},{"title":"dnq_xi_i – TPGLIB","text":"private  function dnq_xi_i(xi, et, i, j) 2D shape function derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Calls proc~~dnq_xi_i~~CallsGraph proc~dnq_xi_i dnq_xi_i proc~dn_i dn_i proc~dnq_xi_i->proc~dn_i proc~n_i n_i proc~dnq_xi_i->proc~n_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dnq_xi_i~~CalledByGraph proc~dnq_xi_i dnq_xi_i proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~dnq_xi_i proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dnq_xi_i.html"},{"title":"f_boltz – TPGLIB","text":"private  function f_boltz(xi, beta, n_beta) Note Fitting function. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi data point real(kind=R8), intent(inout), dimension(1:n_beta) :: beta parameter vector integer(kind=I4), intent(in) :: n_beta number of parameters Return Value real(kind=r8) Called by proc~~f_boltz~~CalledByGraph proc~f_boltz f_boltz proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~f_boltz proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc_lin_all->proc~f_boltz proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc_spl_all->proc~f_boltz proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite proc~calcul_asfc->proc~calcul_asfc_lin_all proc~calcul_asfc->proc~calcul_asfc_spl_all program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/f_boltz.html"},{"title":"locate – TPGLIB","text":"private  function locate(n, xx, x) Note Function that returns the location of an element in a vector. Given an array xx(1: n) , and given a value x , it returns a value j such that x is between\nxx( j ) and xx( j + 1 ). xx must be monotonic, either increasing or decreasing. j = 0 or j = n is returned to indicate\nthat x is out of range. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n vector length real(kind=R8), intent(in), dimension(1:n) :: xx vector real(kind=R8), intent(in) :: x value to locate Return Value integer(kind=i4) Called by proc~~locate~~CalledByGraph proc~locate locate proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~locate proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc_lin_all->proc~locate proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc_spl_all->proc~locate proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite proc~calcul_asfc->proc~calcul_asfc_lin_all proc~calcul_asfc->proc~calcul_asfc_spl_all program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/locate.html"},{"title":"locate2 – TPGLIB","text":"private  function locate2(n, xx, x, eps) Note Function that returns the location of an element in a vector. Given an array xx(1: n) , and given a value x , it returns a value j such that x is between\nxx( j ) and xx( j + 1 ). xx must be monotonic, either increasing or decreasing. j = 0 or j = n is returned to indicate\nthat x is out of range. The difference with locate is the use of eps for comparisons of reals. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n vector length real(kind=R8), intent(in), dimension(1:n) :: xx vector real(kind=R8), intent(in) :: x value to locate real(kind=R8), intent(in) :: eps small value for comparisons of reals Return Value integer(kind=i4) Called by proc~~locate2~~CalledByGraph proc~locate2 locate2 proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~locate2 proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/locate2.html"},{"title":"n_i – TPGLIB","text":"private  function n_i(xi, i) 1D shape function, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi integer(kind=I4), intent(in) :: i Return Value real(kind=r8) Called by proc~~n_i~~CalledByGraph proc~n_i n_i proc~dnq_et_i dnq_et_i proc~dnq_et_i->proc~n_i proc~dnq_xi_i dnq_xi_i proc~dnq_xi_i->proc~n_i proc~nq_i nq_i proc~nq_i->proc~n_i proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~dnq_et_i proc~calcul_asfc_hermite->proc~dnq_xi_i proc~calcul_asfc_hermite->proc~nq_i proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/n_i.html"},{"title":"nq_i – TPGLIB","text":"private  function nq_i(xi, et, i, j) 2D shape function, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Calls proc~~nq_i~~CallsGraph proc~nq_i nq_i proc~n_i n_i proc~nq_i->proc~n_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nq_i~~CalledByGraph proc~nq_i nq_i proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~nq_i proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nq_i.html"},{"title":"calcul_aire – TPGLIB","text":"private  subroutine calcul_aire(tab_in, long, larg, hx, hy, aire) Return the area of a surface Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long,1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in) :: hx increment along x real(kind=R8), intent(in) :: hy increment along y real(kind=R8), intent(out) :: aire computed area Called by proc~~calcul_aire~~CalledByGraph proc~calcul_aire calcul_aire proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc_lin_all->proc~calcul_aire proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc_spl_all->proc~calcul_aire proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_lin_all proc~calcul_asfc->proc~calcul_asfc_spl_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcul_aire ( tab_in , long , larg , hx , hy , aire ) !================================================================================================ !! Return the area of a surface implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ) :: hx !! *increment along x* real ( kind = R8 ), intent ( in ) :: hy !! *increment along y* real ( kind = R8 ), intent ( out ) :: aire !! *computed area* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: z1 , z2 , z3 , z4 , si si = 1 !SCALE_IMG%si ! Raisonnement sur chaque carré du domaine aire = 0. do j = 1 , larg - 1 do i = 1 , long - 1 z1 = tab_in ( i , j ) * si z2 = tab_in ( i , j + 1 ) * si z3 = tab_in ( i + 1 , j + 1 ) * si z4 = tab_in ( i + 1 , j ) * si aire = aire + 0.5_R8 * ( sqrt ( UN + (( z1 - z2 ) / hx ) ** 2 + (( z1 - z4 ) / hy ) ** 2 ) + & sqrt ( UN + (( z3 - z2 ) / hy ) ** 2 + (( z3 - z4 ) / hx ) ** 2 ) ) enddo enddo aire = aire / ( ( long - 1 ) * ( larg - 1 ) ) return endsubroutine calcul_aire","tags":"","loc":"proc/calcul_aire.html"},{"title":"calcul_asfc – TPGLIB","text":"private  subroutine calcul_asfc(tab_in, scal, asfc_res, omp) Return the asfc of a surface regarding the default parameter method_asfc Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor logical(kind=I4), intent(in) :: omp with openmp ? Calls proc~~calcul_asfc~~CallsGraph proc~calcul_asfc calcul_asfc get_unit get_unit proc~calcul_asfc->get_unit proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc->proc~calcul_asfc_hermite proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc->proc~calcul_asfc_lin_all proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc->proc~calcul_asfc_spl_all proc~calcul_asfc_hermite->get_unit lmder1 lmder1 proc~calcul_asfc_hermite->lmder1 omp_get_num_procs omp_get_num_procs proc~calcul_asfc_hermite->omp_get_num_procs proc~df_boltz df_boltz proc~calcul_asfc_hermite->proc~df_boltz proc~dnq_et_i dnq_et_i proc~calcul_asfc_hermite->proc~dnq_et_i proc~dnq_xi_i dnq_xi_i proc~calcul_asfc_hermite->proc~dnq_xi_i proc~f_boltz f_boltz proc~calcul_asfc_hermite->proc~f_boltz proc~init_beta_boltz init_beta_boltz proc~calcul_asfc_hermite->proc~init_beta_boltz proc~locate locate proc~calcul_asfc_hermite->proc~locate proc~locate2 locate2 proc~calcul_asfc_hermite->proc~locate2 proc~nq_i nq_i proc~calcul_asfc_hermite->proc~nq_i proc~calcul_asfc_lin_all->lmder1 proc~calcul_aire calcul_aire proc~calcul_asfc_lin_all->proc~calcul_aire proc~calcul_asfc_lin_all->proc~df_boltz proc~calcul_asfc_lin_all->proc~f_boltz proc~calcul_asfc_lin_all->proc~init_beta_boltz proc~calcul_asfc_lin_all->proc~locate db2ink db2ink proc~calcul_asfc_spl_all->db2ink db2val db2val proc~calcul_asfc_spl_all->db2val proc~calcul_asfc_spl_all->lmder1 proc~calcul_asfc_spl_all->proc~calcul_aire proc~calcul_asfc_spl_all->proc~df_boltz proc~calcul_asfc_spl_all->proc~f_boltz proc~calcul_asfc_spl_all->proc~init_beta_boltz proc~calcul_asfc_spl_all->proc~locate proc~dn_i dn_i proc~dnq_et_i->proc~dn_i proc~n_i n_i proc~dnq_et_i->proc~n_i proc~dnq_xi_i->proc~dn_i proc~dnq_xi_i->proc~n_i proc~nq_i->proc~n_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcul_asfc ( tab_in , scal , asfc_res , omp ) !================================================================================================ !! Return the *asfc* of a surface regarding the default parameter *method_asfc* implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* logical ( kind = I4 ), intent ( in ) :: omp !! *with openmp ?* if ( out_lin ) call get_unit ( unit_out_lin ) if ( out_spl ) call get_unit ( unit_out_spl ) select case ( method_asfc ) case ( lin_all ) call calcul_asfc_lin_all ( tab_in , scal , asfc_res ) case ( spl_all ) call calcul_asfc_spl_all ( tab_in , scal , asfc_res ) case ( hermite ) call calcul_asfc_hermite ( tab_in , scal , asfc_res , omp ) case default stop 'no valid method' endselect return endsubroutine calcul_asfc","tags":"","loc":"proc/calcul_asfc.html"},{"title":"calcul_asfc_hermite – TPGLIB","text":"public  subroutine calcul_asfc_hermite(tab_in, scal, asfc_res, omp) Return the asfc of a surface. The different grids are obtained by Hermite interpolation Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor logical(kind=I4), intent(in) :: omp with openmp ? Calls proc~~calcul_asfc_hermite~~CallsGraph proc~calcul_asfc_hermite calcul_asfc_hermite get_unit get_unit proc~calcul_asfc_hermite->get_unit lmder1 lmder1 proc~calcul_asfc_hermite->lmder1 omp_get_num_procs omp_get_num_procs proc~calcul_asfc_hermite->omp_get_num_procs proc~df_boltz df_boltz proc~calcul_asfc_hermite->proc~df_boltz proc~dnq_et_i dnq_et_i proc~calcul_asfc_hermite->proc~dnq_et_i proc~dnq_xi_i dnq_xi_i proc~calcul_asfc_hermite->proc~dnq_xi_i proc~f_boltz f_boltz proc~calcul_asfc_hermite->proc~f_boltz proc~init_beta_boltz init_beta_boltz proc~calcul_asfc_hermite->proc~init_beta_boltz proc~locate locate proc~calcul_asfc_hermite->proc~locate proc~locate2 locate2 proc~calcul_asfc_hermite->proc~locate2 proc~nq_i nq_i proc~calcul_asfc_hermite->proc~nq_i proc~dn_i dn_i proc~dnq_et_i->proc~dn_i proc~n_i n_i proc~dnq_et_i->proc~n_i proc~dnq_xi_i->proc~dn_i proc~dnq_xi_i->proc~n_i proc~nq_i->proc~n_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calcul_asfc_hermite~~CalledByGraph proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcul_asfc_hermite ( tab_in , scal , asfc_res , omp ) !================================================================================================ !! Return the *asfc* of a surface. The different grids are obtained by Hermite interpolation implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* logical ( kind = I4 ), intent ( in ) :: omp !! *with openmp ?* real ( kind = R8 ), allocatable , dimension (:) :: x ! x points in original grid real ( kind = R8 ), allocatable , dimension (:) :: y ! y points in original grid integer ( kind = I4 ) :: long_new ! number of points in x dimension for new grid integer ( kind = I4 ) :: larg_new ! number of points in y dimension for new grid real ( kind = R8 ), allocatable , dimension (:) :: x_new ! new grid x points real ( kind = R8 ), allocatable , dimension (:) :: y_new ! new grid y points real ( kind = R8 ), allocatable , dimension (:,:) :: tab_ou ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_in_dx ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_in_dy ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_in_xy ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:) :: gx real ( kind = R8 ), allocatable , dimension (:) :: gy real ( kind = R8 ), allocatable , dimension (:) :: gw real ( kind = R8 ), allocatable , dimension (:) :: tab_dnq real ( kind = R8 ) :: rr integer ( kind = I4 ) :: i , ii , j , jj , k , long_tmp , larg_tmp real ( kind = R8 ), dimension ( 1 : nb_beta ) :: beta real ( kind = R8 ), dimension ( 1 : npp ) :: vec_s real ( kind = R8 ), dimension ( 1 : npp ) :: vec_x ! points coordinates real ( kind = R8 ), dimension ( 1 : npp ) :: vec_y ! points coordinates real ( kind = R8 ) :: asfc1 , asfc2 , aire , hx , hy , hhx , hhy , width , height real ( kind = R8 ) :: xi , yi , eps_x integer ( kind = I4 ) :: it , ng , nbpt integer ( kind = I4 ) :: long , larg integer ( kind = I4 ) :: nb_th long = scal % xres larg = scal % yres if ( out_her ) call get_unit ( unit_out_her ) if ( out_her ) open ( unit = unit_out_her , file = \"out/asfc_her_her_all.txt\" ) width = scal % lx height = scal % ly hx = width / ( long - 1 ) hy = height / ( larg - 1 ) eps_x = min ( hx / 10 ** 3 , hy / 10 ** 3 ) ! définition d'abscisses pour l'interpolation par splines allocate ( x ( 1 : long ), y ( 1 : larg ) ) do i = 1 , long x ( i ) = hx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg y ( j ) = hy * real ( j - 1 , kind = R8 ) enddo allocate ( x_new ( 1 : long ), & ! y_new ( 1 : larg ), & ! tab_ou ( 1 : long , 1 : larg ), & ! tab_in_dx ( 1 : long , 1 : larg ), & ! tab_in_dy ( 1 : long , 1 : larg ), & ! tab_in_xy ( 1 : long , 1 : larg ) ) ! rr = ( real ( long0 , kind = R8 ) / long ) ** ( UN / npp ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points rr = max ( rr , ( real ( larg0 , kind = R8 ) / larg ) ** ( UN / npp ) ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points x_new ( 1 : long ) = x ( 1 : long ) y_new ( 1 : larg ) = y ( 1 : larg ) tab_ou ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call init_aire_hermite ( gx = gx , gy = gy , gw = gw , tab_dnq = tab_dnq , ng = ng ) ! pour chaque réduction de maillage, calcul du maillage résultant et de l'aire relative associée !............................................................. long_new = long larg_new = larg hhx = hx hhy = hy call calcul_aire_hermite ( tab_in = tab_ou ( 1 : long_new , 1 : larg_new ), & ! long = long_new , & ! larg = larg_new , & ! gw = gw ( 1 : ng ), & ! tab_dnq = tab_dnq ( 1 : ng ), & ! ng = ng , & ! hx = hhx , & ! hy = hhy , & ! width = width , & ! height = height , & ! aire = aire ) ! vec_s ( 1 ) = log ( aire ) vec_x ( 1 ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) call calcul_tabd_hermite ( tab_in = tab_in ( 1 : long , 1 : larg ), & ! tab_dx = tab_in_dx ( 1 : long , 1 : larg ), & ! tab_dy = tab_in_dy ( 1 : long , 1 : larg ), & ! tab_xy = tab_in_xy ( 1 : long , 1 : larg ), & ! long = long , & ! larg = larg , & ! hx = hx , & ! hy = hy ) ! nb_th = 1 if ( omp ) then nb_th = omp_get_num_procs () endif !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO ORDERED SCHEDULE (STATIC,1) PRIVATE(it, long_tmp, larg_tmp, long_new, larg_new, hhx, hhy, i, x_new, j, y_new, yi, jj, xi, ii, tab_ou, aire) do it = 1 , npp - 1 long_tmp = nint ( long * ( rr ** it )) ! nb points en suite géométrique larg_tmp = nint ( larg * ( rr ** it )) if ( long_new == long_tmp . or . larg_new == larg_tmp ) then vec_s ( it + 1 ) = 0 cycle ! à découper trop fin, on peut tomber sur les mêmes entiers endif long_new = long_tmp larg_new = larg_tmp hhx = width / ( long_new - 1 ) hhy = height / ( larg_new - 1 ) vec_x ( it + 1 ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) deallocate ( x_new , y_new , tab_ou ) allocate ( x_new ( 1 : long_new ), & ! y_new ( 1 : larg_new ), & ! nouvelles abscisses tab_ou ( 1 : long_new , 1 : larg_new ) ) ! do i = 1 , long_new x_new ( i ) = hhx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg_new y_new ( j ) = hhy * real ( j - 1 , kind = R8 ) enddo do j = 1 , larg_new yi = y_new ( j ) jj = locate2 ( n = larg , xx = y ( 1 : larg ), x = yi , eps = eps_x ) yi = ( yi - ( y ( jj ) + y ( jj + 1 )) / 2 ) / ( hy / 2 ) do i = 1 , long_new xi = x_new ( i ) ii = locate2 ( n = long , xx = x ( 1 : long ), x = xi , eps = eps_x ) xi = ( xi - ( x ( ii ) + x ( ii + 1 )) / 2 ) / ( hx / 2 ) tab_ou ( i , j ) = & ! nq_i ( xi , yi , 1 , 1 ) * tab_in ( ii , jj ) + & !  u1 nq_i ( xi , yi , 2 , 1 ) * tab_in ( ii + 1 , jj ) + & !  u2 nq_i ( xi , yi , 3 , 1 ) * tab_in ( ii + 1 , jj + 1 ) + & !  u3 nq_i ( xi , yi , 4 , 1 ) * tab_in ( ii , jj + 1 ) + & !  u4 nq_i ( xi , yi , 1 , 2 ) * tab_in_dx ( ii , jj ) * hx / 2 + & ! du1/dx nq_i ( xi , yi , 2 , 2 ) * tab_in_dx ( ii + 1 , jj ) * hx / 2 + & ! du2/dx nq_i ( xi , yi , 3 , 2 ) * tab_in_dx ( ii + 1 , jj + 1 ) * hx / 2 + & ! du3/dx nq_i ( xi , yi , 4 , 2 ) * tab_in_dx ( ii , jj + 1 ) * hx / 2 + & ! du4/dx nq_i ( xi , yi , 1 , 3 ) * tab_in_dy ( ii , jj ) * hy / 2 + & ! du1/dy nq_i ( xi , yi , 2 , 3 ) * tab_in_dy ( ii + 1 , jj ) * hy / 2 + & ! du2/dy nq_i ( xi , yi , 3 , 3 ) * tab_in_dy ( ii + 1 , jj + 1 ) * hy / 2 + & ! du3/dy nq_i ( xi , yi , 4 , 3 ) * tab_in_dy ( ii , jj + 1 ) * hy / 2 + & ! du4/dy nq_i ( xi , yi , 1 , 4 ) * tab_in_xy ( ii , jj ) * hx * hy / 4 + & ! du1/dxdy nq_i ( xi , yi , 2 , 4 ) * tab_in_xy ( ii + 1 , jj ) * hx * hy / 4 + & ! du2/dxdy nq_i ( xi , yi , 3 , 4 ) * tab_in_xy ( ii + 1 , jj + 1 ) * hx * hy / 4 + & ! du3/dxdy nq_i ( xi , yi , 4 , 4 ) * tab_in_xy ( ii , jj + 1 ) * hx * hy / 4 ! du4/dxdy enddo enddo call calcul_aire_hermite ( tab_in = tab_ou ( 1 : long_new , 1 : larg_new ), & ! long = long_new , & ! larg = larg_new , & ! gw = gw ( 1 : ng ), & ! tab_dnq = tab_dnq ( 1 : ng ), & ! ng = ng , & ! hx = hhx , & ! hy = hhy , & ! width = width , & ! height = height , & ! aire = aire ) ! vec_s ( it + 1 ) = log ( aire ) !~          write(unit_out_her, *) vec_x(it+1), vec_s(it+1) enddo !$OMP END DO !$OMP END PARALLEL deallocate ( x_new , y_new , x , y , tab_ou , tab_in_dx , tab_in_dy , tab_in_xy , tab_dnq , gx , gy , gw ) if ( out_lin ) close ( unit_out_lin ) if ( out_her ) close ( unit_out_her ) !............................................................. k = 1 do i = 1 , npp if ( abs ( vec_s ( i )) > EPS_R8 ) then vec_y ( k ) = vec_s ( i ) vec_x ( k ) = vec_x ( i ) k = k + 1 endif enddo nbpt = k - 1 call interpolate_asfc ( bt = beta ( 1 : nb_beta ), & ! n_bt = nb_beta , & ! n_pt = nbpt , & ! asf = asfc1 , & ! r2 = asfc2 ) ! asfc_res = [ - 1000 * asfc1 , asfc2 ] return contains subroutine interpolate_asfc ( bt , n_bt , n_pt , asf , r2 ) !================================================================================================ !< @note Function that fits the data points for the asfc determination.<br/> !        f\\_boltz(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( out ) :: asf !! *Asfc number* real ( kind = R8 ), intent ( out ) :: r2 !! *correlation number to assess validity of the Asfc calculus* real ( kind = R8 ), dimension ( 1 : n_pt , 1 : n_bt ) :: jacob real ( kind = R8 ), dimension ( 1 : n_pt ) :: v_x , v_y , res_y , pentes integer ( kind = I4 ) :: i0 , i , j , info real ( kind = R8 ) :: delta1 , delta2 , y_mean v_x ( 1 : n_pt ) = vec_x ( 1 : n_pt ) ! smoothing v_y ( 1 ) = vec_y ( 1 ) do i = 1 + 1 , n_pt - 1 v_y ( i ) = 0.25_R8 * ( vec_y ( i - 1 ) + 2 * vec_y ( i ) + vec_y ( i + 1 ) ) enddo v_y ( n_pt ) = vec_y ( n_pt ) call init_beta_boltz ( bt = bt ( 1 : n_bt ), & ! n_bt = n_bt , & ! v_x = v_x ( 1 : n_pt ), & ! v_y = v_y ( 1 : n_pt ), & ! n_pt = n_pt ) ! res_y ( 1 : n_pt ) = 0._R8 jacob ( 1 : n_pt , 1 : n_bt ) = 0._R8 call lmder1 ( fcn = lmder1_f , & ! m = n_pt , & ! n = n_bt , & ! x = bt ( 1 : n_bt ), & ! fvec = res_y ( 1 : n_pt ), & ! fjac = jacob ( 1 : n_pt , 1 : n_bt ), & ! ldfjac = n_pt , & ! tol = 1.0e-8_R8 , & ! info = info ) ! delta1 = 0._R8 delta2 = 0._R8 y_mean = sum ( vec_y ( 1 : n_pt ) ) / n_pt do i = 1 , n_pt delta1 = delta1 + ( vec_y ( i ) - f_boltz ( xi = vec_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt ) & ! ) ** 2 delta2 = delta2 + ( vec_y ( i ) - y_mean ) ** 2 enddo r2 = 1._R8 - delta1 / delta2 !~       if (r2<0) then !~       do i=1,n_pt !~       write(99,*) v_x(i), v_y(i) !~       enddo !~       stop 'error' !~       endif i0 = locate ( n = n_pt , & ! xx = v_x ( 1 : n_pt ), & ! x = bt ( 1 )) ! j = 0 do i = i0 - 5 , i0 + 5 if ( i < 1 . or . i > n_pt ) cycle j = j + 1 pentes ( j ) = + df_boltz ( xi = v_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt , & ! ivar = 0 ) ! enddo asf = sum ( pentes ( 1 : j ) / j ) return endsubroutine interpolate_asfc subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !================================================================================================ !< @note Function called by [[lmder1]] as part of **minpack**, modified by !        [Burkardt](https://people.sc.fsu.edu/~jburkardt/f_src/minpack/minpack.html) <br/> !        According *iflag* value it calculates the function [[f_boltz]] at the data points !        or the jacobian. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: m !! *number of points* integer ( kind = I4 ), intent ( in ) :: n !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ldfjac !! *leading dimension of fjac, which must be at least n* integer ( kind = I4 ), intent ( in ) :: iflag !! *which calculus to perform* real ( kind = R8 ), intent ( out ), dimension ( 1 : m ) :: fvec !! *vector of f_boltz(xi)* real ( kind = R8 ), intent ( out ), dimension ( 1 : ldfjac , 1 : n ) :: fjac !! *jacobian* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n ) :: x !! *parameter values* integer ( kind = I4 ) :: i , k select case ( iflag ) case ( 0 ) continue case ( 1 ) do i = 1 , m fvec ( i ) = f_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! n_beta = n ) & ! - vec_y ( i ) enddo case ( 2 ) do i = 1 , m do k = 1 , n fjac ( i , k ) = df_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! ivar = k , & ! n_beta = n ) ! enddo enddo case default write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop endselect return endsubroutine lmder1_f subroutine init_aire_hermite ( gx , gy , gw , tab_dnq , ng ) !================================================================================================ !< @note ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: gx real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: gy real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: gw real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: tab_dnq integer ( kind = I4 ), intent ( out ) :: ng real ( kind = R8 ) :: x1 , x2 , y1 , y2 integer ( kind = I4 ) :: i , k , nb_gauss_1d nb_gauss_1d = 2 ng = nb_gauss_1d ** 2 allocate ( gx ( 1 : ng ), gy ( 1 : ng ), gw ( 1 : ng ) ) select case ( nb_gauss_1d ) case ( 1 ) x1 = 0._R8 y1 = 2._R8 gx ( 1 : ng ) = [ x1 ] gy ( 1 : ng ) = [ x1 ] gw ( 1 : ng ) = [ y1 * y1 ] case ( 2 ) x1 = sqrt ( 1._R8 / 3._R8 ) y1 = UN gx ( 1 : ng ) = [ - x1 , - x1 , + x1 , + x1 ] gy ( 1 : ng ) = [ - x1 , + x1 , - x1 , + x1 ] gw ( 1 : ng ) = [ y1 * y1 , y1 * y1 , y1 * y1 , y1 * y1 ] case ( 3 ) x1 = sqrt ( 3._R8 / 5.0_R8 ) x2 = 0._R8 y1 = 5._R8 / 9._R8 y2 = 8._R8 / 9._R8 gx ( 1 : ng ) = [ - x1 , - x1 , - x1 , x2 , x2 , x2 , + x1 , + x1 , + x1 ] gy ( 1 : ng ) = [ - x1 , x2 , + x1 , - x1 , x2 , + x1 , - x1 , x2 , + x1 ] gw ( 1 : ng ) = [ y1 * y1 , y1 * y2 , y1 * y1 , y1 * y2 , y2 * y2 , y1 * y2 , y1 * y1 , y1 * y2 , y1 * y1 ] endselect allocate ( tab_dnq ( 1 : 32 * ng ) ) i = 1 do k = 1 , ng tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 4 ) ; i = i + 1 !! tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 4 ) ; i = i + 1 enddo return endsubroutine init_aire_hermite subroutine calcul_tabd_hermite ( tab_in , tab_dx , tab_dy , tab_xy , long , larg , hx , hy ) !================================================================================================ !< @note ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long integer ( kind = I4 ), intent ( in ) :: larg real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_dx real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_dy real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_xy real ( kind = R8 ), intent ( in ) :: hx real ( kind = R8 ), intent ( in ) :: hy integer ( kind = I4 ) :: i , im , ip , j , jm , jp real ( kind = R8 ) :: ui , uim , uip , ujm , ujp , upp , ump , upm , umm do j = 1 , larg jm = max ( j - 1 , 1 ) jp = min ( j + 1 , larg ) do i = 1 , long im = max ( i - 1 , 1 ) ip = min ( i + 1 , long ) ui = tab_in ( i , j ) uim = tab_in ( im , j ) uip = tab_in ( ip , j ) ujm = tab_in ( i , jm ) ujp = tab_in ( i , jp ) upp = tab_in ( ip , jp ) ump = tab_in ( im , jp ) upm = tab_in ( ip , jm ) umm = tab_in ( im , jm ) tab_dx ( i , j ) = ( uip - uim ) / ( 2 * hx ) tab_dy ( i , j ) = ( ujp - ujm ) / ( 2 * hy ) tab_xy ( i , j ) = ( upp - ump - upm + umm ) / ( 4 * hx * hy ) enddo enddo tab_dx ( 1 , 1 : larg ) = ( tab_in ( 2 , 1 : larg ) - & ! tab_in ( 1 , 1 : larg ) ) / hx ! tab_dx ( long , 1 : larg ) = ( tab_in ( long , 1 : larg ) - & ! tab_in ( long - 1 , 1 : larg ) ) / hx ! tab_dy ( 1 : long , 1 ) = ( tab_in ( 1 : long , 2 ) - & ! tab_in ( 1 : long , 1 ) ) / hy ! tab_dy ( 1 : long , larg ) = ( tab_in ( 1 : long , larg ) - & ! tab_in ( 1 : long , larg - 1 ) ) / hy ! tab_xy ( 1 , 1 : larg ) = ( tab_dy ( 2 , 1 : larg ) - & ! tab_dy ( 1 , 1 : larg ) ) / hx ! tab_xy ( long , 1 : larg ) = ( tab_dy ( long , 1 : larg ) - & ! tab_dy ( long - 1 , 1 : larg ) ) / hx ! tab_xy ( 1 : long , 1 ) = ( tab_dx ( 1 : long , 2 ) - & ! tab_dx ( 1 : long , 1 ) ) / hy ! tab_xy ( 1 : long , larg ) = ( tab_dx ( 1 : long , larg ) - & ! tab_dx ( 1 : long , larg - 1 ) ) / hy ! return endsubroutine calcul_tabd_hermite subroutine calcul_aire_hermite ( tab_in , long , larg , gw , tab_dnq , ng , hx , hy , width , height , aire ) !================================================================================================ !< @note ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long integer ( kind = I4 ), intent ( in ) :: larg integer ( kind = I4 ), intent ( in ) :: ng real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in real ( kind = R8 ), intent ( in ), dimension ( 1 : ng ) :: gw real ( kind = R8 ), intent ( in ), dimension ( 1 : 32 * ng ) :: tab_dnq real ( kind = R8 ), intent ( in ) :: hx real ( kind = R8 ), intent ( in ) :: hy real ( kind = R8 ), intent ( in ) :: width real ( kind = R8 ), intent ( in ) :: height real ( kind = R8 ), intent ( out ) :: aire integer ( kind = I4 ) :: i , j , k , i1 , i2 , j1 , j2 real ( kind = R8 ) :: aire_tmp real ( kind = R8 ), allocatable , dimension (:) :: dfx real ( kind = R8 ), allocatable , dimension (:) :: dfy real ( kind = R8 ), allocatable , dimension (:,:) :: tab_dx ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_dy ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_xy ! new grid function evaluations allocate ( dfx ( 1 : ng ), & ! dfy ( 1 : ng ) ) ! allocate ( tab_dx ( 1 : long , 1 : larg ), & ! tab_dy ( 1 : long , 1 : larg ), & ! tab_xy ( 1 : long , 1 : larg ) ) ! call calcul_tabd_hermite ( tab_in = tab_in ( 1 : long , 1 : larg ), & ! tab_dx = tab_dx ( 1 : long , 1 : larg ), & ! tab_dy = tab_dy ( 1 : long , 1 : larg ), & ! tab_xy = tab_xy ( 1 : long , 1 : larg ), & ! long = long , & ! larg = larg , & ! hx = hx , & ! hy = hy ) ! aire_tmp = 0._R8 do j = 1 , larg - 1 j1 = j ; j2 = j + 1 do i = 1 , long - 1 i1 = i ; i2 = i + 1 do k = 1 , ng dfx ( k ) = ( 2._R8 / hx ) * ( & ! tab_dnq ( 32 * ( k - 1 ) + 01 ) * tab_in ( i1 , j1 ) + & !  u1 tab_dnq ( 32 * ( k - 1 ) + 02 ) * tab_in ( i2 , j1 ) + & !  u2 tab_dnq ( 32 * ( k - 1 ) + 03 ) * tab_in ( i2 , j2 ) + & !  u3 tab_dnq ( 32 * ( k - 1 ) + 04 ) * tab_in ( i1 , j2 ) + & !  u4 tab_dnq ( 32 * ( k - 1 ) + 05 ) * tab_dx ( i1 , j1 ) * hx / 2 + & ! du1/dx tab_dnq ( 32 * ( k - 1 ) + 06 ) * tab_dx ( i2 , j1 ) * hx / 2 + & ! du2/dx tab_dnq ( 32 * ( k - 1 ) + 07 ) * tab_dx ( i2 , j2 ) * hx / 2 + & ! du3/dx tab_dnq ( 32 * ( k - 1 ) + 08 ) * tab_dx ( i1 , j2 ) * hx / 2 + & ! du4/dx tab_dnq ( 32 * ( k - 1 ) + 09 ) * tab_dy ( i1 , j1 ) * hy / 2 + & ! du1/dy tab_dnq ( 32 * ( k - 1 ) + 10 ) * tab_dy ( i2 , j1 ) * hy / 2 + & ! du2/dy tab_dnq ( 32 * ( k - 1 ) + 11 ) * tab_dy ( i2 , j2 ) * hy / 2 + & ! du3/dy tab_dnq ( 32 * ( k - 1 ) + 12 ) * tab_dy ( i1 , j2 ) * hy / 2 + & ! du4/dy tab_dnq ( 32 * ( k - 1 ) + 13 ) * tab_xy ( i1 , j1 ) * hx * hy / 4 + & ! du1/dxdy tab_dnq ( 32 * ( k - 1 ) + 14 ) * tab_xy ( i2 , j1 ) * hx * hy / 4 + & ! du2/dxdy tab_dnq ( 32 * ( k - 1 ) + 15 ) * tab_xy ( i2 , j2 ) * hx * hy / 4 + & ! du3/dxdy tab_dnq ( 32 * ( k - 1 ) + 16 ) * tab_xy ( i1 , j2 ) * hx * hy / 4 ) ! du4/dxdy dfy ( k ) = ( 2._R8 / hy ) * ( & ! tab_dnq ( 32 * ( k - 1 ) + 17 ) * tab_in ( i1 , j1 ) + & !  u1 tab_dnq ( 32 * ( k - 1 ) + 18 ) * tab_in ( i2 , j1 ) + & !  u2 tab_dnq ( 32 * ( k - 1 ) + 19 ) * tab_in ( i2 , j2 ) + & !  u3 tab_dnq ( 32 * ( k - 1 ) + 20 ) * tab_in ( i1 , j2 ) + & !  u4 tab_dnq ( 32 * ( k - 1 ) + 21 ) * tab_dx ( i1 , j1 ) * hx / 2 + & ! du1/dx tab_dnq ( 32 * ( k - 1 ) + 22 ) * tab_dx ( i2 , j1 ) * hx / 2 + & ! du2/dx tab_dnq ( 32 * ( k - 1 ) + 23 ) * tab_dx ( i2 , j2 ) * hx / 2 + & ! du3/dx tab_dnq ( 32 * ( k - 1 ) + 24 ) * tab_dx ( i1 , j2 ) * hx / 2 + & ! du4/dx tab_dnq ( 32 * ( k - 1 ) + 25 ) * tab_dy ( i1 , j1 ) * hy / 2 + & ! du1/dy tab_dnq ( 32 * ( k - 1 ) + 26 ) * tab_dy ( i2 , j1 ) * hy / 2 + & ! du2/dy tab_dnq ( 32 * ( k - 1 ) + 27 ) * tab_dy ( i2 , j2 ) * hy / 2 + & ! du3/dy tab_dnq ( 32 * ( k - 1 ) + 28 ) * tab_dy ( i1 , j2 ) * hy / 2 + & ! du4/dy tab_dnq ( 32 * ( k - 1 ) + 29 ) * tab_xy ( i1 , j1 ) * hx * hy / 4 + & ! du1/dxdy tab_dnq ( 32 * ( k - 1 ) + 30 ) * tab_xy ( i2 , j1 ) * hx * hy / 4 + & ! du2/dxdy tab_dnq ( 32 * ( k - 1 ) + 31 ) * tab_xy ( i2 , j2 ) * hx * hy / 4 + & ! du3/dxdy tab_dnq ( 32 * ( k - 1 ) + 32 ) * tab_xy ( i1 , j2 ) * hx * hy / 4 ) ! du4/dxdy enddo do k = 1 , ng aire_tmp = aire_tmp + gw ( k ) * sqrt ( UN + dfx ( k ) ** 2 + dfy ( k ) ** 2 ) enddo enddo enddo aire = aire_tmp * ( hx / 2 ) * ( hy / 2 ) aire = aire / ( width * height ) deallocate ( tab_dx , & ! tab_dy , & ! tab_xy ) ! deallocate ( dfx , dfy ) return endsubroutine calcul_aire_hermite endsubroutine calcul_asfc_hermite","tags":"","loc":"proc/calcul_asfc_hermite.html"},{"title":"calcul_asfc_lin_all – TPGLIB","text":"private  subroutine calcul_asfc_lin_all(tab_in, scal, asfc_res) Return the asfc of a surface. The different grids are obtained by linear interpolation Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor Calls proc~~calcul_asfc_lin_all~~CallsGraph proc~calcul_asfc_lin_all calcul_asfc_lin_all lmder1 lmder1 proc~calcul_asfc_lin_all->lmder1 proc~calcul_aire calcul_aire proc~calcul_asfc_lin_all->proc~calcul_aire proc~df_boltz df_boltz proc~calcul_asfc_lin_all->proc~df_boltz proc~f_boltz f_boltz proc~calcul_asfc_lin_all->proc~f_boltz proc~init_beta_boltz init_beta_boltz proc~calcul_asfc_lin_all->proc~init_beta_boltz proc~locate locate proc~calcul_asfc_lin_all->proc~locate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calcul_asfc_lin_all~~CalledByGraph proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_lin_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcul_asfc_lin_all ( tab_in , scal , asfc_res ) !================================================================================================ !! Return the *asfc* of a surface. The different grids are obtained by linear interpolation implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* real ( kind = R8 ), allocatable , dimension (:) :: x ! x points in original grid real ( kind = R8 ), allocatable , dimension (:) :: y ! y points in original grid integer ( kind = I4 ) :: long_new ! number of points in x dimension for new grid integer ( kind = I4 ) :: larg_new ! number of points in y dimension for new grid real ( kind = R8 ), allocatable , dimension (:) :: x_new ! new grid x points real ( kind = R8 ), allocatable , dimension (:) :: y_new ! new grid y points real ( kind = R8 ), allocatable , dimension (:,:) :: tab_ou ! new grid function evaluations real ( kind = R8 ) :: rr integer ( kind = I4 ) :: i , ii , j , jj , ip , long_tmp , larg_tmp integer ( kind = I4 ) :: nb_pt real ( kind = R8 ), dimension ( 1 : nb_beta ) :: beta real ( kind = R8 ), dimension ( 1 : npp ) :: vec_l real ( kind = R8 ), dimension ( 1 : npp ) :: vec_x ! points coordinates real ( kind = R8 ), dimension ( 1 : npp ) :: vec_y ! points coordinates real ( kind = R8 ) :: asfc1 , asfc2 , aire_lin , xm , xp , ym , yp , hx , hy , hhx , hhy , h1 , h2 , h3 , h4 , width , height logical ( kind = I4 ) :: new_it integer ( kind = I4 ) :: long , larg long = scal % xres larg = scal % yres if ( out_lin ) open ( unit = unit_out_lin , file = \"out/asfc_lin_lin_all.txt\" ) width = scal % lx height = scal % ly hx = width / ( long - 1 ) hy = height / ( larg - 1 ) ! définition d'abscisses pour l'interpolation par splines allocate ( x ( 1 : long ), y ( 1 : larg ) ) do i = 1 , long x ( i ) = hx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg y ( j ) = hy * real ( j - 1 , kind = R8 ) enddo rr = ( real ( long0 , kind = R8 ) / long ) ** ( UN / npp ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points rr = max ( rr , ( real ( larg0 , kind = R8 ) / larg ) ** ( UN / npp ) ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points allocate ( x_new ( 1 : long ), & y_new ( 1 : larg ), & ! nouvelles abscisses tab_ou ( 1 : long , 1 : larg ) ) x_new ( 1 : long ) = x ( 1 : long ) y_new ( 1 : larg ) = y ( 1 : larg ) tab_ou ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) ! pour chaque réduction de maillage, calcul du maillage résultant et de l'aire relative associée !............................................................. long_new = long larg_new = larg hhx = hx hhy = hy new_it = . true . nb_pt = 1 do ip = 1 , npp + 1 if ( new_it ) then long_tmp = long_new larg_tmp = larg_new ! calcul de l'aire relative call calcul_aire ( tab_ou ( 1 : long_tmp , 1 : larg_tmp ), long_tmp , larg_tmp , hhx , hhy , aire_lin ) if ( nb_pt > 1 ) then vec_x ( nb_pt - 1 ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) vec_l ( nb_pt - 1 ) = log ( aire_lin ) endif if ( out_lin . and . nb_pt > 1 ) write ( unit_out_lin , * ) vec_x ( nb_pt - 1 ), vec_l ( nb_pt - 1 ) if ( out_ter ) write ( * , * ) aire_lin , long_tmp , larg_tmp endif if ( ip == npp + 1 ) then deallocate ( x_new , y_new , x , y , tab_ou ) exit endif long_new = nint ( long * ( rr ** ip )) ! nb points en suite géométrique larg_new = nint ( larg * ( rr ** ip )) new_it = . true . if ( long_new == long_tmp . or . larg_new == larg_tmp ) then new_it = . false . cycle ! à découper trop fin, on peut tomber sur les mêmes entiers endif hhx = width / ( long_new - 1 ) hhy = height / ( larg_new - 1 ) deallocate ( x_new , y_new , tab_ou ) allocate ( x_new ( 1 : long_new ), & y_new ( 1 : larg_new ), & ! nouvelles abscisses tab_ou ( 1 : long_new , 1 : larg_new ) ) nb_pt = nb_pt + 1 do i = 1 , long_new x_new ( i ) = hhx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg_new y_new ( j ) = hhy * real ( j - 1 , kind = R8 ) enddo do j = 1 , larg_new jj = locate ( n = larg , xx = y ( 1 : larg ), x = y_new ( j )) ym = y_new ( j ) - y ( jj ) ; yp = y_new ( j ) - y ( jj + 1 ) ym = ym / hy ; yp = yp / hy do i = 1 , long_new ii = locate ( n = long , xx = x ( 1 : long ), x = x_new ( i )) xm = x_new ( i ) - x ( ii ) ; xp = x_new ( i ) - x ( ii + 1 ) xm = xm / hx ; xp = xp / hx h1 = tab_in ( ii , jj ) h2 = tab_in ( ii + 1 , jj ) h3 = tab_in ( ii + 1 , jj + 1 ) h4 = tab_in ( ii , jj + 1 ) tab_ou ( i , j ) = h1 * xp * yp - h2 * xm * yp + h3 * xm * ym - h4 * xp * ym enddo enddo enddo if ( out_lin ) close ( unit_out_lin ) !call system('python pyt/filetoplot.py &') !............................................................. nb_pt = nb_pt - 1 vec_y ( 1 : nb_pt ) = vec_l ( 1 : nb_pt ) call interpolate_asfc ( bt = beta ( 1 : nb_beta ), & n_bt = nb_beta , & n_pt = nb_pt , & asf = asfc1 , & r2 = asfc2 ) asfc_res = [ - 1000 * asfc1 , asfc2 ] return contains subroutine interpolate_asfc ( bt , n_bt , n_pt , asf , r2 ) !================================================================================================ !< @note Function that fits the data points for the asfc determination.<br/> !        f\\_boltz(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( out ) :: asf !! *Asfc number* real ( kind = R8 ), intent ( out ) :: r2 !! *correlation number to assess validity of the Asfc calculus* real ( kind = R8 ), dimension ( 1 : n_pt , 1 : n_bt ) :: jacob real ( kind = R8 ), dimension ( 1 : n_pt ) :: v_x , v_y , res_y , pentes integer ( kind = I4 ) :: i0 , i , j , info real ( kind = R8 ) :: delta1 , delta2 , y_mean v_x ( 1 : n_pt ) = vec_x ( 1 : n_pt ) ! smoothing v_y ( 1 ) = vec_y ( 1 ) do i = 1 + 1 , n_pt - 1 v_y ( i ) = 0.25_R8 * ( vec_y ( i - 1 ) + 2 * vec_y ( i ) + vec_y ( i + 1 ) ) enddo v_y ( n_pt ) = vec_y ( n_pt ) call init_beta_boltz ( bt = bt ( 1 : n_bt ), & ! n_bt = n_bt , & ! v_x = v_x ( 1 : n_pt ), & ! v_y = v_y ( 1 : n_pt ), & ! n_pt = n_pt ) ! res_y ( 1 : n_pt ) = 0._R8 jacob ( 1 : n_pt , 1 : n_bt ) = 0._R8 call lmder1 ( fcn = lmder1_f , & ! m = n_pt , & ! n = n_bt , & ! x = bt ( 1 : n_bt ), & ! fvec = res_y ( 1 : n_pt ), & ! fjac = jacob ( 1 : n_pt , 1 : n_bt ), & ! ldfjac = n_pt , & ! tol = 1.0e-8_R8 , & ! info = info ) ! delta1 = 0._R8 delta2 = 0._R8 y_mean = sum ( vec_y ( 1 : n_pt ) ) / n_pt do i = 1 , n_pt delta1 = delta1 + ( vec_y ( i ) - f_boltz ( xi = vec_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt ) & ! ) ** 2 delta2 = delta2 + ( vec_y ( i ) - y_mean ) ** 2 enddo r2 = 1._R8 - delta1 / delta2 !~       if (r2<0) then !~       do i=1,n_pt !~       write(99,*) v_x(i), v_y(i) !~       enddo !~       stop 'error' !~       endif i0 = locate ( n = n_pt , & ! xx = v_x ( 1 : n_pt ), & ! x = bt ( 1 )) ! j = 0 do i = i0 - 5 , i0 + 5 if ( i < 1 . or . i > n_pt ) cycle j = j + 1 pentes ( j ) = + df_boltz ( xi = v_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt , & ! ivar = 0 ) ! enddo asf = sum ( pentes ( 1 : j ) / j ) return endsubroutine interpolate_asfc subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !================================================================================================ !< @note Function called by [[lmder1]] as part of **minpack**, modified by !        [Burkardt](https://people.sc.fsu.edu/~jburkardt/f_src/minpack/minpack.html) <br/> !        According *iflag* value it calculates the function [[f_boltz]] at the data points !        or the jacobian. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: m !! *number of points* integer ( kind = I4 ), intent ( in ) :: n !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ldfjac !! *leading dimension of fjac, which must be at least n* integer ( kind = I4 ), intent ( in ) :: iflag !! *which calculus to perform* real ( kind = R8 ), intent ( out ), dimension ( 1 : m ) :: fvec !! *vector of f_boltz(xi)* real ( kind = R8 ), intent ( out ), dimension ( 1 : ldfjac , 1 : n ) :: fjac !! *jacobian* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n ) :: x !! *parameter values* integer ( kind = I4 ) :: i , k select case ( iflag ) case ( 0 ) continue case ( 1 ) do i = 1 , m fvec ( i ) = f_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! n_beta = n ) & ! - vec_y ( i ) enddo case ( 2 ) do i = 1 , m do k = 1 , n fjac ( i , k ) = df_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! ivar = k , & ! n_beta = n ) ! enddo enddo case default write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop endselect return endsubroutine lmder1_f endsubroutine calcul_asfc_lin_all","tags":"","loc":"proc/calcul_asfc_lin_all.html"},{"title":"calcul_asfc_spl_all – TPGLIB","text":"private  subroutine calcul_asfc_spl_all(tab_in, scal, asfc_res) Return the asfc of a surface. The different grids are obtained by spline of degree 3 Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor Calls proc~~calcul_asfc_spl_all~~CallsGraph proc~calcul_asfc_spl_all calcul_asfc_spl_all db2ink db2ink proc~calcul_asfc_spl_all->db2ink db2val db2val proc~calcul_asfc_spl_all->db2val lmder1 lmder1 proc~calcul_asfc_spl_all->lmder1 proc~calcul_aire calcul_aire proc~calcul_asfc_spl_all->proc~calcul_aire proc~df_boltz df_boltz proc~calcul_asfc_spl_all->proc~df_boltz proc~f_boltz f_boltz proc~calcul_asfc_spl_all->proc~f_boltz proc~init_beta_boltz init_beta_boltz proc~calcul_asfc_spl_all->proc~init_beta_boltz proc~locate locate proc~calcul_asfc_spl_all->proc~locate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calcul_asfc_spl_all~~CalledByGraph proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_spl_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcul_asfc_spl_all ( tab_in , scal , asfc_res ) !================================================================================================ !! Return the *asfc* of a surface. The different grids are obtained by spline of degree 3 implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* integer ( kind = I4 ), parameter :: idx = 0 ! [[db2val]] input integer ( kind = I4 ), parameter :: idy = 0 ! [[db2val]] input real ( kind = R8 ), allocatable , dimension (:) :: x ! x points in original grid real ( kind = R8 ), allocatable , dimension (:) :: y ! y points in original grid integer ( kind = I4 ) :: long_new ! number of points in x dimension for new grid integer ( kind = I4 ) :: larg_new ! number of points in y dimension for new grid real ( kind = R8 ), allocatable , dimension (:) :: x_new ! new grid x points real ( kind = R8 ), allocatable , dimension (:) :: y_new ! new grid y points real ( kind = R8 ), allocatable , dimension (:,:) :: tab_ou ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: coeff , coeff_tmp real ( kind = R8 ), allocatable , dimension (:) :: tx , tx_tmp ! x knots real ( kind = R8 ), allocatable , dimension (:) :: ty , ty_tmp ! y knots real ( kind = R8 ) :: val , rr integer ( kind = I4 ) :: i , j , k , ip , long_tmp , larg_tmp integer ( kind = I4 ) :: iflag integer ( kind = I4 ) :: inbvx , inbvy , iloy integer ( kind = I4 ) :: nb_pt integer ( kind = I4 ), dimension ( 1 : 8 ) :: d1 , d2 real ( kind = R8 ), dimension ( 1 : nb_beta ) :: beta real ( kind = R8 ), dimension ( 1 : npp ) :: vec_l , vec_s real ( kind = R8 ), dimension ( 1 : npp ) :: vec_x ! points coordinates real ( kind = R8 ), dimension ( 1 : npp ) :: vec_y ! points coordinates real ( kind = R8 ), dimension ( 1 : 8 ) :: gx , gy , vf real ( kind = R8 ) :: asfc1 , asfc2 , aire , aire_lin , aire_tmp , x1 , x2 , y1 , y2 , val_x , val_y , width , height , hx , hy , hhx , hhy logical ( kind = I4 ) :: new_it integer ( kind = I4 ) :: long , larg long = scal % xres larg = scal % yres if ( out_lin ) open ( unit = unit_out_lin , file = \"out/asfc_lin_spl_all.txt\" ) if ( out_spl ) open ( unit = unit_out_spl , file = \"out/asfc_spl_spl_all.txt\" ) width = scal % lx height = scal % ly hx = width / ( long - 1 ) hy = height / ( larg - 1 ) ! définition d'abscisses pour l'interpolation par splines allocate ( x ( 1 : long ), y ( 1 : larg ) ) do i = 1 , long x ( i ) = hx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg y ( j ) = hy * real ( j - 1 , kind = R8 ) enddo rr = ( real ( long0 , kind = R8 ) / long ) ** ( UN / npp ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points rr = max ( rr , ( real ( larg0 , kind = R8 ) / larg ) ** ( UN / npp ) ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points allocate ( x_new ( 1 : long ), & y_new ( 1 : larg ), & ! nouvelles abscisses tab_ou ( 1 : long , 1 : larg ) ) x_new ( 1 : long ) = x ( 1 : long ) y_new ( 1 : larg ) = y ( 1 : larg ) tab_ou ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) ! pour chaque réduction de maillage, calcul du maillage résultant et de l'aire relative associée !............................................................. long_new = long larg_new = larg hhx = hx hhy = hy nb_pt = 1 new_it = . true . do ip = 1 , npp + 1 if ( new_it ) then long_tmp = long_new larg_tmp = larg_new ! calcul de l'aire relative call calcul_aire ( tab_ou ( 1 : long_tmp , 1 : larg_tmp ), long_tmp , larg_tmp , hhx , hhy , aire_lin ) !, rx=real(long-1, kind=R8)/(long_tmp-1), & ! ry=real(larg-1, kind=R8)/(larg_tmp-1)) allocate ( coeff_tmp ( 1 : long_tmp , 1 : larg_tmp ) ) allocate ( tx_tmp ( 1 :( long_tmp + kx )), & ty_tmp ( 1 :( larg_tmp + ky )) ) iflag = 0 call db2ink ( x = x_new ( 1 : long_tmp ), & nx = long_tmp , & y = y_new ( 1 : larg_tmp ), & ny = larg_tmp , & fcn = tab_ou ( 1 : long_tmp , 1 : larg_tmp ), & kx = kx , & ky = ky , & tx = tx_tmp ( 1 :( long_tmp + kx )), & ty = ty_tmp ( 1 :( larg_tmp + ky )), & bcoef = coeff_tmp ( 1 : long_tmp , 1 : larg_tmp ), & iflag = iflag ) if ( iflag /= 1 ) then write ( * , * ) iflag , long_tmp , larg_tmp , kx , ky stop 'error calling db2ink' endif if ( ip == 1 ) then allocate ( coeff ( 1 : long , 1 : larg ) ) allocate ( tx ( 1 :( long + kx )), & ty ( 1 :( larg + ky )) ) coeff ( 1 : long , 1 : larg ) = coeff_tmp ( 1 : long , 1 : larg ) tx ( 1 :( long + kx )) = tx_tmp ( 1 :( long + kx )) ty ( 1 :( larg + ky )) = ty_tmp ( 1 :( larg + ky )) endif inbvx = 1 inbvy = 1 iloy = 1 aire_tmp = 0._R8 !~             !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_PROCS) IF(MULTI_PROCS2) !~             !$OMP DO SCHEDULE (STATIC,(larg_tmp-1)/NB_PROCS) PRIVATE(i, k, iflag, val, y1, y2, x1, x2, d1, d2, gx, gy, vf) FIRSTPRIVATE(inbvx, inbvy, iloy) REDUCTION(+:aire_tmp) do j = 1 , larg_tmp - 1 y1 = y_new ( j ) + ( hhy / 2 ) * ( UN - UN / sqrt ( 3._R8 )) y2 = y_new ( j ) + ( hhy / 2 ) * ( UN + UN / sqrt ( 3._R8 )) do i = 1 , long_tmp - 1 x1 = x_new ( i ) + ( hhx / 2 ) * ( UN - UN / sqrt ( 3._R8 )) x2 = x_new ( i ) + ( hhx / 2 ) * ( UN + UN / sqrt ( 3._R8 )) d1 ( 1 : 8 ) = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] d2 ( 1 : 8 ) = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] gx ( 1 : 8 ) = [ x1 , x1 , x1 , x1 , x2 , x2 , x2 , x2 ] gy ( 1 : 8 ) = [ y1 , y1 , y2 , y2 , y1 , y1 , y2 , y2 ] do k = 1 , 8 call db2val ( xval = gx ( k ), & yval = gy ( k ), & idx = d1 ( k ), & idy = d2 ( k ), & tx = tx_tmp ( 1 :( long_tmp + kx )), & ty = ty_tmp ( 1 :( larg_tmp + ky )), & nx = long_tmp , & ny = larg_tmp , & kx = kx , & ky = ky , & bcoef = coeff_tmp ( 1 : long_tmp , 1 : larg_tmp ), & f = vf ( k ), & iflag = iflag , & inbvx = inbvx , & inbvy = inbvy , & iloy = iloy ) if ( iflag /= 0 ) then write ( * , * ) iflag stop 'error calling db2val' endif enddo do k = 1 , 4 val_x = vf ( 2 * k - 1 ) val_y = vf ( 2 * k ) aire_tmp = aire_tmp + sqrt ( UN + val_x ** 2 + val_y ** 2 ) enddo enddo enddo !~             !$OMP END DO !~             !$OMP END PARALLEL aire = aire_tmp * ( hhx / 2 ) * ( hhy / 2 ) aire = aire / ( width * height ) vec_x ( nb_pt ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) vec_l ( nb_pt ) = log ( aire_lin ) vec_s ( nb_pt ) = log ( aire ) if ( out_lin . and . nb_pt > 1 ) write ( unit_out_lin , * ) vec_x ( nb_pt - 1 ), vec_l ( nb_pt - 1 ) if ( out_spl . and . nb_pt > 1 ) write ( unit_out_spl , * ) vec_x ( nb_pt - 1 ), vec_s ( nb_pt - 1 ) if ( out_ter ) write ( * , * ) hhx , hhy , aire , ip endif if ( ip == npp + 1 ) then deallocate ( x_new , y_new , x , y , tab_ou , coeff , tx , ty , coeff_tmp , tx_tmp , ty_tmp ) exit endif long_new = nint ( long * ( rr ** ip )) ! nb points en suite géométrique larg_new = nint ( larg * ( rr ** ip )) new_it = . true . if ( long_new == long_tmp . or . larg_new == larg_tmp ) then new_it = . false . cycle ! à découper trop fin, on peut tomber sur les mêmes entiers endif hhx = width / ( long_new - 1 ) hhy = height / ( larg_new - 1 ) nb_pt = nb_pt + 1 deallocate ( x_new , y_new , tab_ou ) allocate ( x_new ( 1 : long_new ), & y_new ( 1 : larg_new ), & ! nouvelles abscisses tab_ou ( 1 : long_new , 1 : larg_new ) ) do i = 1 , long_new x_new ( i ) = hhx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg_new y_new ( j ) = hhy * real ( j - 1 , kind = R8 ) enddo inbvx = 1 inbvy = 1 iloy = 1 ! calcul des hauteurs de la surface interpolée !~          !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_PROCS) IF(MULTI_PROCS2) !~          !$OMP DO SCHEDULE (STATIC,larg_new/NB_PROCS) PRIVATE(i, iflag, val) FIRSTPRIVATE(inbvx, inbvy, iloy) do j = 1 , larg_new do i = 1 , long_new call db2val ( xval = x_new ( i ), & yval = y_new ( j ), & idx = idx , & idy = idy , & tx = tx ( 1 :( long + kx )), & ty = ty ( 1 :( larg + ky )), & nx = long , & ny = larg , & kx = kx , & ky = ky , & bcoef = coeff ( 1 : long , 1 : larg ), & f = val , & iflag = iflag , & inbvx = inbvx , & inbvy = inbvy , & iloy = iloy ) if ( iflag /= 0 ) error stop 'error calling db2val' iflag = 0 tab_ou ( i , j ) = val enddo enddo !~          !$OMP END DO !~          !$OMP END PARALLEL deallocate ( coeff_tmp , tx_tmp , ty_tmp ) enddo if ( out_lin ) close ( unit_out_lin ) if ( out_spl ) close ( unit_out_spl ) !............................................................. nb_pt = nb_pt - 1 vec_y ( 1 : nb_pt ) = vec_s ( 1 : nb_pt ) call interpolate_asfc ( bt = beta ( 1 : nb_beta ), & n_bt = nb_beta , & n_pt = nb_pt , & asf = asfc1 , & r2 = asfc2 ) asfc_res = [ - 1000 * asfc1 , asfc2 ] return contains subroutine interpolate_asfc ( bt , n_bt , n_pt , asf , r2 ) !================================================================================================ !< @note Function that fits the data points for the asfc determination.<br/> !        f\\_boltz(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( out ) :: asf !! *Asfc number* real ( kind = R8 ), intent ( out ) :: r2 !! *correlation number to assess validity of the Asfc calculus* real ( kind = R8 ), dimension ( 1 : n_pt , 1 : n_bt ) :: jacob real ( kind = R8 ), dimension ( 1 : n_pt ) :: v_x , v_y , res_y , pentes integer ( kind = I4 ) :: i0 , i , j , info real ( kind = R8 ) :: delta1 , delta2 , y_mean v_x ( 1 : n_pt ) = vec_x ( 1 : n_pt ) ! smoothing v_y ( 1 ) = vec_y ( 1 ) do i = 1 + 1 , n_pt - 1 v_y ( i ) = 0.25_R8 * ( vec_y ( i - 1 ) + 2 * vec_y ( i ) + vec_y ( i + 1 ) ) enddo v_y ( n_pt ) = vec_y ( n_pt ) call init_beta_boltz ( bt = bt ( 1 : n_bt ), & ! n_bt = n_bt , & ! v_x = v_x ( 1 : n_pt ), & ! v_y = v_y ( 1 : n_pt ), & ! n_pt = n_pt ) ! res_y ( 1 : n_pt ) = 0._R8 jacob ( 1 : n_pt , 1 : n_bt ) = 0._R8 call lmder1 ( fcn = lmder1_f , & ! m = n_pt , & ! n = n_bt , & ! x = bt ( 1 : n_bt ), & ! fvec = res_y ( 1 : n_pt ), & ! fjac = jacob ( 1 : n_pt , 1 : n_bt ), & ! ldfjac = n_pt , & ! tol = 1.0e-8_R8 , & ! info = info ) ! delta1 = 0._R8 delta2 = 0._R8 y_mean = sum ( vec_y ( 1 : n_pt ) ) / n_pt do i = 1 , n_pt delta1 = delta1 + ( vec_y ( i ) - f_boltz ( xi = vec_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt ) & ! ) ** 2 delta2 = delta2 + ( vec_y ( i ) - y_mean ) ** 2 enddo r2 = 1._R8 - delta1 / delta2 !~       if (r2<0) then !~       do i=1,n_pt !~       write(99,*) v_x(i), v_y(i) !~       enddo !~       stop 'error' !~       endif i0 = locate ( n = n_pt , & ! xx = v_x ( 1 : n_pt ), & ! x = bt ( 1 )) ! j = 0 do i = i0 - 5 , i0 + 5 if ( i < 1 . or . i > n_pt ) cycle j = j + 1 pentes ( j ) = + df_boltz ( xi = v_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt , & ! ivar = 0 ) ! enddo asf = sum ( pentes ( 1 : j ) / j ) return endsubroutine interpolate_asfc subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !================================================================================================ !< @note Function called by [[lmder1]] as part of **minpack**, modified by !        [Burkardt](https://people.sc.fsu.edu/~jburkardt/f_src/minpack/minpack.html) <br/> !        According *iflag* value it calculates the function [[f_boltz]] at the data points !        or the jacobian. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: m !! *number of points* integer ( kind = I4 ), intent ( in ) :: n !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ldfjac !! *leading dimension of fjac, which must be at least n* integer ( kind = I4 ), intent ( in ) :: iflag !! *which calculus to perform* real ( kind = R8 ), intent ( out ), dimension ( 1 : m ) :: fvec !! *vector of f_boltz(xi)* real ( kind = R8 ), intent ( out ), dimension ( 1 : ldfjac , 1 : n ) :: fjac !! *jacobian* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n ) :: x !! *parameter values* integer ( kind = I4 ) :: i , k select case ( iflag ) case ( 0 ) continue case ( 1 ) do i = 1 , m fvec ( i ) = f_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! n_beta = n ) & ! - vec_y ( i ) enddo case ( 2 ) do i = 1 , m do k = 1 , n fjac ( i , k ) = df_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! ivar = k , & ! n_beta = n ) ! enddo enddo case default write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop endselect return endsubroutine lmder1_f endsubroutine calcul_asfc_spl_all","tags":"","loc":"proc/calcul_asfc_spl_all.html"},{"title":"indice_fractal – TPGLIB","text":"public  subroutine indice_fractal(tab_in, long, larg, indf) Function that returns the fractal dimension with the box counting method Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long surface array length integer(kind=I4), intent(in) :: larg surface array width real(kind=R8), intent(out), dimension(3) :: indf result: ordinate at origin, slope, R2 Calls proc~~indice_fractal~~CallsGraph proc~indice_fractal indice_fractal moindres_carres_lineaire moindres_carres_lineaire proc~indice_fractal->moindres_carres_lineaire proc~calc_moments calc_moments proc~indice_fractal->proc~calc_moments proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~indice_fractal~~CalledByGraph proc~indice_fractal indice_fractal program~test_asfc test_asfc program~test_asfc->proc~indice_fractal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine indice_fractal ( tab_in , long , larg , indf ) !================================================================================================ !! Function that returns the fractal dimension with the box counting method implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface array length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* real ( kind = R8 ), intent ( out ), dimension ( 3 ) :: indf !! *result: ordinate at origin, slope, R2* integer ( kind = I4 ) :: i , j , k , ib , nbhmax , nni , nb , dec_i , dec_j , ri , rj real ( kind = R8 ) :: lboite , hhmax , hhmin , ddh , t1 , t2 , t3 , t4 , hmax , hmin real ( kind = R8 ) :: yibarr , yi_m_yichap , yi_m_yibarr , r2adj real ( kind = R8 ), dimension ( 1 : 2 ) :: var real ( kind = R8 ), allocatable , dimension (:,:) :: tab , Jf real ( kind = R8 ), allocatable , dimension (:) :: tab_nni integer ( kind = I4 ), allocatable , dimension (:,:) :: pas_i , pas_j integer ( kind = I4 ), allocatable , dimension (:) :: nnb type ( moment_stat ) :: mom call calc_moments ( tab = reshape ( tab_in ( 1 : long , 1 : larg ), [ long * larg ] ), & ! mx = mom , & ! nb_mom = 2 ) ! allocate ( tab ( 1 : long , 1 : larg )) tab ( 1 : long , 1 : larg ) = ( tab_in ( 1 : long , 1 : larg ) - mom % mu ) / mom % si hhmin = minval ( tab ( 1 : long , 1 : larg )) ! hauteur min de la surface tab ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) + hhmin + 1._R8 hhmax = maxval ( tab ( 1 : long , 1 : larg )) ! hauteur max de la surface hhmin = minval ( tab ( 1 : long , 1 : larg )) ! hauteur min de la surface ddh = hhmax - hhmin ! amplitude nbhmax = nint ( log ( UN * min ( long - 1 , larg - 1 ) ) / log ( 2. ) ) ! nbre max de comptages, attention il y a n-1 intervalles pour n points if ( 2 ** nbhmax > min ( long - 1 , larg - 1 )) nbhmax = nbhmax - 1 allocate ( Jf ( 1 : nbhmax , 1 : 2 ) ) allocate ( tab_nni ( 1 : nbhmax ) ) nb = 2 ** nbhmax ! nombre de boîtes dans une direction allocate ( pas_i ( 1 : nb , 1 : nbhmax ), pas_j ( 1 : nb , 1 : nbhmax ) ) allocate ( nnb ( 1 : nb ) ) pas_i = 0 pas_j = 0 pas_i ( 1 : nb , nbhmax ) = ( long - 1 ) / nb ! longueur moyenne d'UN pas selon x (le pas n'est pas forcément constant : nbpts /= 2**n +1, par exemple) pas_j ( 1 : nb , nbhmax ) = ( larg - 1 ) / nb ! id selon y ri = mod ( long - 1 , nb ) ! si la division au-dessus ne tombe pas juste, c'est le reste selon x rj = mod ( larg - 1 , nb ) ! id selon y if ( ri > 0 ) then ! s'il y a un résidu, répartition régulière de ce résidu sur le découpage le plus fin do i = 1 , ri pas_i ( ( i - 1 ) * ( nb / ri ) + 1 , nbhmax ) = pas_i ( ( i - 1 ) * ( nb / ri ) + 1 , nbhmax ) + 1 enddo endif if ( rj > 0 ) then do j = 1 , rj pas_j ( ( j - 1 ) * ( nb / rj ) + 1 , nbhmax ) = pas_j ( ( j - 1 ) * ( nb / rj ) + 1 , nbhmax ) + 1 enddo endif do ib = nbhmax - 1 , 1 , - 1 ! agglomération des pas 2 à 2 pour former le pas de la boîte englobante do k = 1 , 2 ** ib pas_i ( k , ib ) = pas_i ( 2 * ( k - 1 ) + 1 , ib + 1 ) + pas_i ( 2 * k , ib + 1 ) pas_j ( k , ib ) = pas_j ( 2 * ( k - 1 ) + 1 , ib + 1 ) + pas_j ( 2 * k , ib + 1 ) enddo enddo do ib = 1 , nbhmax ! niveau de découpage nb = 2 ** ib ! nombre de boîtes dans une direction pour ce découpage lboite = ( ddh - 2 * EPS_R8 ) / nb ! taille z de la boîte nni = 0 dec_i = 1 do i = 1 , nb ! numéro i de la colonne de boîtes dec_j = 1 do j = 1 , nb ! numéro j de la colonne de boîtes ! on considère le plan résultant de la coupe de la colonne par la surface t1 = tab ( dec_i , dec_j ) t2 = tab ( dec_i + pas_i ( i , ib ), dec_j ) t3 = tab ( dec_i + pas_i ( i , ib ), dec_j + pas_j ( j , ib )) t4 = tab ( dec_i , dec_j + pas_j ( j , ib )) ! ce plan traverse plusieurs boîtes, il suffit de les compter hmax = max ( t1 , t2 , t3 , t4 ) hmin = min ( t1 , t2 , t3 , t4 ) nni = nni + ceiling ( hmax / lboite ) & - floor ( hmin / lboite ) dec_j = dec_j + pas_j ( j , ib ) enddo dec_i = dec_i + pas_i ( i , ib ) enddo tab_nni ( ib ) = log ( UN * nni ) Jf ( ib , 1 ) = UN Jf ( ib , 2 ) = log ( UN / lboite ) enddo call moindres_carres_lineaire ( nb_var = 2 , & ! nb_pts = nbhmax , & ! hij = tab_nni ( 1 : nbhmax ), & ! beta = var ( 1 : 2 ), & ! Jf = Jf ( 1 : nbhmax , 1 : 2 ) ) ! yibarr = sum ( tab_nni ( 1 : nbhmax ) ) / ( nbhmax ) yi_m_yichap = 0 yi_m_yibarr = 0 do i = 1 , nbhmax yi_m_yichap = yi_m_yichap + ( tab_nni ( i ) - ( Jf ( i , 1 ) * var ( 1 ) + Jf ( i , 2 ) * var ( 2 ) ) ) ** 2 yi_m_yibarr = yi_m_yibarr + ( tab_nni ( i ) - yibarr ) ** 2 enddo r2adj = UN - ( yi_m_yichap / ( nbhmax - 2 )) / ( yi_m_yibarr / ( nbhmax - 1 )) indf = [ var ( 2 ), var ( 1 ), r2adj ] ! fractal index first deallocate ( tab , tab_nni , Jf , pas_i , pas_j , nnb ) return endsubroutine indice_fractal","tags":"","loc":"proc/indice_fractal.html"},{"title":"init_beta_boltz – TPGLIB","text":"private  subroutine init_beta_boltz(bt, n_bt, v_x, v_y, n_pt) Note Function that initializes the fitting tanh function f_boltz parameters. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:n_bt) :: bt vector of parameters integer(kind=I4), intent(in) :: n_bt number of parameters real(kind=R8), intent(in), dimension(1:n_pt) :: v_x x data to fit real(kind=R8), intent(in), dimension(1:n_pt) :: v_y y data to fit integer(kind=I4), intent(in) :: n_pt data vector length Called by proc~~init_beta_boltz~~CalledByGraph proc~init_beta_boltz init_beta_boltz proc~calcul_asfc_hermite calcul_asfc_hermite proc~calcul_asfc_hermite->proc~init_beta_boltz proc~calcul_asfc_lin_all calcul_asfc_lin_all proc~calcul_asfc_lin_all->proc~init_beta_boltz proc~calcul_asfc_spl_all calcul_asfc_spl_all proc~calcul_asfc_spl_all->proc~init_beta_boltz proc~calcul_asfc calcul_asfc proc~calcul_asfc->proc~calcul_asfc_hermite proc~calcul_asfc->proc~calcul_asfc_lin_all proc~calcul_asfc->proc~calcul_asfc_spl_all program~test_asfc test_asfc program~test_asfc->proc~calcul_asfc_hermite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_beta_boltz ( bt , n_bt , v_x , v_y , n_pt ) !================================================================================================ !< @note Function that initializes the fitting *tanh* function [[f_boltz]] parameters. !< !<   f_{boltz}(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( in ), dimension ( 1 : n_pt ) :: v_x !! *x data to fit* real ( kind = R8 ), intent ( in ), dimension ( 1 : n_pt ) :: v_y !! *y data to fit* real ( kind = R8 ) :: a , pente bt ( 1 ) = 0. !v_x(1) +(v_x(n_pt) -v_x(1))/3 bt ( 2 ) = ( sum ( v_y ( n_pt - 9 : n_pt ) ) + sum ( v_y ( 1 : 10 ) ) ) / ( 2 * 10 ) bt ( 3 ) = ( sum ( v_y ( n_pt - 1 : n_pt ) ) - sum ( v_y ( 1 : 02 ) ) ) / ( 2 * 2 ) !;  a = bt(3) !pente = (v_y(n_pt/2) -v_y(n_pt/4))/(v_x(n_pt/2) -v_x(n_pt/4)) bt ( 4 ) = 1. !a/pente return endsubroutine init_beta_boltz","tags":"","loc":"proc/init_beta_boltz.html"},{"title":"curv2 – TPGLIB","text":"public  subroutine curv2(tab, nx, ny, dx, dy, gradxx, gradyy) Note Function to calculate the double derivatives of a 2D array It implements the details given in ISO 25178. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradxx double derivative along x, x 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradyy double derivative along y, y 2D array Called by proc~~curv2~~CalledByGraph proc~curv2 curv2 proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~curv2 program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine curv2 ( tab , nx , ny , dx , dy , gradxx , gradyy ) !================================================================================================ !< @note Function to calculate the double derivatives of a 2D array !< !<  It implements the details given in ISO 25178. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *input 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradxx !! *double derivative along x, x 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradyy !! *double derivative along y, y 2D array* integer ( kind = I4 ) :: i , j !------------------------------------------------------------------ GRADXX i = 1 gradxx ( 1 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0812 * tab ( i + 0 , 1 : ny ) & ! - 3132 * tab ( i + 1 , 1 : ny ) & ! + 5265 * tab ( i + 2 , 1 : ny ) & ! - 5080 * tab ( i + 3 , 1 : ny ) & ! + 2970 * tab ( i + 4 , 1 : ny ) & ! - 0972 * tab ( i + 5 , 1 : ny ) & ! + 0137 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradxx ( 2 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0137 * tab ( i + 0 , 1 : ny ) & ! - 0147 * tab ( i + 1 , 1 : ny ) & ! - 0255 * tab ( i + 2 , 1 : ny ) & ! + 0470 * tab ( i + 3 , 1 : ny ) & ! - 0285 * tab ( i + 4 , 1 : ny ) & ! + 0093 * tab ( i + 5 , 1 : ny ) & ! - 0013 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradxx ( 3 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( - 0013 * tab ( i + 0 , 1 : ny ) & ! + 0228 * tab ( i + 1 , 1 : ny ) & ! - 0420 * tab ( i + 2 , 1 : ny ) & ! + 0200 * tab ( i + 3 , 1 : ny ) & ! + 0015 * tab ( i + 4 , 1 : ny ) & ! - 0012 * tab ( i + 5 , 1 : ny ) & ! + 0002 * tab ( i + 6 , 1 : ny ) ) ! do i = 4 , nx - 3 gradxx ( i , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 002 * tab ( i + 3 , 1 : ny ) & ! - 027 * tab ( i + 2 , 1 : ny ) & ! + 270 * tab ( i + 1 , 1 : ny ) & ! - 490 * tab ( i , 1 : ny ) & ! + 270 * tab ( i - 1 , 1 : ny ) & ! - 027 * tab ( i - 2 , 1 : ny ) & ! + 002 * tab ( i - 3 , 1 : ny ) ) ! enddo i = nx gradxx ( nx , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0812 * tab ( i - 0 , 1 : ny ) & ! - 3132 * tab ( i - 1 , 1 : ny ) & ! + 5265 * tab ( i - 2 , 1 : ny ) & ! - 5080 * tab ( i - 3 , 1 : ny ) & ! + 2970 * tab ( i - 4 , 1 : ny ) & ! - 0972 * tab ( i - 5 , 1 : ny ) & ! + 0137 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradxx ( nx - 1 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0137 * tab ( i - 0 , 1 : ny ) & ! - 0147 * tab ( i - 1 , 1 : ny ) & ! - 0255 * tab ( i - 2 , 1 : ny ) & ! + 0470 * tab ( i - 3 , 1 : ny ) & ! - 0285 * tab ( i - 4 , 1 : ny ) & ! + 0093 * tab ( i - 5 , 1 : ny ) & ! - 0013 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradxx ( nx - 2 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( - 0013 * tab ( i - 0 , 1 : ny ) & ! + 0228 * tab ( i - 1 , 1 : ny ) & ! - 0420 * tab ( i - 2 , 1 : ny ) & ! + 0200 * tab ( i - 3 , 1 : ny ) & ! + 0015 * tab ( i - 4 , 1 : ny ) & ! - 0012 * tab ( i - 5 , 1 : ny ) & ! + 0002 * tab ( i - 6 , 1 : ny ) ) ! !------------------------------------------------------------------ GRADYY j = 1 gradyy ( 1 : nx , 1 ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0812 * tab ( 1 : nx , j + 0 ) & ! - 3132 * tab ( 1 : nx , j + 1 ) & ! + 5265 * tab ( 1 : nx , j + 2 ) & ! - 5080 * tab ( 1 : nx , j + 3 ) & ! + 2970 * tab ( 1 : nx , j + 4 ) & ! - 0972 * tab ( 1 : nx , j + 5 ) & ! + 0137 * tab ( 1 : nx , j + 6 ) ) ! j = 1 gradyy ( 1 : nx , 2 ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0137 * tab ( 1 : nx , j + 0 ) & ! - 0147 * tab ( 1 : nx , j + 1 ) & ! - 0255 * tab ( 1 : nx , j + 2 ) & ! + 0470 * tab ( 1 : nx , j + 3 ) & ! - 0285 * tab ( 1 : nx , j + 4 ) & ! + 0093 * tab ( 1 : nx , j + 5 ) & ! - 0013 * tab ( 1 : nx , j + 6 ) ) ! j = 1 gradyy ( 1 : nx , 3 ) = ( UN / ( 180 * dy ** 2 ) ) * ( - 0013 * tab ( 1 : nx , j + 0 ) & ! + 0228 * tab ( 1 : nx , j + 1 ) & ! - 0420 * tab ( 1 : nx , j + 2 ) & ! + 0200 * tab ( 1 : nx , j + 3 ) & ! + 0015 * tab ( 1 : nx , j + 4 ) & ! - 0012 * tab ( 1 : nx , j + 5 ) & ! + 0002 * tab ( 1 : nx , j + 6 ) ) ! do j = 4 , ny - 3 gradyy ( 1 : nx , j ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 002 * tab ( 1 : nx , j + 3 ) & ! - 027 * tab ( 1 : nx , j + 2 ) & ! + 270 * tab ( 1 : nx , j + 1 ) & ! - 490 * tab ( 1 : nx , j ) & ! + 270 * tab ( 1 : nx , j - 1 ) & ! - 027 * tab ( 1 : nx , j - 2 ) & ! + 002 * tab ( 1 : nx , j - 3 ) ) ! enddo j = ny gradyy ( 1 : nx , ny ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0812 * tab ( 1 : nx , j - 0 ) & ! - 3132 * tab ( 1 : nx , j - 1 ) & ! + 5265 * tab ( 1 : nx , j - 2 ) & ! - 5080 * tab ( 1 : nx , j - 3 ) & ! + 2970 * tab ( 1 : nx , j - 4 ) & ! - 0972 * tab ( 1 : nx , j - 5 ) & ! + 0137 * tab ( 1 : nx , j - 6 ) ) ! j = ny gradyy ( 1 : nx , ny - 1 ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0137 * tab ( 1 : nx , j - 0 ) & ! - 0147 * tab ( 1 : nx , j - 1 ) & ! - 0255 * tab ( 1 : nx , j - 2 ) & ! + 0470 * tab ( 1 : nx , j - 3 ) & ! - 0285 * tab ( 1 : nx , j - 4 ) & ! + 0093 * tab ( 1 : nx , j - 5 ) & ! - 0013 * tab ( 1 : nx , j - 6 ) ) ! j = ny gradyy ( 1 : nx , ny - 2 ) = ( UN / ( 180 * dy ** 2 ) ) * ( - 0013 * tab ( 1 : nx , j - 0 ) & ! + 0228 * tab ( 1 : nx , j - 1 ) & ! - 0420 * tab ( 1 : nx , j - 2 ) & ! + 0200 * tab ( 1 : nx , j - 3 ) & ! + 0015 * tab ( 1 : nx , j - 4 ) & ! - 0012 * tab ( 1 : nx , j - 5 ) & ! + 0002 * tab ( 1 : nx , j - 6 ) ) ! return endsubroutine curv2","tags":"","loc":"proc/curv2.html"},{"title":"curvature – TPGLIB","text":"public  subroutine curvature(tab, nx, ny, dx, dy, S_param_grad, S_param_curv, gcurvt) Function to calculate the gaussian curvature of a 2D array,\n       its mean quadratic value and the gradient mean quadratic value Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out) :: S_param_grad mean quadratic gradient value real(kind=R8), intent(out) :: S_param_curv mean quadratic curvature value real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gcurvt gaussian curvature  2D array Calls proc~~curvature~~CallsGraph proc~curvature curvature proc~gauss_curv gauss_curv proc~curvature->proc~gauss_curv proc~gradient gradient proc~curvature->proc~gradient proc~gauss_curv->proc~gradient Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~curvature~~CalledByGraph proc~curvature curvature proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~curvature proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~curvature proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine curvature ( tab , nx , ny , dx , dy , S_param_grad , S_param_curv , gcurvt ) !================================================================================================ !! Function to calculate the gaussian curvature of a 2D array, !!        its mean quadratic value and the gradient mean quadratic value implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( out ) :: S_param_grad !! *mean quadratic gradient value* real ( kind = R8 ), intent ( out ) :: S_param_curv !! *mean quadratic curvature value* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *input 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gcurvt !! *gaussian curvature  2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradx !! *derivative along x 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: grady !! *derivative along y 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradxx !! *double derivative along x, x 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradyy !! *double derivative along y, y 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradxy !! *double derivative along x, y 2D array* allocate ( gradx ( 1 : nx , 1 : ny ) ) allocate ( grady ( 1 : nx , 1 : ny ) ) allocate ( gradxx ( 1 : nx , 1 : ny ) ) allocate ( gradxy ( 1 : nx , 1 : ny ) ) allocate ( gradyy ( 1 : nx , 1 : ny ) ) call gradient ( tab = tab ( 1 : nx , 1 : ny ), & ! IN nx = nx , & ! IN ny = ny , & ! IN dx = dx , & ! IN dy = dy , & ! IN gradx = gradx ( 1 : nx , 1 : ny ), & ! OUT grady = grady ( 1 : nx , 1 : ny )) ! OUT !~       S_param_grad = sum( sqrt( gradx(1:nx, 1:ny)**2 + grady(1:nx, 1:ny)**2 ) ) / (nx * ny) S_param_grad = sqrt ( sum ( gradx ( 1 : nx , 1 : ny ) ** 2 + grady ( 1 : nx , 1 : ny ) ** 2 ) ) / ( nx * ny ) call gauss_curv ( gradx = gradx ( 1 : nx , 1 : ny ), & ! IN grady = grady ( 1 : nx , 1 : ny ), & ! IN gradxx = gradxx ( 1 : nx , 1 : ny ), & ! OUT gradxy = gradxy ( 1 : nx , 1 : ny ), & ! OUT gradyy = gradyy ( 1 : nx , 1 : ny ), & ! OUT nx = nx , & ! IN ny = ny , & ! IN dx = dx , & ! IN dy = dy ) ! IN gcurvt ( 1 : nx , 1 : ny ) = ( gradxx ( 1 : nx , 1 : ny ) * gradyy ( 1 : nx , 1 : ny ) - gradxy ( 1 : nx , 1 : ny ) ** 2 ) / ( UN + gradx ( 1 : nx , 1 : ny ) ** 2 + grady ( 1 : nx , 1 : ny ) ** 2 ) ** 2 !~       S_param_curv = sum( sqrt( gradxx(1:nx, 1:ny)**2 + gradyy(1:nx, 1:ny)**2 ) ) / (nx * ny) S_param_curv = sqrt ( sum ( gradxx ( 1 : nx , 1 : ny ) ** 2 + gradyy ( 1 : nx , 1 : ny ) ** 2 ) ) / ( nx * ny ) deallocate ( gradx , grady , gradxy , gradxx , gradyy ) return endsubroutine curvature","tags":"","loc":"proc/curvature.html"},{"title":"deriv_N – TPGLIB","text":"private  subroutine deriv_N(x, y, mat_d) Note Function to provide the interpolation functions of a QU9 element, as well as its derivatives It implements the details given in code ASTER r3.01.01.pdf doc Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: x abscissa between -1 and +1 real(kind=R8), intent(in) :: y ordinate between -1 and +1 real(kind=R8), intent(out), dimension(1:9, 1:6) :: mat_d array containing N, dN/di, d2N/di2 Called by proc~~deriv_n~~CalledByGraph proc~deriv_n deriv_N proc~labelize_point labelize_point proc~labelize_point->proc~deriv_n proc~test_labelize_point test_labelize_point proc~test_labelize_point->proc~deriv_n proc~test_labelize_point->proc~labelize_point proc~label_surf_summits label_surf_summits proc~label_surf_summits->proc~labelize_point program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_labelize_point proc~test_label_surf_summits test_label_surf_summits program~test_grad_curv->proc~test_label_surf_summits proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures program~test_grad_curv->proc~test_peaks_and_pits_curvatures proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~label_surf_summits proc~test_label_surf_summits->proc~label_surf_summits proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine deriv_N ( x , y , mat_d ) !================================================================================================ !< @note Function to provide the interpolation functions of a QU9 element, as well as its derivatives !< !<  It implements the details given in code ASTER r3.01.01.pdf doc !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: x !! *abscissa between -1 and +1* real ( kind = R8 ), intent ( in ) :: y !! *ordinate between -1 and +1* real ( kind = R8 ), intent ( out ), dimension ( 1 : 9 , 1 : 6 ) :: mat_d !! *array containing N, dN/di, d2N/di2* real ( kind = R8 ) :: xm1 , xp1 , xm12 , xp12 , umx2 , dxm1 , dxp1 , xy real ( kind = R8 ) :: ym1 , yp1 , ym12 , yp12 , umy2 , dyp1 , dym1 xm1 = x - 1 ; xp1 = x + 1 ; xm12 = x - 1 / 2._R8 ; xp12 = x + 1 / 2._R8 ; umx2 = 1 - x ** 2 ; dxm1 = 2 * x - 1 ; dxp1 = 2 * x + 1 ; xy = x * y ym1 = y - 1 ; yp1 = y + 1 ; ym12 = y - 1 / 2._R8 ; yp12 = y + 1 / 2._R8 ; umy2 = 1 - y ** 2 ; dym1 = 2 * y - 1 ; dyp1 = 2 * y + 1 !     Nodes order: ! !     4---7---3 !     |   |   | !     8---9-- 6 !     |   |   | !     1---5---2 !     mat_d(1:6, .) = [ N(1:9), dNdx(1:9), dNdy(1:9), d2Ndx2(1:9), d2Ndxdy(1:9), d2Ndy2(1:9) ] mat_d ( 1 : 9 , 1 ) = [ xy * xm1 * ym1 / 4 , & ! 1 xy * xp1 * ym1 / 4 , & ! 2 xy * xp1 * yp1 / 4 , & ! 3 xy * xm1 * yp1 / 4 , & ! 4 y * umx2 * ym1 / 2 , & ! 5 x * umy2 * xp1 / 2 , & ! 6 y * umx2 * yp1 / 2 , & ! 7 x * umy2 * xm1 / 2 , & ! 8 umx2 * umy2 ] ! 9 mat_d ( 1 : 9 , 2 ) = [ dxm1 * y * ym1 / 4 , & ! 1 dxp1 * y * ym1 / 4 , & ! 2 dxp1 * y * yp1 / 4 , & ! 3 dxm1 * y * yp1 / 4 , & ! 4 - xy * ym1 , & ! 5 dxp1 * umy2 / 2 , & ! 6 - xy * yp1 , & ! 7 dxm1 * umy2 / 2 , & ! 8 - 2 * x * umy2 ] ! 9 mat_d ( 1 : 9 , 3 ) = [ x * xm1 * dym1 / 4 , & ! 1 x * xp1 * dym1 / 4 , & ! 2 x * xp1 * dyp1 / 4 , & ! 3 x * xm1 * dyp1 / 4 , & ! 4 umx2 * dym1 / 2 , & ! 5 - xy * xp1 , & ! 6 umx2 * dyp1 / 2 , & ! 7 - xy * xm1 , & ! 8 - 2 * y * umx2 ] ! 9 mat_d ( 1 : 9 , 4 ) = [ y * ym1 / 2 , & ! 1 y * ym1 / 2 , & ! 2 y * yp1 / 2 , & ! 3 y * yp1 / 2 , & ! 4 - y * ym1 , & ! 5 umy2 , & ! 6 - y * yp1 , & ! 7 umy2 , & ! 8 - 2 * umy2 ] ! 9 mat_d ( 1 : 9 , 5 ) = [ xm12 * ym12 , & ! 1 xp12 * ym12 , & ! 2 xp12 * yp12 , & ! 3 xm12 * yp12 , & ! 4 - x * dym1 , & ! 5 - y * dxp1 , & ! 6 - x * dyp1 , & ! 7 - y * dxm1 , & ! 8 + 4 * xy ] ! 9 mat_d ( 1 : 9 , 6 ) = [ x * xm1 / 2 , & ! 1 x * xp1 / 2 , & ! 2 x * xp1 / 2 , & ! 3 x * xm1 / 2 , & ! 4 + umx2 , & ! 5 - x * xp1 , & ! 6 + umx2 , & ! 7 - x * xm1 , & ! 8 - 2 * umx2 ] ! 9 return endsubroutine deriv_N","tags":"","loc":"proc/deriv_n.html"},{"title":"gauss_curv – TPGLIB","text":"public  subroutine gauss_curv(gradx, grady, nx, ny, dx, dy, gradxx, gradyy, gradxy) Function to calculate the double derivatives of a 2D array Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: gradx derivative along x 2D array real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: grady derivative along y 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradxx double derivative along x, x 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradyy double derivative along y, y 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradxy double derivative along x, y 2D array Calls proc~~gauss_curv~~CallsGraph proc~gauss_curv gauss_curv proc~gradient gradient proc~gauss_curv->proc~gradient Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_curv~~CalledByGraph proc~gauss_curv gauss_curv proc~curvature curvature proc~curvature->proc~gauss_curv proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~gauss_curv proc~test_peaks_and_pits_curvatures->proc~curvature proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~curvature program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gauss_curv ( gradx , grady , nx , ny , dx , dy , gradxx , gradyy , gradxy ) !================================================================================================ !! Function to calculate the double derivatives of a 2D array implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: gradx !! *derivative along x 2D array* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: grady !! *derivative along y 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradxx !! *double derivative along x, x 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradyy !! *double derivative along y, y 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradxy !! *double derivative along x, y 2D array* call gradient ( tab = gradx ( 1 : nx , 1 : ny ), & ! IN gradx = gradxx ( 1 : nx , 1 : ny ), & ! OUT grady = gradxy ( 1 : nx , 1 : ny ), & ! OUT nx = nx , & ! IN ny = ny , & ! IN dx = dx , & ! IN dy = dy ) ! IN call gradient ( tab = grady ( 1 : nx , 1 : ny ), & !IN gradx = gradxy ( 1 : nx , 1 : ny ), & !OUT grady = gradyy ( 1 : nx , 1 : ny ), & !OUT nx = nx , & !IN ny = ny , & !IN dx = dx , & !IN dy = dy ) !IN return endsubroutine gauss_curv","tags":"","loc":"proc/gauss_curv.html"},{"title":"gradient – TPGLIB","text":"public  subroutine gradient(tab, nx, ny, dx, dy, gradx, grady) Note Function to calculate the gradient of a 2D array It implements the details given in ISO 25178. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab Input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradx derivative along x 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: grady derivative along y 2D array Called by proc~~gradient~~CalledByGraph proc~gradient gradient proc~curvature curvature proc~curvature->proc~gradient proc~gauss_curv gauss_curv proc~curvature->proc~gauss_curv proc~gauss_curv->proc~gradient proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~gradient proc~test_peaks_and_pits_curvatures->proc~curvature proc~test_peaks_and_pits_curvatures->proc~gauss_curv proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~curvature program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gradient ( tab , nx , ny , dx , dy , gradx , grady ) !================================================================================================ !< @note Function to calculate the gradient of a 2D array !< !<  It implements the details given in ISO 25178. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *Input 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradx !! *derivative along x 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: grady !! *derivative along y 2D array* integer ( kind = I4 ) :: i , j !------------------------------------------------------------------ GRADX i = 1 gradx ( 1 , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( - 147 * tab ( i + 0 , 1 : ny ) & ! + 360 * tab ( i + 1 , 1 : ny ) & ! - 450 * tab ( i + 2 , 1 : ny ) & ! + 400 * tab ( i + 3 , 1 : ny ) & ! - 225 * tab ( i + 4 , 1 : ny ) & ! + 072 * tab ( i + 5 , 1 : ny ) & ! - 010 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradx ( 2 , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( - 010 * tab ( i + 0 , 1 : ny ) & ! - 077 * tab ( i + 1 , 1 : ny ) & ! + 150 * tab ( i + 2 , 1 : ny ) & ! - 100 * tab ( i + 3 , 1 : ny ) & ! + 050 * tab ( i + 4 , 1 : ny ) & ! - 015 * tab ( i + 5 , 1 : ny ) & ! + 002 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradx ( 3 , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( + 002 * tab ( i + 0 , 1 : ny ) & ! - 024 * tab ( i + 1 , 1 : ny ) & ! - 035 * tab ( i + 2 , 1 : ny ) & ! + 080 * tab ( i + 3 , 1 : ny ) & ! - 030 * tab ( i + 4 , 1 : ny ) & ! + 008 * tab ( i + 5 , 1 : ny ) & ! - 001 * tab ( i + 6 , 1 : ny ) ) ! do i = 4 , nx - 3 gradx ( i , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( + 01 * tab ( i + 3 , 1 : ny ) & ! - 09 * tab ( i + 2 , 1 : ny ) & ! + 45 * tab ( i + 1 , 1 : ny ) & ! - 45 * tab ( i - 1 , 1 : ny ) & ! + 09 * tab ( i - 2 , 1 : ny ) & ! - 01 * tab ( i - 3 , 1 : ny ) ) ! enddo i = nx gradx ( nx , 1 : ny ) = - ( UN / ( 60 * dx ) ) * ( - 147 * tab ( i - 0 , 1 : ny ) & ! + 360 * tab ( i - 1 , 1 : ny ) & ! - 450 * tab ( i - 2 , 1 : ny ) & ! + 400 * tab ( i - 3 , 1 : ny ) & ! - 225 * tab ( i - 4 , 1 : ny ) & ! + 072 * tab ( i - 5 , 1 : ny ) & ! - 010 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradx ( nx - 1 , 1 : ny ) = - ( UN / ( 60 * dx ) ) * ( - 010 * tab ( i - 0 , 1 : ny ) & ! - 077 * tab ( i - 1 , 1 : ny ) & ! + 150 * tab ( i - 2 , 1 : ny ) & ! - 100 * tab ( i - 3 , 1 : ny ) & ! + 050 * tab ( i - 4 , 1 : ny ) & ! - 015 * tab ( i - 5 , 1 : ny ) & ! + 002 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradx ( nx - 2 , 1 : ny ) = - ( UN / ( 60 * dx ) ) * ( + 002 * tab ( i - 0 , 1 : ny ) & ! - 024 * tab ( i - 1 , 1 : ny ) & ! - 035 * tab ( i - 2 , 1 : ny ) & ! + 080 * tab ( i - 3 , 1 : ny ) & ! - 030 * tab ( i - 4 , 1 : ny ) & ! + 008 * tab ( i - 5 , 1 : ny ) & ! - 001 * tab ( i - 6 , 1 : ny ) ) ! !------------------------------------------------------------------ GRADY j = 1 grady ( 1 : nx , 1 ) = ( UN / ( 60 * dy ) ) * ( - 147 * tab ( 1 : nx , j + 0 ) & ! + 360 * tab ( 1 : nx , j + 1 ) & ! - 450 * tab ( 1 : nx , j + 2 ) & ! + 400 * tab ( 1 : nx , j + 3 ) & ! - 225 * tab ( 1 : nx , j + 4 ) & ! + 072 * tab ( 1 : nx , j + 5 ) & ! - 010 * tab ( 1 : nx , j + 6 ) ) ! j = 1 grady ( 1 : nx , 2 ) = ( UN / ( 60 * dy ) ) * ( - 010 * tab ( 1 : nx , j + 0 ) & ! - 077 * tab ( 1 : nx , j + 1 ) & ! + 150 * tab ( 1 : nx , j + 2 ) & ! - 100 * tab ( 1 : nx , j + 3 ) & ! + 050 * tab ( 1 : nx , j + 4 ) & ! - 015 * tab ( 1 : nx , j + 5 ) & ! + 002 * tab ( 1 : nx , j + 6 ) ) ! j = 1 grady ( 1 : nx , 3 ) = ( UN / ( 60 * dy ) ) * ( + 002 * tab ( 1 : nx , j + 0 ) & ! - 024 * tab ( 1 : nx , j + 1 ) & ! - 035 * tab ( 1 : nx , j + 2 ) & ! + 080 * tab ( 1 : nx , j + 3 ) & ! - 030 * tab ( 1 : nx , j + 4 ) & ! + 008 * tab ( 1 : nx , j + 5 ) & ! - 001 * tab ( 1 : nx , j + 6 ) ) ! do j = 4 , ny - 3 grady ( 1 : nx , j ) = ( UN / ( 60 * dy ) ) * ( + 01 * tab ( 1 : nx , j + 3 ) & ! - 09 * tab ( 1 : nx , j + 2 ) & ! + 45 * tab ( 1 : nx , j + 1 ) & ! - 45 * tab ( 1 : nx , j - 1 ) & ! + 09 * tab ( 1 : nx , j - 2 ) & ! - 01 * tab ( 1 : nx , j - 3 ) ) ! enddo j = ny grady ( 1 : nx , ny ) = - ( UN / ( 60 * dy ) ) * ( - 147 * tab ( 1 : nx , j - 0 ) & ! + 360 * tab ( 1 : nx , j - 1 ) & ! - 450 * tab ( 1 : nx , j - 2 ) & ! + 400 * tab ( 1 : nx , j - 3 ) & ! - 225 * tab ( 1 : nx , j - 4 ) & ! + 072 * tab ( 1 : nx , j - 5 ) & ! - 010 * tab ( 1 : nx , j - 6 ) ) ! j = ny grady ( 1 : nx , ny - 1 ) = - ( UN / ( 60 * dy ) ) * ( - 010 * tab ( 1 : nx , j - 0 ) & ! - 077 * tab ( 1 : nx , j - 1 ) & ! + 150 * tab ( 1 : nx , j - 2 ) & ! - 100 * tab ( 1 : nx , j - 3 ) & ! + 050 * tab ( 1 : nx , j - 4 ) & ! - 015 * tab ( 1 : nx , j - 5 ) & ! + 002 * tab ( 1 : nx , j - 6 ) ) ! j = ny grady ( 1 : nx , ny - 2 ) = - ( UN / ( 60 * dy ) ) * ( + 002 * tab ( 1 : nx , j - 0 ) & ! - 024 * tab ( 1 : nx , j - 1 ) & ! - 035 * tab ( 1 : nx , j - 2 ) & ! + 080 * tab ( 1 : nx , j - 3 ) & ! - 030 * tab ( 1 : nx , j - 4 ) & ! + 008 * tab ( 1 : nx , j - 5 ) & ! - 001 * tab ( 1 : nx , j - 6 ) ) ! return endsubroutine gradient","tags":"","loc":"proc/gradient.html"},{"title":"gradient_corner – TPGLIB","text":"private  subroutine gradient_corner(hgt, gdx, gdy) Note Function that gives the nodal height gradients gdx : (2,1)----(2,2)----(2,3) : QU9 notation gdy : (1,2)----(2,2)----(3,2) : QU9 notation Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:3, 1:3) :: hgt local height 2D array real(kind=R8), intent(out), dimension(1:3) :: gdx nodal x gradient real(kind=R8), intent(out), dimension(1:3) :: gdy nodal x gradient Called by proc~~gradient_corner~~CalledByGraph proc~gradient_corner gradient_corner proc~label_surf_summits label_surf_summits proc~label_surf_summits->proc~gradient_corner proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~label_surf_summits proc~test_label_surf_summits test_label_surf_summits proc~test_label_surf_summits->proc~label_surf_summits proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_label_surf_summits program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gradient_corner ( hgt , gdx , gdy ) !================================================================================================ !< @note Function that gives the nodal height gradients !< !< gdx : (2,1)----(2,2)----(2,3) : QU9 notation !< !< gdy : (1,2)----(2,2)----(3,2) : QU9 notation !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 , 1 : 3 ) :: hgt !! *local height 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : 3 ) :: gdx !! *nodal x gradient* real ( kind = R8 ), intent ( out ), dimension ( 1 : 3 ) :: gdy !! *nodal x gradient* !~       real(kind=R8), dimension(1:9) :: tab !~       tab(1:9) = [ hgt(1, 1), & 1 !  (3,1)----(3,2)----(3,3) !~                    hgt(1, 3), & 2 !    |        |        | !~                    hgt(3, 3), & 3 !    |        |        | !~                    hgt(3, 1), & 4 !  (2,1)----(2,2)----(2,3) !~                    hgt(1, 2), & 5 !    |        |        | !~                    hgt(2, 3), & 6 !    |        |        | !~                    hgt(3, 2), & 7 !  (1,1)----(1,2)----(1,3) !~                    hgt(2, 1), & 8 ! !~                    hgt(2, 2) ]  9 ! ! (3,1)----(3,2)----(3,3) !   |        |        | !   |        |        | ! (2,1)----(2,2)----(2,3) !   |        |        | !   |        |        | ! (1,1)----(1,2)----(1,3) gdx ( 1 : 3 ) = [ - 1.5_R8 * hgt ( 2 , 1 ), & ! + 0.0_R8 * hgt ( 2 , 2 ), & ! + 1.5_R8 * hgt ( 2 , 3 ) ] ! gdy ( 1 : 3 ) = [ - 1.5_R8 * hgt ( 1 , 2 ), & ! + 0.0_R8 * hgt ( 2 , 2 ), & ! + 1.5_R8 * hgt ( 3 , 2 ) ] ! !~       gdx(1:9) = [ -1.5_R8 * tab(1), &  ! !~                    +1.5_R8 * tab(2), &  ! !~                    +1.5_R8 * tab(3), &  ! !~                    -1.5_R8 * tab(4), &  ! !~                    +0.0_R8 * tab(5), &  ! !~                    +1.5_R8 * tab(6), &  ! !~                    +0.0_R8 * tab(7), &  ! !~                    -1.5_R8 * tab(8), &  ! !~                    +0.0_R8 * tab(9) ]   ! !~       gdy(1:9) = [ -1.5_R8 * tab(1), &  ! !~                    -1.5_R8 * tab(2), &  ! !~                    +1.5_R8 * tab(3), &  ! !~                    +1.5_R8 * tab(4), &  ! !~                    -1.5_R8 * tab(5), &  ! !~                    +0.0_R8 * tab(6), &  ! !~                    +1.5_R8 * tab(7), &  ! !~                    +0.0_R8 * tab(8), &  ! !~                    +0.0_R8 * tab(9) ]   ! return endsubroutine gradient_corner","tags":"","loc":"proc/gradient_corner.html"},{"title":"label_surf_summits – TPGLIB","text":"public  subroutine label_surf_summits(tab, nx, ny, valleys, peaks, saddles, nb_summits) Function to output the extrema of a 2D array, as peaks, valleys or saddles. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along y integer(kind=I4), intent(out), dimension(:,:), allocatable :: valleys list of valley coordinates integer(kind=I4), intent(out), dimension(:,:), allocatable :: peaks list of peaks coordinates integer(kind=I4), intent(out), dimension(:,:), allocatable :: saddles list of saddles coordinates integer(kind=I4), intent(out), dimension(1:3) :: nb_summits number of extrema of each kind Calls proc~~label_surf_summits~~CallsGraph proc~label_surf_summits label_surf_summits proc~gradient_corner gradient_corner proc~label_surf_summits->proc~gradient_corner proc~labelize_point labelize_point proc~label_surf_summits->proc~labelize_point selectcase selectcase proc~label_surf_summits->selectcase proc~deriv_n deriv_N proc~labelize_point->proc~deriv_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~label_surf_summits~~CalledByGraph proc~label_surf_summits label_surf_summits proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~label_surf_summits proc~test_label_surf_summits test_label_surf_summits proc~test_label_surf_summits->proc~label_surf_summits proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_label_surf_summits program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine label_surf_summits ( tab , nx , ny , valleys , peaks , saddles , nb_summits ) !================================================================================================ !! Function to output the extrema of a 2D array, as peaks, valleys or saddles. implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *input 2D array* integer ( kind = I4 ), intent ( out ), dimension ( 1 : 3 ) :: nb_summits !! *number of extrema of each kind* integer ( kind = I4 ), intent ( out ), dimension (:,:), allocatable :: valleys !! *list of valley coordinates* integer ( kind = I4 ), intent ( out ), dimension (:,:), allocatable :: peaks !! *list of peaks coordinates* integer ( kind = I4 ), intent ( out ), dimension (:,:), allocatable :: saddles !! *list of saddles coordinates* integer ( kind = I4 ) :: i , j integer ( kind = I4 ) :: ip ! peak counter integer ( kind = I4 ) :: iv ! valley counter integer ( kind = I4 ) :: is ! saddle counter character ( len = 1 ) :: label integer ( kind = I4 ), dimension ( 1 : 3 , 1 : 3 ) :: tp integer ( kind = I4 ), dimension (:,:), allocatable :: topo ! point kind 2D array real ( kind = R8 ), dimension ( 1 : 3 , 1 : 3 ) :: ht real ( kind = R8 ), dimension ( 1 : 3 ) :: gdx , gdy ! gradient vectors allocate ( topo ( 1 : nx , 1 : ny ) ) topo ( 1 : nx , 1 : ny ) = 0 ! Loop through each point in the surface ip = 1 ; iv = 1 ; is = 1 do i = 1 + 1 , nx - 1 do j = 1 + 1 , ny - 1 tp ( 1 : 3 , 1 : 3 ) = topo ( i - 1 : i + 1 , j - 1 : j + 1 ) ht ( 1 : 3 , 1 : 3 ) = tab ( i - 1 : i + 1 , j - 1 : j + 1 ) ! if the gradients along x (resp. y) have the same sign, there is no extremum in the middle node call gradient_corner ( hgt = ht ( 1 : 3 , 1 : 3 ), & ! in gdx = gdx ( 1 : 3 ), & ! out gdy = gdy ( 1 : 3 ) ) ! out !~             if ( all( [gdx(6) > 0, gdx(8) > 0, gdx(9) > 0] ) .or. all( [gdy(5) > 0, gdy(7) > 0, gdy(9) > 0] ) ) cycle !~             if ( all( [gdx(6) > 0, gdx(8) > 0, gdx(9) > 0] ) .or. all( [gdy(5) < 0, gdy(7) < 0, gdy(9) < 0] ) ) cycle !~             if ( all( [gdx(6) < 0, gdx(8) < 0, gdx(9) < 0] ) .or. all( [gdy(5) < 0, gdy(7) < 0, gdy(9) < 0] ) ) cycle !~             if ( all( [gdx(6) < 0, gdx(8) < 0, gdx(9) < 0] ) .or. all( [gdy(5) > 0, gdy(7) > 0, gdy(9) > 0] ) ) cycle if ( all ( gdx ( 1 : 3 ) > 0 ) . or . all ( gdy ( 1 : 3 ) > 0 ) ) cycle if ( all ( gdx ( 1 : 3 ) > 0 ) . or . all ( gdy ( 1 : 3 ) < 0 ) ) cycle if ( all ( gdx ( 1 : 3 ) < 0 ) . or . all ( gdy ( 1 : 3 ) < 0 ) ) cycle if ( all ( gdx ( 1 : 3 ) < 0 ) . or . all ( gdy ( 1 : 3 ) > 0 ) ) cycle ! condition to avoid summits glued to each other: if a summit has been found in the neighborhood, cycle. if ( any ( [ tp ( 1 , 1 ) > 0 , & ! tp ( 1 , 2 ) > 0 , & ! tp ( 1 , 3 ) > 0 , & ! tp ( 2 , 1 ) > 0 ] ) ) cycle call labelize_point ( height = ht ( 1 : 3 , 1 : 3 ), & ! in label = label ) ! out selectcase ( label ) case ( 'V' ) ; topo ( i , j ) = 1 ; iv = iv + 1 ! one valley more detected case ( 'S' ) ; topo ( i , j ) = 2 ; is = is + 1 ! one saddle more detected case ( 'P' ) ; topo ( i , j ) = 3 ; ip = ip + 1 ! one peak   more detected endselect enddo enddo nb_summits = [ iv - 1 , is - 1 , ip - 1 ] ! now the number of extrema is known allocate ( valleys ( 1 : nb_summits ( 1 ), 1 : 2 ) ) allocate ( saddles ( 1 : nb_summits ( 2 ), 1 : 2 ) ) allocate ( peaks ( 1 : nb_summits ( 3 ), 1 : 2 ) ) ip = 1 ; iv = 1 ; is = 1 do i = 1 + 1 , nx - 1 do j = 1 + 1 , ny - 1 selectcase ( topo ( i , j ) ) case ( 1 ) ; valleys ( iv , 1 ) = i ; valleys ( iv , 2 ) = j ; iv = iv + 1 case ( 2 ) ; saddles ( is , 1 ) = i ; saddles ( is , 2 ) = j ; is = is + 1 case ( 3 ) ; peaks ( ip , 1 ) = i ; peaks ( ip , 2 ) = j ; ip = ip + 1 endselect enddo enddo deallocate ( topo ) return endsubroutine label_surf_summits","tags":"","loc":"proc/label_surf_summits.html"},{"title":"labelize_point – TPGLIB","text":"private  subroutine labelize_point(height, label, x, y) Function to label a point as: peak, valley, saddle or nothing particular Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:3, 1:3) :: height nodal height values as a 2D array character(len=1), intent(out) :: label kind of point real(kind=R8), intent(out), optional :: x coordinates of the extremum found real(kind=R8), intent(out), optional :: y coordinates of the extremum found Calls proc~~labelize_point~~CallsGraph proc~labelize_point labelize_point proc~deriv_n deriv_N proc~labelize_point->proc~deriv_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~labelize_point~~CalledByGraph proc~labelize_point labelize_point proc~label_surf_summits label_surf_summits proc~label_surf_summits->proc~labelize_point proc~test_labelize_point test_labelize_point proc~test_labelize_point->proc~labelize_point proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~peaks_and_pits_curvatures->proc~label_surf_summits proc~test_label_surf_summits test_label_surf_summits proc~test_label_surf_summits->proc~label_surf_summits program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_labelize_point program~test_grad_curv->proc~test_label_surf_summits proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures program~test_grad_curv->proc~test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine labelize_point ( height , label , x , y ) !================================================================================================ !! Function to label a point as: peak, valley, saddle or nothing particular implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 , 1 : 3 ) :: height !! *nodal height values as a 2D array* character ( len = 1 ), intent ( out ) :: label !! *kind of point* real ( kind = R8 ), intent ( out ), optional :: x , y !! *coordinates of the extremum found* real ( kind = R8 ), dimension ( 1 : 9 ) :: tab real ( kind = R8 ), dimension ( 1 : 9 , 1 : 6 ) :: derivatives real ( kind = R8 ) :: h , dhdx , dhdy , d2hdx2 , d2hdy2 , d2hdxdy , delta , dx , dy real ( kind = R8 ) :: xs , ys real ( kind = R8 ), parameter :: eps = 1.0e-8_R8 integer ( kind = I4 ) :: k , status ! following QU9 node notation: tab ( 1 : 9 ) = [ height ( 1 , 1 ), & !  (3,1)----(3,2)----(3,3) height ( 1 , 3 ), & !    |        |        | height ( 3 , 3 ), & !    |        |        | height ( 3 , 1 ), & !  (2,1)----(2,2)----(2,3) height ( 1 , 2 ), & !    |        |        | height ( 2 , 3 ), & !    |        |        | height ( 3 , 2 ), & !  (1,1)----(1,2)----(1,3) height ( 2 , 1 ), & ! height ( 2 , 2 ) ] ! ! Newton Raphson to locate the null first derivatives, which means an extremum ! Intiate with the center of the square [-1,1]X[-1,1] and initalize the counting ! xs = 0 ; ys = 0 ; k = 0 do ! for the current coordinates, what are the surface height and its derivatives: call deriv_N ( x = xs , y = ys , mat_d = derivatives ( 1 : 9 , 1 : 6 )) dhdx = sum ( derivatives ( 1 : 9 , 2 ) * tab ( 1 : 9 ) ) dhdy = sum ( derivatives ( 1 : 9 , 3 ) * tab ( 1 : 9 ) ) d2hdx2 = sum ( derivatives ( 1 : 9 , 4 ) * tab ( 1 : 9 ) ) d2hdxdy = sum ( derivatives ( 1 : 9 , 5 ) * tab ( 1 : 9 ) ) d2hdy2 = sum ( derivatives ( 1 : 9 , 6 ) * tab ( 1 : 9 ) ) ! jacobian denominator delta = d2hdx2 * d2hdy2 - d2hdxdy ** 2 if ( abs ( dhdx ) < eps . and . abs ( dhdy ) < eps ) then ! converge ok status = 0 ! extremum found, whatever its kind exit ! nothing more to do endif if ( abs ( xs ) >= 5._R8 . or . abs ( ys ) >= 5._R8 ) then ! during the convergence process, the point is far from the square, so exit status = 1 ! with the appropriate status exit ! endif ! k = k + 1 if ( k > 1000 ) then ! limit the number of iterations status = 1 exit endif dx = ( - 1. / delta ) * ( + d2hdy2 * dhdx - d2hdxdy * dhdy ) dy = ( - 1. / delta ) * ( - d2hdxdy * dhdx + d2hdx2 * dhdy ) xs = xs + 0.9 * dx ys = ys + 0.9 * dy enddo ! outside the square [-0.5,0.5]X[-0.5,0.5] the extremum belongs to another node if ( abs ( xs ) > 0.5_R8 . or . abs ( ys ) > 0.5_R8 ) status = 1 ! if derivatives are null, what kind of point is it ? !     Nodes order: ! !     4---7---3 !     |   |   | !     8---9-- 6 !     |   |   | !     1---5---2 if ( status == 0 ) then call deriv_N ( x = xs , y = ys , mat_d = derivatives ( 1 : 9 , 1 : 6 )) ! height at the extremum point xs, ys h = sum ( derivatives ( 1 : 9 , 1 ) * tab ( 1 : 9 ) ) if ( all ( tab ( 1 : 8 ) >= h ) ) then ; label = 'V' ! valley or pit elseif ( all ( tab ( 1 : 8 ) <= h ) ) then ; label = 'P' ! hill or peak else ; label = 'S' ! saddle endif else label = 'N' ! nothing particular endif if ( present ( x ) ) then x = xs y = ys endif return endsubroutine labelize_point","tags":"","loc":"proc/labelize_point.html"},{"title":"peaks_and_pits_curvatures – TPGLIB","text":"public  subroutine peaks_and_pits_curvatures(heights, nx, ny, dx, dy, S_param_grad, S_param_curv, peak_curv, pits_curv) Function to calculate and output the peaks and pits curvatures as well as then mean quadratic\n       gradient value and the mean quadratic curvature value. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: heights input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out) :: S_param_grad mean quadratic gradient value real(kind=R8), intent(out) :: S_param_curv mean quadratic curvature value real(kind=R8), intent(out) :: peak_curv 3 first peaks mean curvature real(kind=R8), intent(out) :: pits_curv 3 first pits  mean curvature Calls proc~~peaks_and_pits_curvatures~~CallsGraph proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~curvature curvature proc~peaks_and_pits_curvatures->proc~curvature proc~label_surf_summits label_surf_summits proc~peaks_and_pits_curvatures->proc~label_surf_summits sort_array2 sort_array2 proc~peaks_and_pits_curvatures->sort_array2 proc~gauss_curv gauss_curv proc~curvature->proc~gauss_curv proc~gradient gradient proc~curvature->proc~gradient proc~gradient_corner gradient_corner proc~label_surf_summits->proc~gradient_corner proc~labelize_point labelize_point proc~label_surf_summits->proc~labelize_point selectcase selectcase proc~label_surf_summits->selectcase proc~gauss_curv->proc~gradient proc~deriv_n deriv_N proc~labelize_point->proc~deriv_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~peaks_and_pits_curvatures~~CalledByGraph proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine peaks_and_pits_curvatures ( heights , nx , ny , dx , dy , S_param_grad , S_param_curv , peak_curv , pits_curv ) !================================================================================================ !! Function to calculate and output the peaks and pits curvatures as well as then mean quadratic !!        gradient value and the mean quadratic curvature value. implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( out ) :: peak_curv !! *3 first peaks mean curvature* real ( kind = R8 ), intent ( out ) :: pits_curv !! *3 first pits  mean curvature* real ( kind = R8 ), intent ( out ) :: S_param_grad !! *mean quadratic gradient value* real ( kind = R8 ), intent ( out ) :: S_param_curv !! *mean quadratic curvature value* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: heights !! *input 2D array* integer ( kind = I4 ) :: i , npeak , npits real ( kind = R8 ) :: spg , spc , adim integer ( kind = I4 ), allocatable , dimension (:,:) :: vall , peak , sadd integer ( kind = I4 ), dimension ( 1 : 3 ) :: nb_extr real ( kind = R8 ), dimension ( 1 : nx * ny ) :: tpits real ( kind = R8 ), dimension ( 1 : nx * ny ) :: tpeak real ( kind = R8 ), allocatable , dimension (:,:) :: cvt allocate ( cvt ( 1 : nx , 1 : ny ) ) ! first determine the surface curvature call curvature ( tab = heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in S_param_grad = spg , & ! out S_param_curv = spc , & ! out gcurvt = cvt ( 1 : nx , 1 : ny )) ! out ! OUTPUT S_param_grad = spg S_param_curv = spc ! no need to carry very high/low values, so normalize curvature adim = maxval ( abs ( cvt ( 1 : nx , 1 : ny )) ) cvt ( 1 : nx , 1 : ny ) = cvt ( 1 : nx , 1 : ny ) / adim call label_surf_summits ( tab = cvt ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in valleys = vall , & ! out peaks = peak , & ! out saddles = sadd , & ! out nb_summits = nb_extr ( 1 : 3 )) ! out !..................................................... npits = nb_extr ( 1 ) do i = 1 , npits tpits ( i ) = cvt ( vall ( i , 1 ), vall ( i , 2 ) ) ! first values needed, so ascending sort is OK enddo call sort_array2 ( tab_inout = tpits ( 1 : npits ), & ! inout n = npits ) ! in ! OUTPUT pits_curv = adim * sum ( tpits ( 1 : 3 ) ) / 3. ! mean of first 3 values, with the right dimension !..................................................... npeak = nb_extr ( 3 ) do i = 1 , npeak tpeak ( i ) = - cvt ( peak ( i , 1 ), peak ( i , 2 ) ) ! top values of peak needed, so reverse for ascending sort enddo call sort_array2 ( tab_inout = tpeak ( 1 : npeak ), & ! inout n = npeak ) ! in ! OUTPUT peak_curv = - adim * sum ( tpeak ( 1 : 3 ) ) / 3 ! mean of first 3 values, with the right dimension and the right sign deallocate ( cvt , vall , peak , sadd ) return endsubroutine peaks_and_pits_curvatures","tags":"","loc":"proc/peaks_and_pits_curvatures.html"},{"title":"test_label_surf_summits – TPGLIB","text":"public  subroutine test_label_surf_summits() Function to test the capicity in detecting peaks, pits and saddles in a simple double sinus\n       surface. Arguments None Calls proc~~test_label_surf_summits~~CallsGraph proc~test_label_surf_summits test_label_surf_summits init_scal init_scal proc~test_label_surf_summits->init_scal proc~label_surf_summits label_surf_summits proc~test_label_surf_summits->proc~label_surf_summits write_surf write_surf proc~test_label_surf_summits->write_surf proc~gradient_corner gradient_corner proc~label_surf_summits->proc~gradient_corner proc~labelize_point labelize_point proc~label_surf_summits->proc~labelize_point selectcase selectcase proc~label_surf_summits->selectcase proc~deriv_n deriv_N proc~labelize_point->proc~deriv_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test_label_surf_summits~~CalledByGraph proc~test_label_surf_summits test_label_surf_summits program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_label_surf_summits Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test_label_surf_summits () !================================================================================================ !! Function to test the capicity in detecting peaks, pits and saddles in a simple double sinus !!        surface. implicit none integer ( kind = I4 ), allocatable , dimension (:,:) :: topo integer ( kind = I4 ), allocatable , dimension (:,:) :: vall , peak , sadd real ( kind = R8 ), allocatable , dimension (:,:) :: heights integer ( kind = I4 ), dimension ( 1 : 3 ) :: nb_null_derivatives integer ( kind = I4 ), parameter :: nx = 750 , ny = 1000 integer ( kind = I4 ) :: i , j , i1 , j1 type ( SCALE_SURF ) :: scal ! create a \"digital surf\" object call init_scal ( scal = scal , & ! out; creates a surface type, containing ... nx = nx , & !  in; ... the number of points along x ... ny = ny , & !  in; ... the number of points along y ... lx = nx * 1.e-6_R8 , & !  in; ... the length (default unit : m) ... ly = ny * 1.e-6_R8 , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. allocate ( heights ( 1 : nx , 1 : ny ) ) allocate ( topo ( 1 : nx , 1 : ny ) ) do i = 1 , nx do j = 1 , ny heights ( i , j ) = sinsin ( i , j , nx , ny ) enddo enddo call write_surf ( nom_fic = \"out/test_sinus.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal ) ! call label_surf_summits ( tab = heights ( 1 : nx , 1 : ny ), & ! nx = nx , & ! ny = ny , & ! valleys = vall , & ! peaks = peak , & ! saddles = sadd , & ! nb_summits = nb_null_derivatives ( 1 : 3 ) ) ! write ( * , * ) nb_null_derivatives ( 1 : 3 ) ! csv to compare computed and theoretical values open ( 10 , file = 'out/extrema.csv' ) do i = 1 , nb_null_derivatives ( 1 ) write ( 10 , * ) 'comput,' , vall ( i , 1 ), ',' , vall ( i , 2 ), ',' , '1,VALLEY' enddo do i = 1 , nb_null_derivatives ( 2 ) write ( 10 , * ) 'comput,' , sadd ( i , 1 ), ',' , sadd ( i , 2 ), ',' , '2,SADDLE' enddo do i = 1 , nb_null_derivatives ( 3 ) write ( 10 , * ) 'comput,' , peak ( i , 1 ), ',' , peak ( i , 2 ), ',' , '3,PEAK' enddo do i = 0 , 2 i1 = int ( nx * ( 0.5 + i ) / 3. ) do j = 0 , 5 j1 = int ( ny * ( 0.5 + j ) / 6. ) if ( ( j == 2 * ( j / 2 ) . and . i == 2 * ( i / 2 ) ) . or . & ! ( j == 2 * ( j / 2 ) + 1 . and . i == 2 * ( i / 2 ) + 1 ) ) then ! write ( 10 , * ) 'theory,' , i1 , ',' , j1 , ',' , '3,PEAK' else write ( 10 , * ) 'theory,' , i1 , ',' , j1 , ',' , '1,VALLEY' endif enddo enddo do i = 0 , 2 i1 = int ( nx * ( 1.0 + i ) / 3. ) do j = 0 , 5 j1 = int ( ny * ( 1.0 + j ) / 6. ) if ( j1 /= ny . and . i1 /= nx ) write ( 10 , * ) 'theory,' , i1 , ',' , j1 , ',' , '2,SADDLE' enddo enddo close ( 10 ) deallocate ( heights , topo , vall , peak , sadd ) contains real ( kind = R8 ) function sinsin ( i , j , nx , ny ) implicit none integer ( kind = I4 ), intent ( in ) :: i , j , nx , ny sinsin = sin ( 3 * PI_R8 * i / nx + 1.e-8_R8 ) * sin ( 6 * PI_R8 * j / ny + 2.e-8_R8 ) return endfunction sinsin endsubroutine test_label_surf_summits","tags":"","loc":"proc/test_label_surf_summits.html"},{"title":"test_labelize_point – TPGLIB","text":"public  subroutine test_labelize_point() Function to test the function “labelize_point” on a QU9 domain with a 2nd order polynomial\n       along x and y Arguments None Calls proc~~test_labelize_point~~CallsGraph proc~test_labelize_point test_labelize_point proc~deriv_n deriv_N proc~test_labelize_point->proc~deriv_n proc~labelize_point labelize_point proc~test_labelize_point->proc~labelize_point selectcase selectcase proc~test_labelize_point->selectcase proc~labelize_point->proc~deriv_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test_labelize_point~~CalledByGraph proc~test_labelize_point test_labelize_point program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_labelize_point Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test_labelize_point () !================================================================================================ !! Function to test the function \"labelize_point\" on a QU9 domain with a 2nd order polynomial !!        along x and y implicit none real ( kind = R8 ) :: x , y , x0 , y0 real ( kind = R8 ) :: aax , aay character ( len = 1 ) :: point_kind , label real ( kind = R8 ), parameter :: xx0 = - 0.1_R8 , fxx0 = + 2._R8 real ( kind = R8 ), parameter :: yy0 = + 0.2_R8 , fyy0 = + 1._R8 real ( kind = R8 ), dimension ( 1 : 9 ) :: Ni , dNidx , dNidy , d2Nidx2 , d2Nidxdy , d2Nidy2 , tab real ( kind = R8 ), dimension ( 1 : 9 , 1 : 6 ) :: derivatives real ( kind = R8 ), dimension ( 1 : 3 , 1 : 3 ) :: height ! select what kind of point to check point_kind = 'S' selectcase ( point_kind ) case ( 'V' ) ; aax = + 1._R8 ; aay = + 1._R8 case ( 'P' ) ; aax = - 1._R8 ; aay = - 1._R8 case ( 'S' ) ; aax = + 1._R8 ; aay = - 1._R8 case default ; stop endselect ! \"tab\" is given row wise: !     Nodes order: ! !     4---7---3 !     |   |   | !     8---9-- 6 !     |   |   | !     1---5---2 ! tab ( 1 : 9 ) = [ f ( x = - 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = - 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 1 f ( x = + 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = - 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 5 f ( x = + 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = + 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 2 f ( x = - 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = + 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 8 f ( x = 0._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = - 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 9 f ( x = + 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = 0._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 6 f ( x = 0._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = + 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 4 f ( x = - 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = 0._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 7 f ( x = 0._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = 0._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ) ] ! 3 ! stack is done column wise for reshape height ( 1 : 3 , 1 : 3 ) = reshape ( [ tab ( 1 ), & ! tab ( 8 ), & ! tab ( 4 ), & ! tab ( 5 ), & ! tab ( 9 ), & ! tab ( 7 ), & ! tab ( 2 ), & ! tab ( 6 ), & ! tab ( 3 ) ], [ 3 , 3 ] ) ! random point to compare the analytic function to the quadratic approx x = - 0.35_R8 y = + 0.52_R8 call deriv_N ( x = x , y = y , mat_d = derivatives ( 1 : 9 , 1 : 6 )) Ni ( 1 : 9 ) = derivatives ( 1 : 9 , 1 ) dNidx ( 1 : 9 ) = derivatives ( 1 : 9 , 2 ) dNidy ( 1 : 9 ) = derivatives ( 1 : 9 , 3 ) d2Nidx2 ( 1 : 9 ) = derivatives ( 1 : 9 , 4 ) d2Nidxdy ( 1 : 9 ) = derivatives ( 1 : 9 , 5 ) d2Nidy2 ( 1 : 9 ) = derivatives ( 1 : 9 , 6 ) write ( * , * ) 'numerical h      : ' , sum ( tab * Ni ) , ' ; theoretical h      : ' , f ( x = x , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = y , x0 = yy0 , a = aay , fx0 = fyy0 ) write ( * , * ) 'numerical dhdx   : ' , sum ( tab * dNidx ) , ' ; theoretical dhdx   : ' , df ( x = x , x0 = xx0 , a = aax ) * f ( x = y , x0 = yy0 , a = aay , fx0 = fyy0 ) write ( * , * ) 'numerical dhdy   : ' , sum ( tab * dNidy ) , ' ; theoretical dhdy   : ' , f ( x = x , x0 = xx0 , a = aax , fx0 = fxx0 ) * df ( x = y , x0 = yy0 , a = aay ) write ( * , * ) 'numerical d2hdx2 : ' , sum ( tab * d2Nidx2 ) , ' ; theoretical d2hdx2 : ' , d2f ( a = aax ) * f ( x = y , x0 = yy0 , a = aay , fx0 = fyy0 ) write ( * , * ) 'numerical d2hdy2 : ' , sum ( tab * d2Nidy2 ) , ' ; theoretical d2hdy2 : ' , f ( x = x , x0 = xx0 , a = aax , fx0 = fxx0 ) * d2f ( a = aay ) write ( * , * ) 'numerical d2hdxdy: ' , sum ( tab * d2Nidxdy ) , ' ; theoretical d2hdxdy: ' , df ( x = x , x0 = xx0 , a = aax ) * df ( x = y , x0 = yy0 , a = aay ) !=========================================== call labelize_point ( height = height ( 1 : 3 , 1 : 3 ), label = label , x = x0 , y = y0 ) write ( * , * ) 'theoretical xx0: ' , xx0 , 'numerical xx0: ' , x0 write ( * , * ) 'theoretical yy0: ' , yy0 , 'numerical yy0: ' , y0 write ( * , * ) 'theoretical point: ' , point_kind , ' numerical point: ' , label contains real ( kind = R8 ) function f ( x , x0 , a , fx0 ) implicit none real ( kind = R8 ), intent ( in ) :: x real ( kind = R8 ), intent ( in ) :: x0 real ( kind = R8 ), intent ( in ) :: a real ( kind = R8 ), intent ( in ) :: fx0 real ( kind = R8 ) :: b , c ! 2nd order polynomial defined by: ! ->   a : +1 or -1 (curvature sign) ! ->  x0 : the extremum abscissa ! -> fx0 : the extremum value b = - 2 * a * x0 c = fx0 + a * x0 ** 2 f = a * x ** 2 + b * x + c return endfunction f real ( kind = R8 ) function df ( x , x0 , a ) implicit none real ( kind = R8 ), intent ( in ) :: x real ( kind = R8 ), intent ( in ) :: x0 real ( kind = R8 ), intent ( in ) :: a real ( kind = R8 ) :: b b = - 2 * a * x0 df = 2 * a * x + b return endfunction df real ( kind = R8 ) function d2f ( a ) implicit none real ( kind = R8 ), intent ( in ) :: a d2f = 2 * a return endfunction d2f endsubroutine test_labelize_point","tags":"","loc":"proc/test_labelize_point.html"},{"title":"test_peaks_and_pits_curvatures – TPGLIB","text":"public  subroutine test_peaks_and_pits_curvatures() Function to test the function “peaks_and_pits_curvatures” on a real rough surface.\n       Outputs surface gradients and curvatures as 2D arrays or single values. Arguments None Calls proc~~test_peaks_and_pits_curvatures~~CallsGraph proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures end_fftw3 end_fftw3 proc~test_peaks_and_pits_curvatures->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~test_peaks_and_pits_curvatures->fftw_plan_with_nthreads init_fftw3 init_fftw3 proc~test_peaks_and_pits_curvatures->init_fftw3 omp_get_max_threads omp_get_max_threads proc~test_peaks_and_pits_curvatures->omp_get_max_threads proc~curv2 curv2 proc~test_peaks_and_pits_curvatures->proc~curv2 proc~curvature curvature proc~test_peaks_and_pits_curvatures->proc~curvature proc~fft_filter fft_filter proc~test_peaks_and_pits_curvatures->proc~fft_filter proc~gauss_curv gauss_curv proc~test_peaks_and_pits_curvatures->proc~gauss_curv proc~gradient gradient proc~test_peaks_and_pits_curvatures->proc~gradient proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures read_surf read_surf proc~test_peaks_and_pits_curvatures->read_surf unit2IUf unit2IUf proc~test_peaks_and_pits_curvatures->unit2IUf write_surf write_surf proc~test_peaks_and_pits_curvatures->write_surf proc~curvature->proc~gauss_curv proc~curvature->proc~gradient calc_fftw3_real_bwd calc_fftw3_real_bwd proc~fft_filter->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~fft_filter->calc_fftw3_real_fwd extend extend proc~fft_filter->extend proc~gaussian_filter gaussian_filter proc~fft_filter->proc~gaussian_filter tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~fft_filter->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~fft_filter->tab_calc_fftw3_real_fwd proc~gauss_curv->proc~gradient proc~peaks_and_pits_curvatures->proc~curvature proc~label_surf_summits label_surf_summits proc~peaks_and_pits_curvatures->proc~label_surf_summits sort_array2 sort_array2 proc~peaks_and_pits_curvatures->sort_array2 proc~gradient_corner gradient_corner proc~label_surf_summits->proc~gradient_corner proc~labelize_point labelize_point proc~label_surf_summits->proc~labelize_point selectcase selectcase proc~label_surf_summits->selectcase proc~deriv_n deriv_N proc~labelize_point->proc~deriv_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test_peaks_and_pits_curvatures~~CalledByGraph proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test_peaks_and_pits_curvatures () !================================================================================================ !! Function to test the function \"peaks_and_pits_curvatures\" on a real rough surface. !!        Outputs surface gradients and curvatures as 2D arrays or single values. implicit none real ( kind = R8 ), allocatable , dimension (:,:) :: heights , bf_heights real ( kind = R8 ), allocatable , dimension (:,:) :: gradx , grady , gradxx , gradxy , gradyy , cvt real ( kind = R8 ) :: dx , dy , dz , pcurv , pgrad , pmin , pmax , fft_cutoff integer ( kind = I4 ) :: nx , ny , nx2 , ny2 , n_th type ( SCALE_SURF ) :: scal_surf call read_surf ( nom_fic = \"sur/test1.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres dx = scal_surf % dx * unit2IUf ( scal_surf % dx_unit ) dy = scal_surf % dy * unit2IUf ( scal_surf % dy_unit ) dz = 0 fft_cutoff = dx / 5.e-6 nx2 = 2 * ( nint ( PAD_FFT * nx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT * ny ) / 2 ) write ( * , * ) 'nx, ny = ' , nx , ny write ( * , * ) 'dx, dy = ' , dx , dy !================================================================= allocate ( bf_heights ( 1 : nx , 1 : ny ) ) allocate ( gradx ( 1 : nx , 1 : ny ) ) allocate ( grady ( 1 : nx , 1 : ny ) ) allocate ( gradxx ( 1 : nx , 1 : ny ) ) allocate ( gradxy ( 1 : nx , 1 : ny ) ) allocate ( gradyy ( 1 : nx , 1 : ny ) ) allocate ( cvt ( 1 : nx , 1 : ny ) ) n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! in long = nx , & ! in larg = ny , & ! in cutoff = fft_cutoff , & ! in bf_tab = bf_heights ( 1 : nx , 1 : ny ), & ! out multi_fft = . FALSE .) ! in call end_fftw3 () call write_surf ( nom_fic = \"out/test_bf_heights.sur\" , & ! in tab_s = bf_heights ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call gradient ( tab = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in gradx = gradx ( 1 : nx , 1 : ny ), & ! out grady = grady ( 1 : nx , 1 : ny )) ! out call write_surf ( nom_fic = \"out/test_gradq.sur\" , & ! in tab_s = gradx ( 1 : nx , 1 : ny ) ** 2 + & ! in grady ( 1 : nx , 1 : ny ) ** 2 , & ! scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradx.sur\" , & ! in tab_s = gradx ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_grady.sur\" , & ! in tab_s = grady ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in !================================================================= call gauss_curv ( gradx = gradx ( 1 : nx , 1 : ny ), & ! grady = grady ( 1 : nx , 1 : ny ), & ! gradxx = gradxx ( 1 : nx , 1 : ny ), & ! gradxy = gradxy ( 1 : nx , 1 : ny ), & ! gradyy = gradyy ( 1 : nx , 1 : ny ), & ! nx = nx , & ! ny = ny , & ! dx = dx , & ! dy = dy ) ! call write_surf ( nom_fic = \"out/test_gradxx_1.sur\" , & ! in tab_s = gradxx ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradxy_1.sur\" , & ! in tab_s = gradxy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradyy_1.sur\" , & ! in tab_s = gradyy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call curv2 ( tab = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in gradxx = gradxx ( 1 : nx , 1 : ny ), & ! out gradyy = gradyy ( 1 : nx , 1 : ny )) ! out call write_surf ( nom_fic = \"out/test_gradxx_2.sur\" , & ! in tab_s = gradxx ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradxy_2.sur\" , & ! in tab_s = gradxy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradyy_2.sur\" , & ! in tab_s = gradyy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call curvature ( tab = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in S_param_grad = pgrad , & ! out S_param_curv = pcurv , & ! out gcurvt = cvt ( 1 : nx , 1 : ny )) ! out write ( * , * ) \"S_param_grad: \" , pgrad call write_surf ( nom_fic = \"out/test_cvt.sur\" , & ! in tab_s = cvt ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in !================================================================= call peaks_and_pits_curvatures ( heights = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in S_param_grad = pgrad , & ! out S_param_curv = pcurv , & ! out peak_curv = pmax , & ! out pits_curv = pmin ) ! out write ( * , * ) \"S_param_curv: \" , pcurv write ( * , * ) \"peak_curv: \" , pmin write ( * , * ) \"pits_curv: \" , pmax !================================================================= deallocate ( heights , bf_heights , gradx , grady , gradxy , gradxx , gradyy , cvt ) return endsubroutine test_peaks_and_pits_curvatures","tags":"","loc":"proc/test_peaks_and_pits_curvatures.html"},{"title":"fft_filter – TPGLIB","text":"public  subroutine fft_filter(tab, long, larg, cutoff, bf_tab, multi_fft, pad, ext, type_apo) Uses surfile proc~~fft_filter~~UsesGraph proc~fft_filter fft_filter surfile surfile proc~fft_filter->surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Classical Gaussian filter Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab 2D array in integer(kind=I4), intent(in) :: long 2D array width integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(in) :: cutoff cut-off wavelength real(kind=R8), intent(out), dimension(1:long, 1:larg) :: bf_tab 2D array out logical(kind=I4), intent(in) :: multi_fft multiple fft at once ? real(kind=R8), intent(in), optional :: pad fft padding character(len=*), intent(in), optional :: ext extension character(len=*), intent(in), optional :: type_apo apodization type Calls proc~~fft_filter~~CallsGraph proc~fft_filter fft_filter calc_fftw3_real_bwd calc_fftw3_real_bwd proc~fft_filter->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~fft_filter->calc_fftw3_real_fwd extend extend proc~fft_filter->extend proc~gaussian_filter gaussian_filter proc~fft_filter->proc~gaussian_filter tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~fft_filter->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~fft_filter->tab_calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fft_filter~~CalledByGraph proc~fft_filter fft_filter proc~multiple_anisotropy multiple_anisotropy proc~multiple_anisotropy->proc~fft_filter proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~fft_filter program~test_smooth test_smooth program~test_smooth->proc~fft_filter program~test_anisotropy test_anisotropy program~test_anisotropy->proc~multiple_anisotropy program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fft_filter ( tab , long , larg , cutoff , bf_tab , multi_fft , pad , ext , type_apo ) !================================================================================================ !! Classical Gaussian filter !------------------------------------------------------------------------------------------------ use surfile , only : init_scal , write_surf , SCALE_SURF implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array width* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ) :: cutoff !! *cut-off wavelength* logical ( kind = I4 ), intent ( in ) :: multi_fft !! *multiple fft at once ?* real ( kind = R8 ), intent ( in ), optional :: pad !! *fft padding* character ( len =* ), intent ( in ), optional :: ext !! *extension* character ( len =* ), intent ( in ), optional :: type_apo !! *apodization type* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: bf_tab !! *2D array out* integer ( kind = I4 ) :: nx2 , ny2 , iex , iey , ibx , iby real ( kind = R8 ) :: o_pad logical ( kind = I4 ) :: with_pad character ( len = :), allocatable :: o_ext character ( len = :), allocatable :: o_type_apo complex ( kind = R8 ), dimension (:,:), allocatable :: cmple real ( kind = R8 ), dimension (:,:), allocatable :: tab_ext , gauss_tab , tab_tmp with_pad = . true . if ( . not . present ( ext ) ) then o_ext = 'symmetry' else o_ext = ext endif if ( . not . present ( type_apo ) ) then o_type_apo = 'no_apo' else o_type_apo = type_apo endif if ( . not . present ( pad ) ) then o_pad = PAD_FFT_FILTER else if ( pad < 0. ) then o_pad = 1 nx2 = long ny2 = larg with_pad = . false . else o_pad = pad endif endif if ( with_pad ) then nx2 = 2 * ( nint ( o_pad * long ) / 2 ) ny2 = 2 * ( nint ( o_pad * larg ) / 2 ) endif allocate ( tab_ext ( 1 : nx2 , 1 : ny2 ) ) ! allocate ( tab_tmp ( 1 : nx2 , 1 : ny2 ) ) ! allocate ( cmple ( 1 : nx2 , 1 : ny2 ) ) ! if ( nx2 > long ) then ibx = ceiling ( ( nx2 - long ) / 2. ) ; iex = ibx + long - 1 iby = ceiling ( ( ny2 - larg ) / 2. ) ; iey = iby + larg - 1 call extend ( tab_in = tab ( 1 : long , 1 : larg ), & ! tab_out = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! nx = long , & ! ny = larg , & ! nx2 = nx2 , & ! ny2 = ny2 , & ! ext = o_ext , & ! type_apo = o_type_apo ) ! else tab_ext ( 1 : nx2 , 1 : ny2 ) = tab ( 1 : long , 1 : larg ) endif if ( multi_fft ) then call tab_calc_fftw3_real_fwd ( tab_in = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = cmple ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! else call calc_fftw3_real_fwd ( tab_in = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = cmple ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! endif allocate ( gauss_tab ( 1 : nx2 , 1 : ny2 ) ) call gaussian_filter ( long = nx2 , & ! larg = ny2 , & ! xc = cutoff , & ! gauss_filt = gauss_tab ( 1 : nx2 , 1 : ny2 ) ) ! cmple ( 1 : nx2 , 1 : ny2 ) = cmple ( 1 : nx2 , 1 : ny2 ) * gauss_tab ( 1 : nx2 , 1 : ny2 ) deallocate ( gauss_tab ) if ( multi_fft ) then call tab_calc_fftw3_real_bwd ( tab_in = cmple ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! else call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! endif if ( nx2 > long ) then bf_tab ( 1 : long , 1 : larg ) = tab_ext ( ibx : iex , iby : iey ) else bf_tab ( 1 : long , 1 : larg ) = tab_ext ( 1 : nx2 , 1 : ny2 ) endif deallocate ( cmple ) deallocate ( tab_ext , tab_tmp ) return endsubroutine fft_filter","tags":"","loc":"proc/fft_filter.html"},{"title":"gaussian_filter – TPGLIB","text":"private  subroutine gaussian_filter(long, larg, xc, gauss_filt) Gaussian kernel Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in) :: xc the cut-off wavelength real(kind=R8), intent(out), dimension(1:long, 1:larg) :: gauss_filt 2D array out Called by proc~~gaussian_filter~~CalledByGraph proc~gaussian_filter gaussian_filter proc~fft_filter fft_filter proc~fft_filter->proc~gaussian_filter proc~multiple_anisotropy multiple_anisotropy proc~multiple_anisotropy->proc~fft_filter proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~fft_filter program~test_smooth test_smooth program~test_smooth->proc~fft_filter program~test_anisotropy test_anisotropy program~test_anisotropy->proc~multiple_anisotropy program~test_grad_curv test_grad_curv program~test_grad_curv->proc~test_peaks_and_pits_curvatures Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gaussian_filter ( long , larg , xc , gauss_filt ) !================================================================================================ !! Gaussian kernel !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ) :: xc !! *the cut-off wavelength* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: gauss_filt !! *2D array out* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: tmp , xi , xj real ( kind = R8 ), parameter :: const = sqrt ( log ( 2._R8 ) / PI_R8 ) do j = 2 , larg / 2 + 1 do i = 2 , long / 2 + 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) tmp = gaussian_function ( xi , xj , xc ) gauss_filt ( + i , + j ) = tmp gauss_filt ( long + 2 - i , + j ) = tmp gauss_filt ( + i , larg + 2 - j ) = tmp gauss_filt ( long + 2 - i , larg + 2 - j ) = tmp enddo enddo do j = 2 , larg / 2 + 1 i = 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) tmp = gaussian_function ( xi , xj , xc ) gauss_filt ( i , j ) = tmp gauss_filt ( i , larg + 2 - j ) = tmp enddo do i = 2 , long / 2 + 1 j = 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) tmp = gaussian_function ( xi , xj , xc ) gauss_filt ( i , j ) = tmp gauss_filt ( long + 2 - i , j ) = tmp enddo i = 1 j = 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) gauss_filt ( i , j ) = gaussian_function ( xi , xj , xc ) contains !----------------------------------------- real ( kind = R8 ) function gaussian_function ( xi , xj , xc ) implicit none real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ) :: xj real ( kind = R8 ), intent ( in ) :: xc ! fréquence de coupure, plus exactement proportion : (freq coup) / (nb points) gaussian_function = exp ( - PI_R8 * const ** 2 * ( xi ** 2 + xj ** 2 ) / ( xc ** 2 ) ) ! sqrt(ln(2)/pi)=0.47 return endfunction gaussian_function !----------------------------------------- endsubroutine gaussian_filter","tags":"","loc":"proc/gaussian_filter.html"},{"title":"median_filter – TPGLIB","text":"public  subroutine median_filter(tab, long, larg, snb, kernel, sig, omp) A bit more complex filter: the overall height standard deviation is taken into account Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:long, 1:larg) :: tab 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width integer(kind=I4), intent(in) :: snb patch number along a direction integer(kind=I4), intent(in) :: kernel kernel size real(kind=R8), intent(in) :: sig error std logical(kind=I4), intent(in) :: omp if multithreading Calls proc~~median_filter~~CallsGraph proc~median_filter median_filter proc~calc_median calc_median proc~median_filter->proc~calc_median proc~calc_moments calc_moments proc~median_filter->proc~calc_moments proc~median_smooth median_smooth proc~median_filter->proc~median_smooth sort_array2 sort_array2 proc~calc_median->sort_array2 proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d proc~median_smooth->proc~calc_median omp_get_num_procs omp_get_num_procs proc~median_smooth->omp_get_num_procs proc~median_smooth->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~median_filter~~CalledByGraph proc~median_filter median_filter program~test_smooth test_smooth program~test_smooth->proc~median_filter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine median_filter ( tab , long , larg , snb , kernel , sig , omp ) !================================================================================================ !! A bit more complex filter: the overall height standard deviation is taken into account !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: snb !! *patch number along a direction* integer ( kind = I4 ), intent ( in ) :: kernel !! *kernel size* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( in ) :: sig !! *error std* real ( kind = R8 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: md integer ( kind = I4 ), dimension ( 1 : snb + 1 ) :: li , lj real ( kind = R8 ), dimension ( 1 : snb * snb ) :: ect real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp1 , tab_tmp2 type ( moment_stat ) :: mx_smooth allocate ( tab_tmp1 ( 1 : long , 1 : larg ) ) allocate ( tab_tmp2 ( 1 : long , 1 : larg ) ) ! first determine the difference between the input surface and a median filtered one tab_tmp1 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) call median_smooth ( tab = tab_tmp1 ( 1 : long , 1 : larg ), & ! kernel = kernel , & ! long = long , & ! larg = larg , & ! omp = omp ) ! tab_tmp2 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) - tab_tmp1 ( 1 : long , 1 : larg ) ! bounds when patching domain li ( 1 ) = 1 ; li ( snb + 1 ) = long lj ( 1 ) = 1 ; lj ( snb + 1 ) = larg do i = 2 , snb li ( i ) = li ( i - 1 ) + int ( real ( long , kind = R8 ) / snb , kind = I4 ) lj ( i ) = lj ( i - 1 ) + int ( real ( larg , kind = R8 ) / snb , kind = I4 ) enddo k = 0 do j = 1 , snb do i = 1 , snb call calc_moments ( tab = reshape ( tab_tmp2 ( li ( i ): li ( i + 1 ) - 1 , lj ( j ): lj ( j + 1 ) - 1 ), & ! [( li ( i ) - li ( i + 1 ) ) * ( lj ( j ) - lj ( j + 1 ) )] ), & ! mx = mx_smooth , & ! nb_mom = 2 ) ! k = k + 1 ect ( k ) = mx_smooth % si enddo enddo call calc_median ( tab = ect ( 1 : snb * snb ), & ! md = md ) ! call calc_moments ( tab = reshape ( tab_tmp2 ( 1 : long , 1 : larg ), & ! [ long * larg ] ), & ! mx = mx_smooth , & ! nb_mom = 2 ) ! where ( abs ( tab_tmp2 ( 1 : long , 1 : larg ) - mx_smooth % mu ) > sig * md ) tab ( 1 : long , 1 : larg ) = tab_tmp1 ( 1 : long , 1 : larg ) deallocate ( tab_tmp1 , tab_tmp2 ) return endsubroutine median_filter","tags":"","loc":"proc/median_filter.html"},{"title":"median_smooth – TPGLIB","text":"public  subroutine median_smooth(tab, long, larg, kernel, omp) Very classical smoothing Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:long, 1:larg) :: tab 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width integer(kind=I4), intent(in) :: kernel kernel size logical(kind=I4), intent(in) :: omp if multithreading Calls proc~~median_smooth~~CallsGraph proc~median_smooth median_smooth omp_get_num_procs omp_get_num_procs proc~median_smooth->omp_get_num_procs proc~calc_median calc_median proc~median_smooth->proc~calc_median sort_array2 sort_array2 proc~median_smooth->sort_array2 proc~calc_median->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~median_smooth~~CalledByGraph proc~median_smooth median_smooth proc~median_filter median_filter proc~median_filter->proc~median_smooth program~test_smooth test_smooth program~test_smooth->proc~median_smooth program~test_smooth->proc~median_filter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine median_smooth ( tab , long , larg , kernel , omp ) !================================================================================================ !! Very classical smoothing !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: kernel !! *kernel size* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array* integer ( kind = I4 ) :: i , j , k , ii , jj , nt , nk , nb_th real ( kind = R8 ) :: md real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp , t real ( kind = R8 ), allocatable , dimension (:) :: vt allocate ( tab_tmp ( 1 : long , 1 : larg ) ) ; tab_tmp = HIG_R8 k = kernel nt = ( 2 * k + 1 ) * ( 2 * k + 1 ) allocate ( t ( - k : k , - k : k ), vt ( 1 :( 2 * k + 1 ) * ( 2 * k + 1 )) ) nb_th = 1 if ( omp ) then nb_th = omp_get_num_procs () endif !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO SCHEDULE (STATIC,larg/nb_th) PRIVATE(i, t, nk, ii, jj, vt, md) do j = 1 , larg do i = 1 , long t ( - k : k , - k : k ) = - HIG_R8 / 10 nk = 0 do jj = - k , + k if ( j + jj < 1 . or . j + jj > larg ) cycle do ii = - k , + k if ( i + ii < 1 . or . i + ii > long ) cycle nk = nk + 1 t ( ii , jj ) = tab ( i + ii , j + jj ) enddo enddo vt ( 1 : nt ) = reshape ( t ( - k : k , - k : k ), [ nt ]) call sort_array2 ( tab_inout = vt ( 1 : nt ), n = nt ) call calc_median ( tab = vt ( nt - nk + 1 : nt ), md = md ) tab_tmp ( i , j ) = md enddo enddo !$OMP END DO !$OMP END PARALLEL tab ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp , t , vt ) return endsubroutine median_smooth","tags":"","loc":"proc/median_smooth.html"},{"title":"morpho_filter – TPGLIB","text":"public  subroutine morpho_filter(tabin, tabou, long, larg, scale_xyz, ray, omp, nb_div, mtype) Note Morphological filter: uses combinations of roll_smooth to provide all kind of transformation : closing opening dilation erosion Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin 2D array in real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tabou 2D array out integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz lag along x, y and scale z real(kind=R8), intent(in) :: ray roll radius logical(kind=I4), intent(in) :: omp if multithreading integer(kind=I4), intent(in) :: nb_div number of macro elements along an axis character(len=*), intent(in) :: mtype closing, opening, dilation or erosion Calls proc~~morpho_filter~~CallsGraph proc~morpho_filter morpho_filter proc~roll_smooth roll_smooth proc~morpho_filter->proc~roll_smooth omp_get_num_procs omp_get_num_procs proc~roll_smooth->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~morpho_filter~~CalledByGraph proc~morpho_filter morpho_filter program~test_smooth test_smooth program~test_smooth->proc~morpho_filter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine morpho_filter ( tabin , tabou , long , larg , scale_xyz , ray , omp , nb_div , mtype ) !================================================================================================ !< @note !< !< Morphological filter: uses combinations of [[roll_smooth]] to provide all kind of transformation : !< !< + closing !< + opening !< + dilation !< + erosion !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: nb_div !! *number of macro elements along an axis* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( in ) :: ray !! *roll radius* character ( len =* ), intent ( in ) :: mtype !! *closing, opening, dilation or erosion* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *lag along x, y and scale z* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tabou !! *2D array out* real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp logical ( kind = I4 ) :: op1 , op2 integer ( kind = I4 ) :: k select case ( mtype ( 1 : 7 ) ) case ( \"closing\" ) op1 = . true . ; op2 = . true . ; k = + 1 case ( \"opening\" ) op1 = . true . ; op2 = . true . ; k = - 1 case ( \"dilatio\" ) op1 = . true . ; op2 = . false . ; k = + 1 case ( \"erosion\" ) op1 = . true . ; op2 = . false . ; k = - 1 case default stop \"bad choice, morpho_filter\" endselect if ( op1 ) then call roll_smooth ( tabin = tabin ( 1 : long , 1 : larg ), & ! IN tabou = tabou ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN scale_xyz = scale_xyz , & ! IN sgn = + k , & ! IN ray = ray , & ! IN omp = omp , & ! IN nb_div = nb_div ) ! IN endif if ( op2 ) then allocate ( tab_tmp ( 1 : long , 1 : larg ) ) call roll_smooth ( tabin = tabou ( 1 : long , 1 : larg ), & ! IN tabou = tab_tmp ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN scale_xyz = scale_xyz , & ! IN sgn = - k , & ! IN ray = ray , & ! IN omp = omp , & ! IN nb_div = nb_div ) ! IN tabou ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp ) endif return endsubroutine morpho_filter","tags":"","loc":"proc/morpho_filter.html"},{"title":"roll_smooth – TPGLIB","text":"private  subroutine roll_smooth(tabin, tabou, long, larg, scale_xyz, sgn, ray, omp, nb_div) Note A ball of radius “ray” rolls on / below the surface, hence defining a closing or an opening enveloppe. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin 2D array in real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tabou 2D array out integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz lag along x, y and scale z integer(kind=I4), intent(in) :: sgn + 1: dilation, -1:erosion real(kind=R8), intent(in) :: ray roll radius logical(kind=I4), intent(in) :: omp if multithreading integer(kind=I4), intent(in) :: nb_div number of macro elements along an axis Calls proc~~roll_smooth~~CallsGraph proc~roll_smooth roll_smooth omp_get_num_procs omp_get_num_procs proc~roll_smooth->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~roll_smooth~~CalledByGraph proc~roll_smooth roll_smooth proc~morpho_filter morpho_filter proc~morpho_filter->proc~roll_smooth program~test_smooth test_smooth program~test_smooth->proc~morpho_filter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine roll_smooth ( tabin , tabou , long , larg , scale_xyz , sgn , ray , omp , nb_div ) !================================================================================================ !< @note !< !< A ball of radius \"ray\" rolls on / below the surface, hence defining a closing or an opening enveloppe. !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: sgn !! *+ 1: dilation, -1:erosion* integer ( kind = I4 ), intent ( in ) :: nb_div !! *number of macro elements along an axis* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( in ) :: ray !! *roll radius* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *lag along x, y and scale z* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tabou !! *2D array out* integer ( kind = I4 ) :: i , j , ii , jj , nb_th integer ( kind = I4 ) :: hw integer ( kind = I4 ) :: ik , jk , idiv , jdiv , ista , iend , jsta , jend real ( kind = R8 ) :: h1 , h2 , ht , tmp , delta_h_max real ( kind = R8 ) :: ech_x , ech_y real ( kind = R8 ), allocatable , dimension (:,:) :: elem , tab_tmp integer ( kind = I4 ), allocatable , dimension (:,:) :: thw ech_x = scale_xyz ( 1 ) !SCALE_IMG%dx * unit2IUf(SCALE_IMG%dx_unit) ech_y = scale_xyz ( 2 ) !SCALE_IMG%dy * unit2IUf(SCALE_IMG%dy_unit) h1 = minval ( tabin ( 1 : long , 1 : larg ) ) h2 = maxval ( tabin ( 1 : long , 1 : larg ) ) delta_h_max = h2 - h1 ht = min ( - abs ( h1 ), - abs ( h2 ) ) h2 = max ( + abs ( h1 ), + abs ( h2 ) ) h1 = ht ! the normal width of the ball is : hw = int( ray / ech_x ) ! However the ball curvature makes the ball height sometimes higher than the surfaces heights hw = int ( sqrt ( 2 * delta_h_max * ray - delta_h_max ** 2 ) / ech_x ) !+ 1 allocate ( elem ( - hw : hw , - hw : hw ) ) allocate ( tab_tmp ( - hw + 1 : hw + long , - hw + 1 : hw + larg ) ) ! surface is extended tab_tmp ( 1 : long , 1 : larg ) = tabin ( 1 : long , 1 : larg ) ! original surface do i = 1 , long tab_tmp ( i , - hw + 1 : 0 ) = tab_tmp ( i , 1 ) tab_tmp ( i , larg + 1 : larg + hw ) = tab_tmp ( i , larg ) enddo do j = - hw + 1 , larg + hw tab_tmp ( - hw + 1 : 0 , j ) = tab_tmp ( 1 , j ) tab_tmp ( long + 1 : long + hw , j ) = tab_tmp ( long , j ) enddo nb_th = 1 if ( omp ) then nb_th = omp_get_num_procs () endif allocate ( thw ( 1 : nb_div , 1 : nb_div ) ) ! number of macro squares on which the ball active width is determined idiv = long / nb_div jdiv = larg / nb_div !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO  SCHEDULE (STATIC, max(nb_div/nb_th, 1)) PRIVATE(jk, ik, delta_h_max, ista, iend, jsta, jend) do jk = 1 , nb_div if ( jk == nb_div ) then ; jend = larg ; else ; jend = jk * jdiv ; endif ; jsta = 1 + jdiv * ( jk - 1 ) do ik = 1 , nb_div if ( ik == nb_div ) then ; iend = long ; else ; iend = ik * idiv ; endif ; ista = 1 + idiv * ( ik - 1 ) delta_h_max = maxval ( tab_tmp ( - hw + ista : hw + iend , - hw + jsta : hw + jend ) ) - & ! minval ( tab_tmp ( - hw + ista : hw + iend , - hw + jsta : hw + jend ) ) ! beyond the present width, the ball height is greater than the surface height thw ( ik , jk ) = int ( sqrt ( 2 * delta_h_max * ray - delta_h_max ** 2 ) / ech_x ) enddo enddo !$OMP END DO !$OMP END PARALLEL if ( sgn == + 1 ) then do jj = - hw , hw do ii = - hw , hw tmp = ray ** 2 - ( ii * ech_x ) ** 2 - ( jj * ech_y ) ** 2 if ( tmp < 0. ) then elem ( ii , jj ) = ray + 1.1 * abs ( h2 ) else ! the ball location is a little above the surface elem ( ii , jj ) = ray - sqrt ( tmp ) endif enddo enddo else do jj = - hw , hw do ii = - hw , hw tmp = ray ** 2 - ( ii * ech_x ) ** 2 - ( jj * ech_y ) ** 2 if ( tmp < 0. ) then elem ( ii , jj ) = - ray - 1.1 * abs ( h1 ) else ! the ball location is a little below the surface elem ( ii , jj ) = - ray + sqrt ( tmp ) endif enddo enddo endif !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO SCHEDULE (STATIC,larg/nb_th) PRIVATE(i, j, jk, ik, hw) do j = 1 , larg ; jk = 1 + j / ( jdiv + 1 ) do i = 1 , long ; ik = 1 + i / ( idiv + 1 ) hw = thw ( ik , jk ) tabou ( i , j ) = - minval ( sgn * ( elem ( - hw : hw , - hw : hw ) - & ! tab_tmp ( - hw + i : hw + i , - hw + j : hw + j ) ) ) enddo enddo !$OMP END DO !$OMP END PARALLEL if ( sgn == + 1 ) then tabou ( 1 : long , 1 : larg ) = + tabou ( 1 : long , 1 : larg ) + ray else tabou ( 1 : long , 1 : larg ) = - tabou ( 1 : long , 1 : larg ) - ray endif deallocate ( elem , tab_tmp , thw ) return endsubroutine roll_smooth","tags":"","loc":"proc/roll_smooth.html"},{"title":"soften – TPGLIB","text":"public  subroutine soften(tabin, mask, tabout, long, larg) Note Function to smooth out a 2D array: each point is replaced by a weighted mean of its neighbors. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin 2D array in integer(kind=I4), intent(in), optional, dimension(1:long, 1:larg) :: mask mask real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tabout 2D array out integer(kind=I4), intent(in) :: long 2D array width integer(kind=I4), intent(in) :: larg 2D array height Called by proc~~soften~~CalledByGraph proc~soften soften program~test_smooth test_smooth program~test_smooth->proc~soften Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine soften ( tabin , mask , tabout , long , larg ) !================================================================================================ !< @note Function to smooth out a 2D array: each point is replaced by a weighted mean of its neighbors. !< !<  !<   h_{i,j} = \\frac{1}{16} \\left( 4 h_{i, j} + 2 h_{i + 1, j    } + 2 h_{i - 1, j    } + 2 h_{i    , j + 1} + 2 h_{i    , j - 1} !<                                              + h_{i + 1, j - 1} +   h_{i - 1, j + 1} +   h_{i - 1, j + 1} +   h_{i + 1, j - 1} \\right) !<  !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array width* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tabout !! *2D array out* integer ( kind = I4 ), intent ( in ), dimension ( 1 : long , 1 : larg ), optional :: mask !! *mask* integer ( kind = I4 ) :: i , j tabout ( 1 : long , 1 : larg ) = tabin ( 1 : long , 1 : larg ) if ( present ( mask ) ) then do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 if ( sum ( mask ( i - 1 : i + 1 , j - 1 : j + 1 )) < 9 ) then cycle else tabout ( i , j ) = ( 2 * tabin ( i , j ) + tabin ( i + 1 , j ) + tabin ( i - 1 , j ) + & ! tabin ( i , j + 1 ) + tabin ( i , j - 1 ) + ( tabin ( i + 1 , j - 1 ) + tabin ( i - 1 , j - 1 ) + & ! tabin ( i - 1 , j + 1 ) + tabin ( i + 1 , j + 1 ) ) / 2._R8 ) / 8 endif enddo enddo else do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 tabout ( i , j ) = ( 2 * tabin ( i , j ) + tabin ( i + 1 , j ) + tabin ( i - 1 , j ) + & ! tabin ( i , j + 1 ) + tabin ( i , j - 1 ) + ( tabin ( i + 1 , j - 1 ) + tabin ( i - 1 , j - 1 ) + & ! tabin ( i - 1 , j + 1 ) + tabin ( i + 1 , j + 1 ) ) / 2._R8 ) / 8 enddo enddo endif return endsubroutine soften","tags":"","loc":"proc/soften.html"},{"title":"calcul_normales – TPGLIB","text":"public  subroutine calcul_normales(tab_in, long, larg, scale_xyz, cone_angle, hori, print_mask) Function that returns the fraction of surface nearly horizontal (normal less than 5 degrees\n       from a vertical line) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long,1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long surface array length integer(kind=I4), intent(in) :: larg surface array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz lag along x, y and scale z real(kind=R8), intent(in) :: cone_angle cone angle real(kind=R8), intent(out) :: hori fraction of facets nearly horizontal logical(kind=I4), intent(in), optional :: print_mask mask output ? Calls proc~~calcul_normales~~CallsGraph proc~calcul_normales calcul_normales get_unit get_unit proc~calcul_normales->get_unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calcul_normales~~CalledByGraph proc~calcul_normales calcul_normales program~test_morpho test_morpho program~test_morpho->proc~calcul_normales Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcul_normales ( tab_in , long , larg , scale_xyz , cone_angle , hori , print_mask ) !================================================================================================ !! Function that returns the fraction of surface nearly horizontal (normal less than 5 degrees !!        from a vertical line) !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface array length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface array width* real ( kind = R8 ), intent ( in ) :: cone_angle !! *cone angle* real ( kind = R8 ), intent ( out ) :: hori !! *fraction of facets nearly horizontal* logical ( kind = I4 ), intent ( in ), optional :: print_mask !! *mask output ?* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *lag along x, y and scale z* integer ( kind = I4 ) :: i , j , ino , nb_no , ua real ( kind = R8 ) :: z1 , z2 , z3 , z4 real ( kind = R8 ) :: n1x , n1y , n1z , n2x , n2y , n2z , nx , ny , nz , norme real ( kind = R8 ) :: phi , angle_moy , ech_x , ech_y , ech_z , ech_r , d13 , d24 , d42 character ( len = 16 ) :: str real ( kind = R8 ), allocatable , dimension (:) :: angle real ( kind = R8 ), allocatable , dimension (:,:,:) :: vec nb_no = long * larg !  nombre de noeuds auquels on associera une normale allocate ( angle ( 1 : nb_no ) ) ! recevra les angles à la verticale pour chaque noeud allocate ( vec ( 1 : long , 1 : larg , 1 : 3 ) ) ! recevra pour chaque noeud la contribution des facettes triangulaires connectées ech_x = scale_xyz ( 1 ) !SCALE_IMG%dx * unit2IUf(SCALE_IMG%dx_unit) ech_y = scale_xyz ( 2 ) !SCALE_IMG%dy * unit2IUf(SCALE_IMG%dy_unit) ech_z = scale_xyz ( 3 ) ech_r = ech_x / ech_y d13 = ( 2. / 3. ) * sqrt ( ech_x ** 2 + ech_y ** 2 ) / 2 d42 = ( 2. / 3. ) * sqrt ( ( ech_x / 2 ) ** 2 + ech_y ** 2 ) d24 = ( 2. / 3. ) * sqrt ( ech_x ** 2 + ( ech_y / 2 ) ** 2 ) ! Raisonnement sur chaque carré du domaine vec ( 1 : long , 1 : larg , 1 : 3 ) = 0 do j = 1 , larg - 1 do i = 1 , long - 1 z1 = tab_in ( i , j ) * ech_z z4 = tab_in ( i , j + 1 ) * ech_z z2 = tab_in ( i + 1 , j ) * ech_z z3 = tab_in ( i + 1 , j + 1 ) * ech_z ! Triangle 1 n1x = ( z1 - z2 ) / ech_x n1y = ( z1 - z4 ) / ech_y n1z = 1 norme = sqrt ( n1x ** 2 + n1y ** 2 + n1z ** 2 ) n1x = n1x / norme n1y = n1y / norme n1z = n1z / norme ! Triangle 2 n2x = ( z4 - z3 ) / ech_x n2y = ( z2 - z3 ) / ech_y n2z = 1 norme = sqrt ( n2x ** 2 + n2y ** 2 + n2z ** 2 ) n2x = n2x / norme n2y = n2y / norme n2z = n2z / norme ! triangle 1 vec ( i + 0 , j + 0 , 1 : 3 ) = vec ( i + 0 , j + 0 , 1 : 3 ) + [ n1x , n1y , n1z ] / d13 ! node 1 vec ( i + 0 , j + 1 , 1 : 3 ) = vec ( i + 0 , j + 1 , 1 : 3 ) + [ n1x , n1y , n1z ] / d24 ! node 2 vec ( i + 1 , j + 0 , 1 : 3 ) = vec ( i + 1 , j + 0 , 1 : 3 ) + [ n1x , n1y , n1z ] / d42 ! node 4 ! triangle 2 vec ( i + 1 , j + 1 , 1 : 3 ) = vec ( i + 1 , j + 1 , 1 : 3 ) + [ n2x , n2y , n2z ] / d13 ! node 3 vec ( i + 0 , j + 1 , 1 : 3 ) = vec ( i + 0 , j + 1 , 1 : 3 ) + [ n2x , n2y , n2z ] / d42 ! node 2 vec ( i + 1 , j + 0 , 1 : 3 ) = vec ( i + 1 , j + 0 , 1 : 3 ) + [ n2x , n2y , n2z ] / d24 ! node 4 enddo enddo ino = 0 do j = 1 , larg do i = 1 , long nx = vec ( i , j , 1 ) ny = vec ( i , j , 2 ) nz = vec ( i , j , 3 ) norme = sqrt ( nx ** 2 + ny ** 2 + nz ** 2 ) nx = nx / norme ny = ny / norme nz = nz / norme phi = acos ( nz ) * 18 0. / PI_R8 ino = ino + 1 angle ( ino ) = phi enddo enddo ! angle moyen de la surface angle_moy = 0 !sum( angle(1:nb_no) )/nb_no ! tout ce qui dépasse l'angle moyen (à cone_angle° près) est masqué à 0 where ( abs ( angle - angle_moy ) < cone_angle ) angle = 1. elsewhere angle = 0. endwhere ! pourcentage de facettes quasi horizontales hori = 100 * sum ( angle ( 1 : nb_no ) ) / nb_no if ( present ( print_mask ) ) then str = repeat ( ' ' , len ( str ) ) write ( str , '(I12.12)' ) ino call get_unit ( ua ) open ( unit = ua , file = \"out/mask_angle.txt\" ) write ( ua , '(' // trim ( str ) // 'I2.1)' ) ( int ( angle ( i ) ), i = 1 , long * larg ) close ( ua ) endif deallocate ( angle , vec ) return endsubroutine calcul_normales","tags":"","loc":"proc/calcul_normales.html"},{"title":"count_cell – TPGLIB","text":"public  subroutine count_cell(msk, long, larg, nbr_cell, med_cell) Calculate the number of cells in a mask, as well as the cell median size Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(inout), dimension(1:long, 1:larg) :: msk mask integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height integer(kind=I4), intent(out) :: nbr_cell number of cells real(kind=R8), intent(out), optional :: med_cell median size of the cells Calls proc~~count_cell~~CallsGraph proc~count_cell count_cell proc~calc_median calc_median proc~count_cell->proc~calc_median proc~flood flood proc~count_cell->proc~flood sort_array2 sort_array2 proc~calc_median->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_cell~~CalledByGraph proc~count_cell count_cell proc~topology topology proc~topology->proc~count_cell program~test_morpho test_morpho program~test_morpho->proc~count_cell Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine count_cell ( msk , long , larg , nbr_cell , med_cell ) !================================================================================================ !! Calculate the number of cells in a mask, as well as the cell median size !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* integer ( kind = I4 ), intent ( out ) :: nbr_cell !! *number of cells* real ( kind = R8 ), intent ( out ), optional :: med_cell !! *median size of the cells* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: msk !! *mask* integer ( kind = I4 ) :: i , j , k , nb real ( kind = R8 ), dimension ( 1 : long * larg ) :: cell cell ( 1 : long * larg ) = 0 k = 1 do call flood ( masque = msk ( 1 : long , 1 : larg ), & ! INOUT taille = nb , & ! OUT nx = long , & ! IN ny = larg , & ! IN niv = k + 1 ) ! IN if ( nb == 0 ) exit cell ( k ) = nb k = k + 1 enddo nbr_cell = k - 1 med_cell = 0._R8 if (. not . present ( med_cell )) return if ( k > 0 ) then call calc_median ( tab = cell ( 1 : nbr_cell ), & ! IN md = med_cell ) ! OUT med_cell = 100 * med_cell / ( long * larg ) else med_cell = 0 endif return endsubroutine count_cell","tags":"","loc":"proc/count_cell.html"},{"title":"def_masque – TPGLIB","text":"public  subroutine def_masque(msk, tab, long, larg, crit1, crit2, top) Height mask without deepest pits and highest peaks Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(1:long, 1:larg) :: msk mask real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab heights 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(in) :: crit1 %age for deepest pits to remove real(kind=R8), intent(in) :: crit2 %age for highest peaks to remove real(kind=R8), intent(out) :: top %age of surface masked Called by proc~~def_masque~~CalledByGraph proc~def_masque def_masque proc~topology topology proc~topology->proc~def_masque program~test_morpho test_morpho program~test_morpho->proc~def_masque Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine def_masque ( msk , tab , long , larg , crit1 , crit2 , top ) !================================================================================================ !! Height mask without deepest pits and highest peaks !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ) :: crit1 !! *%age for deepest pits to remove* real ( kind = R8 ), intent ( in ) :: crit2 !! *%age for highest peaks to remove* real ( kind = R8 ), intent ( out ) :: top !! *%age of surface masked* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *heights 2D array* integer ( kind = I4 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: msk !! *mask* msk ( 1 : long , 1 : larg ) = 0 ! height masked : height above c1 + c2 * (1 - c1) ! ex: c1 = 15 %, c2 = 85 % -> heights that are above 85 % of the (1 - 15 %) core are masked where ( tab > crit1 + crit2 - crit1 * crit2 ) msk = 1 top = 100 * real ( sum ( msk ( 1 : long , 1 : larg ) ), kind = R8 ) / ( long * larg ) return endsubroutine def_masque","tags":"","loc":"proc/def_masque.html"},{"title":"erode_dilate – TPGLIB","text":"public  subroutine erode_dilate(msk, long, larg, val, act) Perform erosion or dilation on a binary mask depending on the value of act.\nThe operations utilize a defined kernel to affect neighboring pixels based on the specified val Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(inout), dimension(1:long,1:larg) :: msk 2D mask integer(kind=I4), intent(in) :: long 2D mask length integer(kind=I4), intent(in) :: larg 2D mask height integer(kind=I4), intent(in) :: val size of the structuring element for the erosion/dilation operation character(len=5), intent(in) :: act action to be performed, either “erode” or another operation, presumably “dilate”. Called by proc~~erode_dilate~~CalledByGraph proc~erode_dilate erode_dilate proc~topology topology proc~topology->proc~erode_dilate program~test_morpho test_morpho program~test_morpho->proc~erode_dilate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine erode_dilate ( msk , long , larg , val , act ) !================================================================================================ !! Perform erosion or dilation on a binary mask depending on the value of act. !! The operations utilize a defined kernel to affect neighboring pixels based on the specified val !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D mask length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D mask height* integer ( kind = I4 ), intent ( in ) :: val !! *size of the structuring element for the erosion/dilation operation* character ( len = 5 ), intent ( in ) :: act !! *action to be performed, either \"erode\" or another operation, presumably \"dilate\".* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: msk !! *2D mask* integer ( kind = I4 ) :: i , j , fin , ival integer ( kind = I4 ), dimension ( - val : val , - val : val ) :: ker ! If the action specified is \"erode\", the mask is inverted (0s become 1s and 1s become 0s). This prepares the mask for the erosion operation. if ( act == \"erode\" ) msk ( 1 : long , 1 : larg ) = 1 - msk ( 1 : long , 1 : larg ) fin = + 2 ! The forall construct fills the kernel with the value fin (2) for all points (i, j) within a circular area defined by the radius val. ! The center of the kernel (ker(0, 0)) is explicitly set to 0. ker ( - val : val , - val : val ) = 0 forall ( i = - val : + val , j = - val : + val , i ** 2 + j ** 2 <= val ** 2 ) ker ( i , j ) = fin ker ( 0 , 0 ) = 0 do j = 1 + val , larg - val do i = 1 + val , long - val ! If the pixel value at position (i, j) in the mask is even, the loop skips any further processing for that pixel and continues to the next iteration. if ( mod ( msk ( i , j ), 2 ) == 0 ) cycle ! If the pixel value is odd, the corresponding area in the mask defined by the kernel is updated by adding the kernel values to it. ! This implements the dilation operation. msk ( i - val : i + val , j - val : j + val ) = msk ( i - val : i + val , j - val : j + val ) + ker ( - val : val , - val : val ) enddo enddo ! This line sets all elements of the mask that are greater than or equal to 1 to 1, effectively binarizing the mask after dilation. where ( msk ( 1 : long , 1 : larg ) >= 1 ) msk = 1 ! If the action specified is \"erode\", the mask is inverted again, restoring it to its original form after dilation. if ( act == \"erode\" ) msk ( 1 : long , 1 : larg ) = 1 - msk ( 1 : long , 1 : larg ) return endsubroutine erode_dilate","tags":"","loc":"proc/erode_dilate.html"},{"title":"flood – TPGLIB","text":"private  subroutine flood(masque, taille, nx, ny, niv) Note Perform some kind of flood fill or connected component labeling on a grid (masque),\nstarting from an initial ‘1’ element found and spreading out to adjacent ‘1’ elements,\nupdating them to a specified value or zero if no value (niv) is specified. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(inout), dimension(1:nx, 1:ny) :: masque Input/output matrix integer(kind=I4), intent(out) :: taille Output scalar integer(kind=I4), intent(in) :: nx Input dimensions integer(kind=I4), intent(in) :: ny Input dimensions integer(kind=I4), intent(in), optional :: niv Optional input level Called by proc~~flood~~CalledByGraph proc~flood flood proc~count_cell count_cell proc~count_cell->proc~flood proc~topology topology proc~topology->proc~count_cell program~test_morpho test_morpho program~test_morpho->proc~count_cell Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flood ( masque , taille , nx , ny , niv ) !================================================================================================ !< @note !< !< Perform some kind of flood fill or connected component labeling on a grid (masque), !< starting from an initial '1' element found and spreading out to adjacent '1' elements, !< updating them to a specified value or zero if no value (niv) is specified. !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nx , ny !! *Input dimensions* integer ( kind = I4 ), intent ( in ), optional :: niv !! *Optional input level* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : nx , 1 : ny ) :: masque !! *Input/output matrix* integer ( kind = I4 ), intent ( out ) :: taille !! *Output scalar* integer ( kind = I4 ) :: i , j , p , q , k , ind , ival integer ( kind = I4 ) :: nb_traite ! Arrays to hold position indices and a tracking matrix integer ( kind = I4 ), dimension ( nx * ny ) :: liste_x , liste_y integer ( kind = I4 ), dimension ( nx , ny ) :: deja_fait ! Initialize arrays to zero liste_x = 0 liste_y = 0 deja_fait = 0 ! Initial position i = 0 j = 0 ! Find the first occurrence of the element \"1\" in masque o : do i = 1 , nx do j = 1 , ny if ( masque ( i , j ) == 1 ) exit o enddo enddo o ! If no element is found, set output size to zero and exit subroutine if ( i == nx + 1 . and . j == ny + 1 ) then taille = 0 return endif ! Initialize processing of found element ind = 1 liste_x ( ind ) = i liste_y ( ind ) = j ! Mark element as processed deja_fait ( i , j ) = 1 ! Start processing of elements nb_traite = 1 ! Explore neighbors in 8 directions (up, down, left, right and combinations) do i = liste_x ( nb_traite ) j = liste_y ( nb_traite ) ! Break the loop if outside bounds if ( i * j == 0 ) exit ! Check south direction k = 1 do p = i q = j - k if ( q < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check south-west direction k = 1 do p = i - k q = j - k if ( p < 1 ) exit if ( q < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check south-east direction k = 1 do p = i + k q = j - k if ( p > nx ) exit if ( q < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check north direction k = 1 do p = i q = j + k if ( q > nx ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check north-west direction k = 1 do p = i - k q = j + k if ( p < 1 ) exit if ( q > ny ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check north-east direction k = 1 do p = i + k q = j + k if ( p > nx ) exit if ( q > ny ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check west direction k = 1 do p = i - k q = j if ( p < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check east direction k = 1 do p = i + k q = j if ( p > nx ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Increment processed count nb_traite = nb_traite + 1 enddo ! Set output size to number of processed elements taille = ind ! Update masque values based on presence of niv and processed nodes ival = 0 if ( present ( niv ) ) ival = niv where ( deja_fait == 1 ) masque = ival ! Fill the connected region in 'masque' return endsubroutine flood","tags":"","loc":"proc/flood.html"},{"title":"make_composite_mask – TPGLIB","text":"private  subroutine make_composite_mask(msk, n_cells, locus, a, b, width, height, shap, long, larg) Note The subroutine generates a composite mask based on specified parameters.\nThe mask is filled with a number of shapes (in this case, ellipses) placed randomly within a defined area, while ensuring that the shapes do not overlap. If the locus is set to ‘center’, the subroutine immediately centers a single shape in the mask. If not centered, it attempts to randomly place the specified number of shapes ( n_cells ) within the mask.\n  The algorithm limits attempts to place shapes to avoid overlaps. The routine uses random numbers to determine the position of each shape, ensuring that they fit within the given dimensions and do not exceed the boundaries of the mask. A separate temporary mask ( msk_quad ) is used to track where shapes have already been placed, preventing overlaps. The process continues until the desired number of shapes is successfully placed or until a maximum number of attempts is reached (to avoid infinite loops). Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(1:long, 1:larg) :: msk Output mask that will be filled with shapes integer(kind=I4), intent(in) :: n_cells Number of cells to create in the composite mask character(len=6), intent(in) :: locus Position of the shape (e.g., ‘center’ for centering) integer(kind=I4), intent(in) :: a ellipsis first parameter integer(kind=I4), intent(in) :: b ellipsis second parameter integer(kind=I4), intent(in) :: width Width of each shape to be drawn in the mask integer(kind=I4), intent(in) :: height Height of each shape to be drawn in the mask character(len=8), intent(in) :: shap Type of shape to be drawn (here, ‘ellipsis’ is used) integer(kind=I4), intent(in) :: long Length (dimensions) of the mask integer(kind=I4), intent(in) :: larg Width (dimensions) of the mask Calls proc~~make_composite_mask~~CallsGraph proc~make_composite_mask make_composite_mask proc~make_mask make_mask proc~make_composite_mask->proc~make_mask Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_composite_mask ( msk , n_cells , locus , a , b , width , height , shap , long , larg ) !================================================================================================ !< @note !< !< The subroutine generates a composite mask based on specified parameters. !< The mask is filled with a number of shapes (in this case, ellipses) placed randomly within a defined area, while ensuring that the shapes do not overlap. !< !< + If the `locus` is set to 'center', the subroutine immediately centers a single shape in the mask. !< + If not centered, it attempts to randomly place the specified number of shapes (`n_cells`) within the mask. !<   The algorithm limits attempts to place shapes to avoid overlaps. !< + The routine uses random numbers to determine the position of each shape, ensuring that they fit within the given dimensions and do not exceed the boundaries of the mask. !< + A separate temporary mask (`msk_quad`) is used to track where shapes have already been placed, preventing overlaps. !< + The process continues until the desired number of shapes is successfully placed or until a maximum number of attempts is reached (to avoid infinite loops). !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_cells !! *Number of cells to create in the composite mask* integer ( kind = I4 ), intent ( in ) :: long !! *Length (dimensions) of the mask* integer ( kind = I4 ), intent ( in ) :: larg !! *Width (dimensions) of the mask* integer ( kind = I4 ), intent ( in ) :: width !! *Width of each shape to be drawn in the mask* integer ( kind = I4 ), intent ( in ) :: height !! *Height of each shape to be drawn in the mask* integer ( kind = I4 ), intent ( in ) :: a !! *ellipsis first parameter* integer ( kind = I4 ), intent ( in ) :: b !! *ellipsis second parameter* character ( len = 8 ), intent ( in ) :: shap !! *Type of shape to be drawn (here, 'ellipsis' is used)* character ( len = 6 ), intent ( in ) :: locus !! *Position of the shape (e.g., 'center' for centering)* integer ( kind = I4 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: msk !! *Output mask that will be filled with shapes* ! Declaration of local variables integer ( kind = I4 ) :: icells , x0 , y0 , iter , itry real ( kind = R8 ) :: x , y ! Temporary masks to manage the shapes integer ( kind = I4 ), dimension ( 1 : long , 1 : larg ) :: msk_quad , msk_shap ! Initialize the output mask to zero msk ( 1 : long , 1 : larg ) = 0 ! If the position is centered, calculate the central coordinates if ( locus == 'center' ) then x0 = long / 2 + 1 ! x-coordinate of the center y0 = larg / 2 + 1 ! y-coordinate of the center ! Call the subroutine to create a centered ellipse mask call make_mask ( x0 = x0 , & ! y0 = y0 , & ! a = a , & ! b = b , & ! shap = 'ellipsis' , & ! msk = msk , & ! long = long , & ! larg = larg ) ! return endif ! Initialize the attempt counter for placing cells itry = 0 l1 : do itry = itry + 1 ! Increment the attempt counter if ( itry > 100 ) exit l1 ! Limit the number of tries to 100 msk_quad ( 1 : long , 1 : larg ) = 0 ! Reset the quadrilateral mask msk ( 1 : long , 1 : larg ) = 0 ! Reset the final mask icells = 0 ! Cell placement counter iter = 0 ! Iteration counter for placement l2 : do iter = iter + 1 ! Increment the iteration counter if ( iter > 200 ) cycle l1 ! Limit the number of iterations to 200 ! Display the current state of the iteration and the number of cells write ( * , * ) iter , icells call random_number ( x ) ! Generate a random number for x x0 = width / 2 + 1 + x * ( long - width - 1 ) ! Calculate the x-coordinate of the center of the shape call random_number ( y ) ! Generate a random number for y y0 = height / 2 + 1 + y * ( larg - height - 1 ) ! Calculate the y-coordinate of the center of the shape msk_shap ( 1 : long , 1 : larg ) = 0 ! Reset the temporary shape mask ! Define the shape mask over a square area centered on (x0, y0) msk_shap ( x0 - width / 2 : x0 + width / 2 , & ! y0 - height / 2 : y0 + height / 2 ) = 1 ! ! Check if the shape does not overlap with an already placed shape if ( sum ( msk_quad ( 1 : long , 1 : larg ) * msk_shap ( 1 : long , 1 : larg )) > 0 ) cycle l2 ! Call the subroutine to create an ellipse mask at coordinates (x0, y0) call make_mask ( x0 = x0 , & ! y0 = y0 , & ! a = a , & ! b = b , & ! shap = 'ellipsis' , & ! msk = msk , & ! long = long , & ! larg = larg ) ! msk_quad ( x0 - width / 2 : x0 + width / 2 , & ! y0 - height / 2 : y0 + height / 2 ) = 1 ! Mark the area of the placed shape icells = icells + 1 ! Increment the count of placed cells if ( icells == n_cells ) exit l1 ! Exit if the desired number of cells has been reached enddo l2 enddo l1 return endsubroutine make_composite_mask","tags":"","loc":"proc/make_composite_mask.html"},{"title":"make_mask – TPGLIB","text":"private  subroutine make_mask(x0, y0, a, b, shap, msk, long, larg) Mask a region within a given shape (for the moment an ellipsis) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: x0 mask shape center 1st coordinate integer(kind=I4), intent(in) :: y0 mask shape center 2nd coordinate integer(kind=I4), intent(in) :: a ellipsis semi-length integer(kind=I4), intent(in) :: b ellipsis semi-height character(len=8), intent(in) :: shap kind of mask shape integer(kind=I4), intent(inout), dimension(1:long, 1:larg) :: msk mask integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height Called by proc~~make_mask~~CalledByGraph proc~make_mask make_mask proc~make_composite_mask make_composite_mask proc~make_composite_mask->proc~make_mask Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_mask ( x0 , y0 , a , b , shap , msk , long , larg ) !================================================================================================ !! Mask a region within a given shape (for the moment an ellipsis) !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* integer ( kind = I4 ), intent ( in ) :: x0 !! *mask shape center 1st coordinate* integer ( kind = I4 ), intent ( in ) :: y0 !! *mask shape center 2nd coordinate* integer ( kind = I4 ), intent ( in ) :: a !! *ellipsis semi-length* integer ( kind = I4 ), intent ( in ) :: b !! *ellipsis semi-height* character ( len = 8 ), intent ( in ) :: shap !! *kind of mask shape* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: msk !! *mask* integer ( kind = I4 ) :: i , j select case ( shap ) case ( 'ellipsis' ) forall ( i = 1 : long , j = 1 : larg , ( real ( i - x0 , kind = R8 ) / a ) ** 2 + ( real ( j - y0 , kind = R8 ) / b ) ** 2 < 1. ) msk ( i , j ) = 1 case default stop 'make_mask, bad choice' endselect return endsubroutine make_mask","tags":"","loc":"proc/make_mask.html"},{"title":"surf_area – TPGLIB","text":"public  subroutine surf_area(tab_in, long, larg, scale_xyz, aire) Function that returns the relative area of a surface minus 1. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long,1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz scale along x, y, z real(kind=R8), intent(out) :: aire computed area Called by proc~~surf_area~~CalledByGraph proc~surf_area surf_area program~test_morpho test_morpho program~test_morpho->proc~surf_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine surf_area ( tab_in , long , larg , scale_xyz , aire ) !================================================================================================ !! Function that returns the relative area of a surface minus 1. !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *scale along x, y, z* real ( kind = R8 ), intent ( out ) :: aire !! *computed area* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: z1 , z2 , z3 , z4 , hx , hy , hz hx = scale_xyz ( 1 ) hy = scale_xyz ( 2 ) hz = scale_xyz ( 3 ) ! Raisonnement sur chaque carré du domaine aire = 0. do j = 1 , larg - 1 do i = 1 , long - 1 z1 = tab_in ( i , j ) * hz z2 = tab_in ( i , j + 1 ) * hz z3 = tab_in ( i + 1 , j + 1 ) * hz z4 = tab_in ( i + 1 , j ) * hz aire = aire + 0.5_R8 * ( sqrt ( 1._R8 + ( ( z1 - z2 ) / hx ) ** 2 + ( ( z1 - z4 ) / hy ) ** 2 ) + & ! sqrt ( 1._R8 + ( ( z3 - z2 ) / hy ) ** 2 + ( ( z3 - z4 ) / hx ) ** 2 ) ) ! enddo enddo aire = aire / ( ( long - 1 ) * ( larg - 1 ) ) - 1._R8 return endsubroutine surf_area","tags":"","loc":"proc/surf_area.html"},{"title":"topology – TPGLIB","text":"public  subroutine topology(tab, long, larg, res) Note The function performs the following operations on a surface: mask the heights heights that are above 85 % of the (100% - 15 %) core, to avoid pits and peaks erode then dilate (opening) the mask count cells and the median size Reproduce the preceding steps with thresholds 15% and 95%. The results are put in the vector ‘res’ Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab heights 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(out), dimension(1:6) :: res results Calls proc~~topology~~CallsGraph proc~topology topology proc~count_cell count_cell proc~topology->proc~count_cell proc~def_masque def_masque proc~topology->proc~def_masque proc~erode_dilate erode_dilate proc~topology->proc~erode_dilate proc~calc_median calc_median proc~count_cell->proc~calc_median proc~flood flood proc~count_cell->proc~flood sort_array2 sort_array2 proc~calc_median->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine topology ( tab , long , larg , res ) !================================================================================================ !< @note !< !< The function performs the following operations on a surface: !< !< + mask the heights heights that are above 85 % of the (100% - 15 %) core, to avoid pits and peaks !< + erode then dilate (opening) the mask !< + count cells and the median size !< !< Reproduce the preceding steps with thresholds 15% and 95%. !< !< The results are put in the vector 'res' !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *heights 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : 6 ) :: res !! *results* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ) :: tab_tmp1 integer ( kind = I4 ), dimension ( 1 : long , 1 : larg ) :: msk real ( kind = R8 ) :: mintab , maxtab , top01 , top02 , med_cell01 , med_cell02 integer ( kind = I4 ) :: nbr_cell01 , nbr_cell02 mintab = minval ( tab ( 1 : long , 1 : larg ) ) maxtab = maxval ( tab ( 1 : long , 1 : larg ) ) tab_tmp1 ( 1 : long , 1 : larg ) = ( tab ( 1 : long , 1 : larg ) - mintab ) / ( maxtab - mintab ) call def_masque ( msk = msk , & ! OUT tab = tab_tmp1 , & ! IN long = long , & ! IN larg = larg , & ! IN crit1 = 0.15_R8 , & ! IN crit2 = 0.85_R8 , & ! IN top = top01 ) ! OUT !......................................! call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"erode\" ) ! IN call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"dilat\" ) ! IN call count_cell ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN nbr_cell = nbr_cell01 , & ! IN med_cell = med_cell01 ) ! IN !......................................! call def_masque ( msk = msk , & ! OUT tab = tab_tmp1 , & ! IN long = long , & ! IN larg = larg , & ! IN crit1 = 0.15_R8 , & ! IN crit2 = 0.95_R8 , & ! IN top = top02 ) ! OUT call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"erode\" ) ! IN call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"dilat\" ) ! IN call count_cell ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN nbr_cell = nbr_cell02 , & ! OUT med_cell = med_cell02 ) ! OUT res ( 1 : 6 ) = [ real ( nbr_cell01 , kind = R8 ), med_cell01 , top01 , & ! real ( nbr_cell02 , kind = R8 ), med_cell02 , top02 ] return endsubroutine topology","tags":"","loc":"proc/topology.html"},{"title":"fake_acv – TPGLIB","text":"subroutine fake_acv(acv_array, long, larg, param, ech) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), allocatable, dimension(:,:) :: acv_array integer(kind=I4), intent(in) :: long integer(kind=I4), intent(in) :: larg real(kind=R8), intent(in), dimension(1:3) :: param real(kind=R8), intent(in), dimension(1:2) :: ech Called by proc~~fake_acv~~CalledByGraph proc~fake_acv fake_acv program~test_anisotropy test_anisotropy program~test_anisotropy->proc~fake_acv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fake_acv ( acv_array , long , larg , param , ech ) implicit none real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: acv_array integer ( kind = I4 ), intent ( in ) :: long , larg real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: param real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: ech integer ( kind = I4 ) :: i , j , ia , ib , i0 , j0 real ( kind = R8 ) :: a , b , ang , c , s , echx , echy allocate ( acv_array ( 1 : long , 1 : larg ) ) a = param ( 1 ) b = param ( 2 ) ang = param ( 3 ) echx = ech ( 1 ) echy = ech ( 2 ) ia = int ( a / echx ) ib = int ( b / echy ) i0 = long / 2 + 1 j0 = larg / 2 + 1 c = cos ( ang * PI_R8 / 180 ) s = sin ( ang * PI_R8 / 180 ) do j = 1 , larg do i = 1 , long acv_array ( i , j ) = exp ( log ( 1. / 2. ) * sqrt ( ( ( + c * ( i - i0 ) + s * ( j - j0 ) ) / ia ) ** 2 + & ! ( ( - s * ( i - i0 ) + c * ( j - j0 ) ) / ib ) ** 2 ) ) ! enddo enddo return endsubroutine fake_acv","tags":"","loc":"proc/fake_acv.html"},{"title":"acv – TPGLIB","text":"public  subroutine acv(tab_in, tab_out, long, larg) Note Function that returns the acf of an array. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input array real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out acf of the input array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Calls proc~~acv~~CallsGraph proc~acv acv apod apod proc~acv->apod calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acv->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acv->calc_fftw3_real_fwd init_scal init_scal proc~acv->init_scal proc~calc_moments calc_moments proc~acv->proc~calc_moments trans_corner2center trans_corner2center proc~acv->trans_corner2center write_surf write_surf proc~acv->write_surf proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~acv~~CalledByGraph proc~acv acv proc~correlation_parameters correlation_parameters proc~correlation_parameters->proc~acv program~test_anisotropy test_anisotropy program~test_anisotropy->proc~correlation_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine acv ( tab_in , tab_out , long , larg ) !================================================================================================ !< @note Function that returns the *acf* of an array. !< !<  !< \\begin{align*} !<    acf(i,j) &= (z \\ast z)(i,j) = \\sum_{k,l}&#94;{n,n} z(k+1-i,l+1-j)z(k,l)  \\\\ !<    TF(acf)  &= ACF = Z \\cdot Z                                          \\\\ !<    acf      &= TF&#94;{-1}(ACF) = TF&#94;{-1}(Z&#94;2) !< \\end{align*} !<  !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *acf of the input array* integer ( kind = I4 ) :: nx2 , ny2 , iex , iey , ibx , iby , i , j , lo2 , la2 real ( kind = R8 ) :: tmp integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max complex ( kind = R8 ), dimension (:,:), allocatable :: cmpl real ( kind = R8 ), dimension (:,:), allocatable :: tab_ext1 , tab_ext2 type ( SCALE_SURF ) :: scal_surf type ( MOMENT_STAT ) :: m_res ! 0-padding if ( PAD_FFT_ANI < 0 ) then nx2 = long ny2 = larg ibx = 1 ; iex = long iby = 1 ; iey = larg else nx2 = 2 * ( nint ( PAD_FFT_ANI * long ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT_ANI * larg ) / 2 ) ibx = max ( ceiling ( ( nx2 - long ) / 2. ), 1 ) ; iex = ibx + long - 1 iby = max ( ceiling ( ( ny2 - larg ) / 2. ), 1 ) ; iey = iby + larg - 1 endif allocate ( tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! tab_ext2 ( 1 : nx2 , 1 : ny2 ) ) ! allocate ( cmpl ( 1 : nx2 , 1 : ny2 ) ) ! tab_ext1 ( 1 : nx2 , 1 : ny2 ) = 0 call calc_moments ( tab = tab_in ( 1 : long , 1 : larg ), & ! mx = m_res , & ! nb_mom = 2 ) ! tab_ext1 ( ibx : iex , iby : iey ) = ( tab_in ( 1 : long , 1 : larg ) - m_res % mu ) / m_res % si if ( APO_FFT_ANI /= \"no_apo\" ) then call apod ( tab_in = tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! tab_out = tab_ext2 ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 , & ! type_apo = trim ( APO_FFT_ANI ), & ! param = 0.1_R8 ) ! else tab_ext2 ( 1 : nx2 , 1 : ny2 ) = tab_ext1 ( 1 : nx2 , 1 : ny2 ) endif !---------------- call calc_fftw3_real_fwd ( tab_in = tab_ext2 ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = cmpl ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! cmpl ( 1 : nx2 , 1 : ny2 ) = cmplx ( abs ( cmpl ( 1 : nx2 , 1 : ny2 ) ) ** 2 , 0 , kind = R8 ) ! théorème de wiener call calc_fftw3_real_bwd ( tab_in = cmpl ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! call trans_corner2center ( tab_in = tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! tab_out = tab_ext2 ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! tab_out ( 1 : long , 1 : larg ) = tab_ext2 ( ibx : iex , iby : iey ) ! normalisation loc_max ( 1 : 2 ) = maxloc ( tab_out ( 1 : long , 1 : larg ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) tmp = tab_out ( lo2 , la2 ) tab_out ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) / tmp if (. true .) then call init_scal ( scal = scal_surf , & ! nx = long , & ! ny = larg , & ! lx = 1._R8 , & ! ly = 1._R8 , & ! unit_z = 'm ' ) ! call write_surf ( nom_fic = \"test_acv.sur\" , & ! tab_s = tab_out ( 1 : long , 1 : larg ), & ! scal = scal_surf ) ! endif deallocate ( cmpl ) deallocate ( tab_ext1 , tab_ext2 ) return endsubroutine acv","tags":"","loc":"proc/acv.html"},{"title":"correlation_parameters – TPGLIB","text":"public  subroutine correlation_parameters(tab, long, larg, res, cut, sub_plane, scale_xy, omp) Note Function that returns ellipse_acf parameters calculated on the autocorrelation\nfunction. But prior to the acf calculation, the mean plane is subtracted. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab 2D array in integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(out), dimension(1:8) :: res correlation parameters real(kind=R8), intent(in), optional :: cut cut height logical(kind=I4), intent(in) :: sub_plane subtract least square plane ? real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x and y in micrometers logical(kind=I4), intent(in) :: omp multithreaded ? Calls proc~~correlation_parameters~~CallsGraph proc~correlation_parameters correlation_parameters least_squares_tcheby least_squares_tcheby proc~correlation_parameters->least_squares_tcheby proc~acv acv proc~correlation_parameters->proc~acv proc~ellipse_acf ellipse_acf proc~correlation_parameters->proc~ellipse_acf apod apod proc~acv->apod calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acv->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acv->calc_fftw3_real_fwd init_scal init_scal proc~acv->init_scal proc~calc_moments calc_moments proc~acv->proc~calc_moments trans_corner2center trans_corner2center proc~acv->trans_corner2center write_surf write_surf proc~acv->write_surf get_unit get_unit proc~ellipse_acf->get_unit omp_get_num_procs omp_get_num_procs proc~ellipse_acf->omp_get_num_procs sort_array2 sort_array2 proc~ellipse_acf->sort_array2 proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~correlation_parameters~~CalledByGraph proc~correlation_parameters correlation_parameters program~test_anisotropy test_anisotropy program~test_anisotropy->proc~correlation_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine correlation_parameters ( tab , long , larg , res , cut , sub_plane , scale_xy , omp ) !================================================================================================ !< @note Function that returns [[ellipse_acf]] parameters calculated on the autocorrelation !< function. But prior to the acf calculation, the mean plane is subtracted. !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* logical ( kind = I4 ), intent ( in ) :: sub_plane !! *subtract least square plane ?* logical ( kind = I4 ), intent ( in ) :: omp !! *multithreaded ?* real ( kind = R8 ), intent ( in ), optional :: cut !! *cut height* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x and y in micrometers* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : 8 ) :: res !! *correlation parameters* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ) :: tab_tmp1 , tab_tmp2 if ( sub_plane ) then ! mean plane subtracted call least_squares_tcheby ( tab_in = tab ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp1 ( 1 : long , 1 : larg ), & ! OUT long1 = long , & ! IN long2 = larg , & ! IN nvarx = 1 , & ! IN nvary = 1 ) ! IN tab_tmp1 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) - tab_tmp1 ( 1 : long , 1 : larg ) else tab_tmp1 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) endif call acv ( tab_in = tab_tmp1 ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp2 ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg ) ! IN call ellipse_acf ( tabin = tab_tmp2 ( 1 : long , 1 : larg ), & ! IN long = long , & ! IN larg = larg , & ! IN p_acv = res ( 1 : 8 ), & ! OUT cut = cut , & ! IN scale_xy = scale_xy , & ! IN omp = omp ) ! IN return endsubroutine correlation_parameters","tags":"","loc":"proc/correlation_parameters.html"},{"title":"ellipse_acf – TPGLIB","text":"public  subroutine ellipse_acf(tabin, long, larg, p_acv, cut, scale_xy, omp) Note Function that returns p_acv which contains parameters on anisotropy. p_acv(1) = axe_a,                                ellipsis big axis p_acv(2) = axe_b,                                ellipsis small axis p_acv(3) = axe_a/axe_b                           another anisotropy factor p_acv(4) = nint(angle/inc_a),                    main texture orientation p_acv(5) = ray_pente,                            radius of greatest slope p_acv(6) = max_pente,                            greatest slope p_acv(7) = max_pente/min_pente                   slope anisotropy factor p_acv(8) = highest curvature/smallest curvature, curvature anisotropy factor Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin surface acf array integer(kind=I4), intent(in) :: long surface length integer(kind=I4), intent(in) :: larg surface width real(kind=R8), intent(out), dimension(1:8) :: p_acv vector containing anisotropy outputs real(kind=R8), intent(in), optional :: cut cut height real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x and y in micrometers logical(kind=I4), intent(in) :: omp multithreaded ? Calls proc~~ellipse_acf~~CallsGraph proc~ellipse_acf ellipse_acf get_unit get_unit proc~ellipse_acf->get_unit omp_get_num_procs omp_get_num_procs proc~ellipse_acf->omp_get_num_procs sort_array2 sort_array2 proc~ellipse_acf->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ellipse_acf~~CalledByGraph proc~ellipse_acf ellipse_acf proc~correlation_parameters correlation_parameters proc~correlation_parameters->proc~ellipse_acf program~test_anisotropy test_anisotropy program~test_anisotropy->proc~ellipse_acf program~test_anisotropy->proc~correlation_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ellipse_acf ( tabin , long , larg , p_acv , cut , scale_xy , omp ) !================================================================================================ !< @note Function that returns p_acv which contains parameters on anisotropy. !< !<  - p_acv(1) = axe_a,                                ellipsis big axis !<  - p_acv(2) = axe_b,                                ellipsis small axis !<  - p_acv(3) = axe_a/axe_b                           another anisotropy factor !<  - p_acv(4) = nint(angle/inc_a),                    main texture orientation !<  - p_acv(5) = ray_pente,                            radius of greatest slope !<  - p_acv(6) = max_pente,                            greatest slope !<  - p_acv(7) = max_pente/min_pente                   slope anisotropy factor !<  - p_acv(8) = highest curvature/smallest curvature, curvature anisotropy factor !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface width* logical ( kind = I4 ), intent ( in ) :: omp !! *multithreaded ?* real ( kind = R8 ), intent ( in ), optional :: cut !! *cut height* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *surface acf array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x and y in micrometers* real ( kind = R8 ), intent ( out ), dimension ( 1 : 8 ) :: p_acv !! *vector containing anisotropy outputs* integer ( kind = I4 ) :: i , k , ll , p , q , qp , qm , nb_p , nx , ny , lo2 , la2 , funit , nb_th logical ( kind = I4 ) :: verif real ( kind = R8 ) :: x , y , xb , yb , xm , ym , xp , yp , inc_a real ( kind = R8 ) :: r , r1 , rc , theta , h0 , hh , h1 , h2 , h3 , h4 , coupe , pente_locale , pente_locale_precede real ( kind = R8 ) :: angle , axe_a , axe_b , ech_x , ech_y , ech_z , ech_r real ( kind = R8 ) :: min_pente , max_pente , ray_pente real ( kind = R8 ) :: c , s integer ( kind = I4 ), dimension ( 0 : 179 ) :: p_min , e_angle integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max !, imax_acv real ( kind = R8 ), dimension ( 0 : 179 ) :: pente_max real ( kind = R8 ), dimension ( 0 : 359 ) :: ellipse real ( kind = R8 ), allocatable , dimension (:,:) :: tabou , tab_tmp real ( kind = R8 ), allocatable , dimension (:) :: courbure ech_x = scale_xy ( 1 ) !SCALE_IMG%dx * unit2IUf(SCALE_IMG%dx_unit) / 1.e-6  ! x lag in micron ech_y = scale_xy ( 2 ) !SCALE_IMG%dy * unit2IUf(SCALE_IMG%dy_unit) / 1.e-6  ! y lag in micron ech_z = 1. ! acf(0,0) = 1 loc_max ( 1 : 2 ) = maxloc ( tabin ( 1 : long , 1 : larg ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) !  on prend une surface carrée inscrite ll = min ( lo2 , la2 ) - 1 allocate ( tabou ( 0 : ll , 0 : 359 ) ) allocate ( courbure ( 0 : 359 ) ) tabou = EPS_R8 courbure = EPS_R8 !~       ! avec fftw, il faut mettre le max de l'acv en (lo2,la2) !~       imax_acv = maxloc( tabin(1:long, 1:larg) ) allocate ( tab_tmp ( 1 : long , 1 : larg ) ) tab_tmp ( 1 : long , 1 : larg ) = tabin ( 1 : long , 1 : larg ) verif = . false . if ( verif ) then ! sortie xyz call get_unit ( funit ) open ( funit , file = 'out/test_pol.dat' ) endif !  angle increment for polar representation of the rosette inc_a = 2 * PI_R8 / 360 !  determination of heights on a rosette diameter, obtained by linear interpolation : !  a point “falls” into a rectangular element [h1,h2,h3,h4], its height is determined by lin. interp. nb_p = 0 nb_th = 1 if ( omp ) nb_th = omp_get_num_procs () !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO SCHEDULE (STATIC,(ll+1)/nb_th) PRIVATE(p,r,q,theta,x,y,xm,ym,h1,h2,h3,h4,hh) do p = 0 , ll !  identifying a point on the diameter r = p !  corresponding algebraic radius do q = 0 , 359 !  angular increment identification theta = q * inc_a !  projection on x and y of the point marked by its radius and angle, taking the lower integer, !  gives the number of the bottom line and left-hand column of the rectangle !  the remainder (x-nx) represents the abscissa of the point in the rectangle with sides=1 !  the 0.9999 coefficient is used to avoid falling right on an existing point x = lo2 + r * cos ( theta ) * 0.9999_R8 ; nx = floor ( x ) ; xb = x - nx y = la2 + r * sin ( theta ) * 0.9999_R8 ; ny = floor ( y ) ; yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= long . and . ny + 1 <= larg . and . & nx >= 1 . and . ny >= 1 ) then ! attention r may be greater than lo2 or la2 h1 = tab_tmp ( nx , ny ) h2 = tab_tmp ( nx + 1 , ny ) h3 = tab_tmp ( nx + 1 , ny + 1 ) h4 = tab_tmp ( nx , ny + 1 ) hh = h1 * xm * ym + h2 * xp * ym + h3 * xp * yp + h4 * xm * yp tabou ( p , q ) = hh nb_p = nb_p + 1 else hh = 0. endif if ( verif ) write ( funit , * ) real ( x , kind = R4 ), real ( y , kind = R4 ), real ( hh , kind = R4 ) enddo enddo !$OMP END DO !$OMP END PARALLEL deallocate ( tab_tmp ) if ( verif ) close ( funit ) if ( present ( cut ) ) then coupe = cut else coupe = 0.5 endif do q = 0 , 359 !  angle en deg theta = q * inc_a !  angle en rad ech_r = sqrt ( ( ech_x * cos ( theta )) ** 2 + & ! ( ech_y * sin ( theta )) ** 2 ) !  unit according to angle q ellipse ( q ) = ( ll - 1 ) * ech_r !  max value of ellipse radius do p = 0 , ll - 1 !  identifying a point on the diameter r1 = p !  algebraic radius h1 = tabou ( p , q ) h2 = tabou ( p + 1 , q ) if ( abs ( h2 ) < 10 * EPS_R8 ) exit !  useful for ll = floor(sqrt(UN*(lo2**2 +la2**2))) -1 if ( h1 > coupe . and . h2 < coupe ) then rc = r1 + ( h1 - coupe ) / ( h1 - h2 ) ellipse ( q ) = rc * ech_r exit ! if you don't pass here: no intersection with the cutting plane -> max value taken by default endif enddo ! curvature averaged over 3 points rc = 0 do p = 1 , 3 h0 = tabou ( p - 1 , q ) h1 = tabou ( p , q ) h2 = tabou ( p + 1 , q ) if ( abs ( h2 ) < 10 * EPS_R8 ) exit !  useful for ll = floor(sqrt(UN*(lo2**2 +la2**2))) -1 rc = rc + ( h0 - 2 * h1 + h2 ) enddo courbure ( q ) = - ( rc / ( 2 * ech_r ** 2 ) ) / 3. enddo do q = 0 , 179 e_angle ( q ) = 2 * q ! angle doubled for the continuity of sin and cos enddo call sort_array2 ( tab_inout = ellipse ( 0 : 179 ), & ! tab1 = e_angle ( 0 : 179 ), & ! n = 180 ) ! axe_b = sum ( ellipse ( 0 : 2 )) / 3. axe_a = sum ( ellipse ( 177 : 179 )) / 3. c = sum ( cos ( e_angle ( 175 : 179 ) * PI_R8 / 180 ) ) / 5. s = sum ( sin ( e_angle ( 175 : 179 ) * PI_R8 / 180 ) ) / 5. angle = atan2 ( s , c ) * 180 / PI_R8 / 2 ! angle halfed (see above) p_acv ( 1 ) = axe_a p_acv ( 2 ) = axe_b p_acv ( 3 ) = axe_a / axe_b p_acv ( 4 ) = nint ( angle ) !----------------------------------------------- p_min ( 0 : 179 ) = ll - 1 do q = 0 , 179 !  incrément angulaire qp = q + 1 ; if ( qp > 179 ) qp = 0 qm = q - 1 ; if ( qm < 0 ) qm = 179 theta = q * inc_a ech_r = sqrt ( ( ech_x * cos ( theta )) ** 2 + & ! ( ech_y * sin ( theta )) ** 2 ) !  unit according to angle q pente_locale_precede = 0._R8 do p = 1 , ll - 1 pente_locale = ( ( tabou ( p + 1 , q ) - tabou ( p - 1 , q )) / 2 ) ** 2 + & ! ( ( tabou ( p , qp ) - tabou ( p , qm )) / ( 2 * p * inc_a ) ) ** 2 ! pente_locale = sqrt ( pente_locale ) * ech_z / ech_r if ( abs ( pente_locale ) < abs ( pente_locale_precede ) ) then p_min ( q ) = p !  the steepest slope distance is recorded exit else pente_locale_precede = pente_locale endif enddo enddo call sort_array2 ( tab_inout = p_min ( 0 : 179 ), & ! n = 180 ) ! k = int ( sum ( p_min ( 0 : 4 ) ) / 5. , kind = I4 ) !  the minimum distance do q = 0 , 179 !  angular increment qp = q + 1 ; if ( qp > 179 ) qp = 0 qm = q - 1 ; if ( qm < 0 ) qm = 179 theta = q * inc_a ech_r = sqrt ( ( ech_x * cos ( theta ) ) ** 2 + & ! ( ech_y * sin ( theta ) ) ** 2 ) !  unit according to angle q pente_locale = ( ( tabou ( k + 1 , q ) - tabou ( k - 1 , q )) / 2 ) ** 2 + & ! ( ( tabou ( k , qp ) - tabou ( k , qm )) / ( 2 * k * inc_a ) ) ** 2 ! pente_locale = sqrt ( pente_locale ) * ech_z / ech_r pente_max ( q ) = abs ( pente_locale ) !  for angle q, greater slope enddo do q = 0 , 179 e_angle ( q ) = q enddo call sort_array2 ( tab_inout = pente_max ( 0 : 179 ), & ! tab1 = e_angle ( 0 : 179 ), & ! n = 180 ) ! angle = sum ( e_angle ( 175 : 179 ) ) / 5. theta = angle * inc_a ech_r = sqrt ( ( ech_x * cos ( theta ) ) ** 2 + & ! ( ech_y * sin ( theta ) ) ** 2 ) !  unit according to angle q min_pente = sum ( pente_max ( 0 : 2 ) ) / 3. max_pente = sum ( pente_max ( 177 : 179 ) ) / 3. ray_pente = k * ech_r p_acv ( 5 ) = ray_pente p_acv ( 6 ) = max_pente p_acv ( 7 ) = max_pente / min_pente !  anisotropy indicator p_acv ( 8 ) = maxval ( courbure ( 0 : 359 ) ) / minval ( courbure ( 0 : 359 ) ) deallocate ( tabou , courbure ) return endsubroutine ellipse_acf","tags":"","loc":"proc/ellipse_acf.html"},{"title":"multiple_anisotropy – TPGLIB","text":"public  subroutine multiple_anisotropy(tabin, long, larg, scale_xy, multi_fft, vec_ani) Note Function that returns simple_anisotropy min, max and max/min for different Gaussian filter\ncutoff Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin surface acf array integer(kind=I4), intent(in) :: long surface length integer(kind=I4), intent(in) :: larg surface width real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x and y logical(kind=I4), intent(in) :: multi_fft parallel ffts? real(kind=R8), intent(out), dimension(1:9) :: vec_ani anisotropy parameters Calls proc~~multiple_anisotropy~~CallsGraph proc~multiple_anisotropy multiple_anisotropy init_scal init_scal proc~multiple_anisotropy->init_scal proc~fft_filter fft_filter proc~multiple_anisotropy->proc~fft_filter proc~simple_anisotropy simple_anisotropy proc~multiple_anisotropy->proc~simple_anisotropy write_surf write_surf proc~multiple_anisotropy->write_surf calc_fftw3_real_bwd calc_fftw3_real_bwd proc~fft_filter->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~fft_filter->calc_fftw3_real_fwd extend extend proc~fft_filter->extend proc~gaussian_filter gaussian_filter proc~fft_filter->proc~gaussian_filter tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~fft_filter->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~fft_filter->tab_calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~multiple_anisotropy~~CalledByGraph proc~multiple_anisotropy multiple_anisotropy program~test_anisotropy test_anisotropy program~test_anisotropy->proc~multiple_anisotropy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine multiple_anisotropy ( tabin , long , larg , scale_xy , multi_fft , vec_ani ) !================================================================================================ !< @note Function that returns simple_anisotropy min, max and max/min for different Gaussian filter !< cutoff !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface width* logical ( kind = I4 ), intent ( in ) :: multi_fft !! *parallel ffts?* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *surface acf array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x and y* real ( kind = R8 ), intent ( out ), dimension ( 1 : 9 ) :: vec_ani !! *anisotropy parameters* integer ( kind = I4 ) :: icut , i real ( kind = R8 ) :: dx , dy , fft_cutoff , length real ( kind = R8 ) :: max_mean_pks , min_mean_pks , rat_mean_pks , max_mean_len real ( kind = R8 ) :: min_mean_len , rat_mean_len , max_mean_slp , min_mean_slp , rat_mean_slp character ( len = 2 ) :: str real ( kind = R8 ), dimension ( 0 : 179 ) :: mean_len , mean_pks , mean_slp real ( kind = R8 ), allocatable , dimension (:,:) :: bf_tab real ( kind = R8 ), allocatable , dimension (:,:) :: mat_len !! *array containing anisotropy outputs* real ( kind = R8 ), allocatable , dimension (:,:) :: mat_pks !! *array containing anisotropy outputs* real ( kind = R8 ), allocatable , dimension (:,:) :: mat_slp !! *array containing anisotropy outputs* type ( SCALE_SURF ) :: scal_surf allocate ( bf_tab ( 1 : long , 1 : larg ) ) dx = scale_xy ( 1 ) ! x lag dy = scale_xy ( 2 ) ! y lag length = dx / 1.e-6 ! base cutoff = 1 µm allocate ( mat_len ( 0 : 179 , 1 : 10 ) ) allocate ( mat_pks ( 0 : 179 , 1 : 10 ) ) allocate ( mat_slp ( 0 : 179 , 1 : 10 ) ) call init_scal ( scal = scal_surf , & ! nx = long , & ! ny = larg , & ! lx = long * dx , & ! ly = larg * dy , & ! unit_z = 'nm' ) ! do icut = 1 , 10 fft_cutoff = length / icut call fft_filter ( tab = tabin ( 1 : long , 1 : larg ), & ! in long = long , & ! in larg = larg , & ! in cutoff = fft_cutoff , & ! in bf_tab = bf_tab ( 1 : long , 1 : larg ), & ! out multi_fft = multi_fft ) ! in write ( str , '(i2.2)' ) icut if (. false .) then call write_surf ( nom_fic = \"out/bf_tab\" // str // \".sur\" , & ! tab_s = bf_tab ( 1 : long , 1 : larg ), & ! scal = scal_surf ) ! endif call simple_anisotropy ( tabin = bf_tab ( 1 : long , 1 : larg ), & ! in long = long , & ! in larg = larg , & ! in vec_len = mat_len ( 0 : 179 , icut ), & ! out   path length ratios vec_pks = mat_pks ( 0 : 179 , icut ), & ! out   peak mean width vec_slp = mat_slp ( 0 : 179 , icut ), & ! out   RMS slopes scale_xy = scale_xy ( 1 : 2 ), & ! in multi_fft = multi_fft ) ! in enddo do i = 0 , 179 mean_pks ( i ) = sum ( mat_pks ( i , 06 : 10 ) ) / 5. ! mean on smoother profiles mean_len ( i ) = sum ( mat_len ( i , 01 : 05 ) ) / 5. mean_slp ( i ) = sum ( mat_slp ( i , 01 : 05 ) ) / 5. enddo deallocate ( bf_tab , mat_len , mat_pks , mat_slp ) max_mean_pks = maxval ( mean_pks ( 0 : 179 ) ) ! robust maximum of the peak mean width min_mean_pks = minval ( mean_pks ( 0 : 179 ) ) !        minimum rat_mean_pks = max_mean_pks / min_mean_pks ! ratio max_mean_len = maxval ( mean_len ( 0 : 179 ) ) ! robust maximum of the path length ratio min_mean_len = minval ( mean_len ( 0 : 179 ) ) !        minimum rat_mean_len = max_mean_len / min_mean_len ! ratio max_mean_slp = maxval ( mean_slp ( 0 : 179 ) ) ! robust maximum of the RMS slopes min_mean_slp = minval ( mean_slp ( 0 : 179 ) ) !        minimum rat_mean_slp = max_mean_slp / min_mean_slp ! ratio vec_ani ( 1 : 9 ) = [ max_mean_pks , min_mean_pks , rat_mean_pks , & ! max_mean_len , min_mean_len , rat_mean_len , & ! max_mean_slp , min_mean_slp , rat_mean_slp ] ! return endsubroutine multiple_anisotropy","tags":"","loc":"proc/multiple_anisotropy.html"},{"title":"simple_anisotropy – TPGLIB","text":"public  subroutine simple_anisotropy(tabin, long, larg, vec_len, vec_pks, vec_slp, scale_xy, multi_fft) Note Function that returns some anisotropy parameters calculated on a polar representation,\nfor each angle from 0 to 179 the excess of length the RMS slope the mean peak width Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin surface acf array integer(kind=I4), intent(in) :: long surface length integer(kind=I4), intent(in) :: larg surface width real(kind=R8), intent(out), dimension(0:179) :: vec_len vector containing path length ratios real(kind=R8), intent(out), dimension(0:179) :: vec_pks vector containing peak mean width real(kind=R8), intent(out), dimension(0:179) :: vec_slp vector containing RMS slopes real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x, y logical(kind=I4), intent(in) :: multi_fft parallel ffts? Called by proc~~simple_anisotropy~~CalledByGraph proc~simple_anisotropy simple_anisotropy proc~multiple_anisotropy multiple_anisotropy proc~multiple_anisotropy->proc~simple_anisotropy program~test_anisotropy test_anisotropy program~test_anisotropy->proc~multiple_anisotropy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine simple_anisotropy ( tabin , long , larg , vec_len , vec_pks , vec_slp , scale_xy , multi_fft ) !================================================================================================ !< @note Function that returns some anisotropy parameters calculated on a polar representation, !< for each angle from 0 to 179 !< !< + the excess of length !< + the RMS slope !< + the mean peak width !< !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface width* logical ( kind = I4 ), intent ( in ) :: multi_fft !! *parallel ffts?* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *surface acf array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x, y* real ( kind = R8 ), intent ( out ), dimension ( 0 : 179 ) :: vec_len !! *vector containing path length ratios* real ( kind = R8 ), intent ( out ), dimension ( 0 : 179 ) :: vec_pks !! *vector containing peak mean width* real ( kind = R8 ), intent ( out ), dimension ( 0 : 179 ) :: vec_slp !! *vector containing RMS slopes* integer ( kind = I4 ) :: lo , la , ll , nx , ny , ird integer ( kind = I4 ) :: p , q , k , nb_cross , nb_peak real ( kind = R8 ) :: scx , scy , dr , s , c real ( kind = R8 ) :: mx , my , reg_a , reg_b real ( kind = R8 ) :: h1 , h2 , h3 , h4 , hh real ( kind = R8 ) :: inc_a , theta , x , y , xb , yb , xm , ym , xp , yp , tmp real ( kind = R8 ), allocatable , dimension (:,:) :: height_disc real ( kind = R8 ), allocatable , dimension (:) :: vec_tmp , slope integer ( kind = I4 ), allocatable , dimension (:) :: cross , peaks ! lags in micron scx = scale_xy ( 1 ) ! x lag scy = scale_xy ( 2 ) ! y lag ! define the surface center location if ( long == 2 * ( long / 2 ) ) then ; lo = long / 2 + 1 ; else ; lo = long / 2 ; endif if ( larg == 2 * ( larg / 2 ) ) then ; la = larg / 2 + 1 ; else ; la = larg / 2 ; endif ! define the square length embedded in the surface ll = min ( lo , la ) - 1 allocate ( height_disc ( 0 : ll , 0 : 359 ) ) allocate ( vec_tmp ( 0 : 2 * ll ) ) allocate ( cross ( 1 : 2 * ll ) ) allocate ( slope ( 1 : 2 * ll ) ) allocate ( peaks ( 1 : 2 * ll ) ) ! angle increment inc_a = 2 * PI_R8 / 360 ! determination of heights on a diameter of the rosette, obtained by linear interpolation: ! a point \"falls\" into a rectangular element [h1,h2,h3,h4], its height is determined by linear interpolation. !* Calculate heights along the radius for each angular position. do p = 0 , ll ! point number on a radius ird = p ! point radius do q = 0 , 359 ! point angular location (°) theta = q * inc_a ! angular location (rad) ! projection on x and y of the point determined by its radius and angle ! by taking the floor, we get the number of the lower row and the left column of the rectangle ! the remainder (x-nx) thus represents the abscissa of the point in the rectangle with sides=1 x = lo + ird * cos ( theta ) if ( abs ( x - nint ( x )) < 1.e-3_R8 ) then nx = nint ( x ) else nx = floor ( x ) endif xb = x - nx y = la + ird * sin ( theta ) if ( abs ( y - nint ( y )) < 1.e-3_R8 ) then ny = nint ( y ) else ny = floor ( y ) endif yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= long . and . ny + 1 <= larg . and . & ! nx >= 1 . and . ny >= 1 ) then ! note ird may be greater than lo or la h1 = tabin ( nx , ny ) h2 = tabin ( nx + 1 , ny ) h3 = tabin ( nx + 1 , ny + 1 ) h4 = tabin ( nx , ny + 1 ) hh = h1 * xm * ym + & ! h2 * xp * ym + & ! h3 * xp * yp + & ! h4 * xm * yp ! height_disc ( p , q ) = hh endif enddo ! q = 0, 359 enddo ! p = 0, ll ! centering tmp = sum ( height_disc ( 0 : ll , 0 : 359 ) ) / ( ( ll + 1 ) * 360 ) height_disc ( 0 : ll , 0 : 359 ) = height_disc ( 0 : ll , 0 : 359 ) - tmp ! for each degree, determine the mean peak width and the path length ratio do q = 0 , 359 - 180 do p = ll , 1 , - 1 ; vec_tmp ( ll - p ) = height_disc ( p , q + 180 ) ; enddo ! left part of the height vector do p = 0 , ll , + 1 ; vec_tmp ( ll + p ) = height_disc ( p , q ) ; enddo ! right part theta = q * inc_a ; s = sin ( theta ) ; c = cos ( theta ) ! element length, usually scx=scy dr = sqrt ( ( s * scx ) ** 2 + ( c * scy ) ** 2 ) ! path relative length  ----------------------------------------------------------------------------------------------- ! tmp = 0. do p = 1 , 2 * ll tmp = tmp + sqrt ( dr ** 2 + ( vec_tmp ( p ) - vec_tmp ( p - 1 )) ** 2 ) enddo vec_len ( q ) = tmp / ( 2 * ll * dr ) - 1. ! path absolute slope  ------------------------------------------------------------------------------------------------ ! do p = 1 , 2 * ll slope ( p ) = ( vec_tmp ( p ) - vec_tmp ( p - 1 ) ) / dr enddo tmp = sum ( slope ( 1 : 2 * ll ) ) / ( 2 * ll ) slope ( 1 : 2 * ll ) = slope ( 1 : 2 * ll ) - tmp vec_slp ( q ) = sqrt ( sum ( slope ( 1 : 2 * ll ) ** 2 ) ) / ( 2 * ll ) ! find each abscissa point where the height crosses z=0 ----------------------------------------------------------------- ! !------- subtract mean profile (least square) mx = ( ll + 1 ) * dr ! x mean x = 0, dr, 2*dr, ..., 2*ll*dr my = sum ( vec_tmp ( 0 : 2 * ll ) ) / ( 2 * ll + 1 ) ! y mean reg_a = 0 tmp = 0 do p = 0 , 2 * ll reg_a = reg_a + ( p * dr - mx ) * ( vec_tmp ( p ) - my ) tmp = tmp + ( p * dr - mx ) ** 2 enddo reg_a = reg_a / tmp ! first regressor reg_b = my - reg_a * mx ! second regressor do p = 0 , 2 * ll vec_tmp ( p ) = vec_tmp ( p ) - ( reg_a * p * dr + reg_b ) enddo !------- find peaks cross ( 1 : 2 * ll ) = 0 peaks ( 1 : 2 * ll ) = 0 k = 1 cross ( k ) = 0 do p = 1 , 2 * ll if ( vec_tmp ( p - 1 ) * vec_tmp ( p ) < 0. ) then ! the height crosses z=0 k = k + 1 cross ( k ) = p endif enddo k = k + 1 cross ( k ) = 2 * ll nb_cross = k ! determine the peak width ! k = 0 do p = 1 , nb_cross - 1 if ( vec_tmp ( ( cross ( p + 1 ) + cross ( p )) / 2 ) > 0 ) then ! it must be a peak k = k + 1 peaks ( k ) = cross ( k + 1 ) - cross ( k ) endif enddo nb_peak = k ! mean peak width ! if ( nb_peak > 0 ) then vec_pks ( q ) = dr * sum ( peaks ( 1 : nb_peak ) ) / nb_peak else vec_pks ( q ) = dr * 2 * ll endif enddo deallocate ( height_disc , vec_tmp , cross , peaks , slope ) return endsubroutine simple_anisotropy","tags":"","loc":"proc/simple_anisotropy.html"},{"title":"plane – TPGLIB","text":"function plane(a, b, c, x, y) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: a real(kind=R8), intent(in) :: b real(kind=R8), intent(in) :: c real(kind=R8), intent(in) :: x real(kind=R8), intent(in) :: y Return Value real(kind=r8) Called by proc~~plane~~CalledByGraph proc~plane plane program~test_morpho test_morpho program~test_morpho->proc~plane Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/plane.html"},{"title":"stat_mom – TPGLIB","text":"Routines to calculate statistical moments, and some utilities Uses data_arch sort_arrays module~~stat_mom~~UsesGraph module~stat_mom stat_mom data_arch data_arch module~stat_mom->data_arch sort_arrays sort_arrays module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~stat_mom~~UsedByGraph module~stat_mom stat_mom module~abbott abbott module~abbott->module~stat_mom module~anisotropy anisotropy module~anisotropy->module~stat_mom module~filter filter module~anisotropy->module~filter module~asfc asfc module~asfc->module~stat_mom module~filter->module~stat_mom module~morpho morpho module~morpho->module~stat_mom program~test_morpho test_morpho program~test_morpho->module~stat_mom program~test_morpho->module~morpho program~test_stat test_stat program~test_stat->module~stat_mom module~grad_curv grad_curv module~grad_curv->module~filter program~test_abbott test_abbott program~test_abbott->module~abbott program~test_anisotropy test_anisotropy program~test_anisotropy->module~anisotropy program~test_asfc test_asfc program~test_asfc->module~asfc program~test_smooth test_smooth program~test_smooth->module~filter program~test_grad_curv test_grad_curv program~test_grad_curv->module~grad_curv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: moment_stat statistical moments Components Type Visibility Attributes Name Initial real(kind=R8), public :: Kk sixth moment real(kind=R8), public :: Ku kurtosis real(kind=R8), public :: Sk skewness real(kind=R8), public :: Ss fifth moment real(kind=R8), public :: mu mean real(kind=R8), public :: si standard deviation real(kind=R8), public :: va variance Functions public  function random_normal () Arguments None Return Value real(kind=r8) Note Adapted from the following fortran 77 code\n     algorithm 712, collected algorithms from acm.\n     this work published in transactions on mathematical software,\n     vol. 18, no. 4, december, 1992, pp. 434-435. The function random_normal() returns a normally distributed pseudo-random\n    number with zero mean and unit variance. The algorithm uses the ratio of uniforms method of a.j. kinderman\n   and j.f. monahan augmented with quadratic bounding curves. Author: Alan Miller csiro division of mathematical & information sciences private bag 10, clayton south mdc clayton 3169, victoria, australia public  function rnorm () result(fn_val) Generate a random normal deviate using the polar method. Read more… Arguments None Return Value real(kind=R8) public  function rnorm_vec (n, mu, sigma) result(variates) Vector of reals that follow a normal law Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n vector size real(kind=R8), intent(in), optional :: mu distribution mean real(kind=R8), intent(in), optional :: sigma distribution std Return Value real(kind=R8), dimension(1:n) output vector Subroutines public  subroutine calc_median (tab, mask, md) Function to calculate the median value of a series. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:) :: tab series 1D array logical(kind=I4), intent(in), optional, dimension(:) :: mask mask real(kind=R8), intent(out) :: md result: series median value public  subroutine calc_moments (tab, mask, mx, nb_mom) Function to calculate the statistical moments of an array with mask, of shape dim. 1 or 2 Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(..) :: tab 1D or 2D array logical(kind=I4), intent(in), optional, dimension(..) :: mask 1D or 2D mask type( moment_stat ), intent(out) :: mx moment_stat result integer(kind=I4), intent(in) :: nb_mom number of desired moments private  subroutine calc_moments_1D (tab, mask, mx, nb_mom) Function to calculate the statistical moments of a 1D array with mask, see calc_moments Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:) :: tab 1D array logical(kind=I4), intent(in), optional, dimension(:) :: mask 1D mask type( moment_stat ), intent(out) :: mx moment_stat result integer(kind=I4), intent(in) :: nb_mom number of desired moments public  subroutine scramble (tab, lg) scramble a vector of reals Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(1:lg) :: tab integer(kind=i4), intent(in) :: lg","tags":"","loc":"module/stat_mom.html"},{"title":"abbott – TPGLIB","text":"Returns the Firestone Abbott’s curve as well as some ISO 25178 parameters Uses miscellaneous least_squares pikaia_oop sort_arrays gnufor stat_mom data_arch module~~abbott~~UsesGraph module~abbott abbott data_arch data_arch module~abbott->data_arch gnufor gnufor module~abbott->gnufor least_squares least_squares module~abbott->least_squares miscellaneous miscellaneous module~abbott->miscellaneous module~stat_mom stat_mom module~abbott->module~stat_mom pikaia_oop pikaia_oop module~abbott->pikaia_oop sort_arrays sort_arrays module~abbott->sort_arrays module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~abbott~~UsedByGraph module~abbott abbott program~test_abbott test_abbott program~test_abbott->module~abbott Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine abbott_param (tab, lg, nom, curves, results, omp) Function that returns the Abbott’s curve in a svg file as well as smrk1, smrk2, spk, svk, sk Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:lg ) :: tab surface in a 1D vector integer(kind=I4), intent(in) :: lg surface total number of points character(len=*), intent(in) :: nom output generic name logical(kind=I4), intent(in), dimension(1:3) :: curves if true, generates a svg drawing 1: histogram 2: Abbott 3: tangent fit real(kind=R8), intent(out), dimension(1:11 ) :: results surface parameters output Read more… logical(kind=I4), intent(in) :: omp if true, openmp used","tags":"","loc":"module/abbott.html"},{"title":"asfc – TPGLIB","text":"A fast and accurate way of determining the area-scale fractal analysis complexity parameter Asfc Principle The ISO 25178-2:2012(E) states that “The observed area is calculated as a function of scale by a series of\nvirtual tiling exercises covering the measured surface in a patchwork fashion. The areas of the tiles, or patches,\nrepresent the areal scales of observation. The tiling exercises are repeated with tiles of progressively smaller areas to\ndetermine the observed areas to determine the observed areas as a function of the areal scales of observation. Then, the function log(relative area)=f(log(element area)) can be determined.\nThe area-scale fractal analysis complexity parameter Asfc is defined as a thousand times minus the line slope:. Determining the steepest part of the curve in a robust way It can be reasonably stated that most of relative area plots are S-shaped, even if the trail can be more linear\nthan curved. Instead of arbitrarily defining a “central” region where to calculate the maximum of the slope, the whole\ncurve is fitted with a family Tn , of monotonic functions. In most cases leads to an accurate fit, especially in the linear part of the curve, where the studied surface exhibits\nself-similarity properties. The proposed model is parsimonious — only four parameters have to be determined, with a\nleast square procedure for instance — and then doesn’t suffer from overfitting. Some surfaces have better fit results with but it doesn’t change much the Asfc value. The location of the steepest part is analytically determined by\ncanceling the second derivative of Tn . A simple calculus yields: when , it reduces to . To address the computation efficiency question — induced by the series of tiling exercises — the surface itself\nisn’t tiled as explained in ISO 25178. The different scales are those of the grids that are used to discretize the surface. The grids are chosen regular with lateral steps from (hx, hy) for the finest grid to (Hx, Hy) for the largest grid. The finest\ngrid is the one of the original surface, and the coarsest grid is an 8 × 8 grid. The original grid is the only one for which the surface points match the grid points, for the other grids the surface heights are obtained by interpolation. The intermediate grids are defined so that the element size has a geometric progression, hence its location is evenly spaced on a logarithm axis. Three surface interpolation methods are tested: linear (linear Finite Elements), interpolant cubic splines, and Hermite\n(Hermite Finite Elements) The chosen interpolation methods are: left, linear FE - middle, Hermite FE -  right, cubic spline. “dof” stands for “degree of\nfreedom”. In the upper part, one can see that from left to right, the smoothness increases. Below, calling u the unknown, it can be\nseen that increasing smoothness requires to take into account more derivatives. As the spline method guarantees curvature continuity,\nthe unknown and its derivatives must be computed globally. The surface heights are computed on the different grids with one of the three interpolation procedures that are\nproposed – linear (finite element style), Hermite (finite element style) and cubic spline. 128 grids are used to draw the\nrelative area curve.\nProvided the interpolating function f(x,y) , the area of a surface element defined on is obtained\nby integration of Such an expression being barely easy to analytically integrate, the Gauss integrating method is used with two points in each direction,\nwhich ensures the exact integration of a third degree polynomial on both directions. Uses miscellaneous least_squares surfile bspline stat_mom data_arch minpack module~~asfc~~UsesGraph module~asfc asfc bspline bspline module~asfc->bspline data_arch data_arch module~asfc->data_arch least_squares least_squares module~asfc->least_squares minpack minpack module~asfc->minpack miscellaneous miscellaneous module~asfc->miscellaneous module~stat_mom stat_mom module~asfc->module~stat_mom surfile surfile module~asfc->surfile module~stat_mom->data_arch sort_arrays sort_arrays module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~asfc~~UsedByGraph module~asfc asfc program~test_asfc test_asfc program~test_asfc->module~asfc Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), private, parameter :: hermite = 4 Hermite interpolation between grids integer(kind=I4), private, parameter :: kx = 3 x bspline order integer(kind=I4), private, parameter :: ky = 3 y bspline order integer(kind=I4), private, parameter :: larg0 = 8 roughest grid integer(kind=I4), private, parameter :: lin_all = 0 linear interpolation between grids logical(kind=I4), private, parameter :: live = .false. default for file outputs integer(kind=I4), private, parameter :: long0 = 8 roughest grid integer(kind=I4), private, parameter :: method_asfc = hermite default integer(kind=I4), private, parameter :: nb_beta = 4 number of parameters to be determined when optimizing integer(kind=I4), private, parameter :: npp = 128 number of points for the asfc determination logical(kind=I4), private, parameter :: out_her = live default for file outputs, Hermite case logical(kind=I4), private, parameter :: out_lin = live default for file outputs, linear case logical(kind=I4), private, parameter :: out_spl = live default for file outputs, spline case logical(kind=I4), private, parameter :: out_ter = live default for terminal output integer(kind=I4), private, parameter :: spl_all = 2 spline interpolation between grids integer(kind=I4), private :: unit_out_her output unit for the Hermite case integer(kind=I4), private :: unit_out_lin output unit for the linear case integer(kind=I4), private :: unit_out_spl output unit for the spline case Functions private  function df_boltz (xi, beta, n_beta, ivar) Fitting function partial derivatives. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi data point real(kind=R8), intent(inout), dimension(1:n_beta) :: beta parameter vector integer(kind=I4), intent(in) :: n_beta number of parameters integer(kind=I4), intent(in) :: ivar parameter number Return Value real(kind=r8) private  function dn_i (xi, i) 1D shape function derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi integer(kind=I4), intent(in) :: i Return Value real(kind=r8) private  function dnq_et_i (xi, et, i, j) 2D shape function derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) private  function dnq_xi_et_i (xi, et, i, j) 2D shape function , derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) private  function dnq_xi_i (xi, et, i, j) 2D shape function derivative, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) private  function f_boltz (xi, beta, n_beta) Fitting function. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi data point real(kind=R8), intent(inout), dimension(1:n_beta) :: beta parameter vector integer(kind=I4), intent(in) :: n_beta number of parameters Return Value real(kind=r8) private  function locate (n, xx, x) Function that returns the location of an element in a vector. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n vector length real(kind=R8), intent(in), dimension(1:n) :: xx vector real(kind=R8), intent(in) :: x value to locate Return Value integer(kind=i4) private  function locate2 (n, xx, x, eps) Function that returns the location of an element in a vector. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n vector length real(kind=R8), intent(in), dimension(1:n) :: xx vector real(kind=R8), intent(in) :: x value to locate real(kind=R8), intent(in) :: eps small value for comparisons of reals Return Value integer(kind=i4) private  function n_i (xi, i) 1D shape function, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi integer(kind=I4), intent(in) :: i Return Value real(kind=r8) private  function nq_i (xi, et, i, j) 2D shape function, quadratic case. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: et integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Subroutines private  subroutine calcul_aire (tab_in, long, larg, hx, hy, aire) Return the area of a surface Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long,1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in) :: hx increment along x real(kind=R8), intent(in) :: hy increment along y real(kind=R8), intent(out) :: aire computed area private  subroutine calcul_asfc (tab_in, scal, asfc_res, omp) Return the asfc of a surface regarding the default parameter method_asfc Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor logical(kind=I4), intent(in) :: omp with openmp ? public  subroutine calcul_asfc_hermite (tab_in, scal, asfc_res, omp) Return the asfc of a surface. The different grids are obtained by Hermite interpolation Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor logical(kind=I4), intent(in) :: omp with openmp ? private  subroutine calcul_asfc_lin_all (tab_in, scal, asfc_res) Return the asfc of a surface. The different grids are obtained by linear interpolation Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor private  subroutine calcul_asfc_spl_all (tab_in, scal, asfc_res) Return the asfc of a surface. The different grids are obtained by spline of degree 3 Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_in input surface type( SCALE_SURF ), intent(in) :: scal surface characteristics real(kind=R8), intent(out), dimension(1:2) :: asfc_res result: asfc, adjustment factor public  subroutine indice_fractal (tab_in, long, larg, indf) Function that returns the fractal dimension with the box counting method Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long surface array length integer(kind=I4), intent(in) :: larg surface array width real(kind=R8), intent(out), dimension(3) :: indf result: ordinate at origin, slope, R2 private  subroutine init_beta_boltz (bt, n_bt, v_x, v_y, n_pt) Function that initializes the fitting tanh function f_boltz parameters. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:n_bt) :: bt vector of parameters integer(kind=I4), intent(in) :: n_bt number of parameters real(kind=R8), intent(in), dimension(1:n_pt) :: v_x x data to fit real(kind=R8), intent(in), dimension(1:n_pt) :: v_y y data to fit integer(kind=I4), intent(in) :: n_pt data vector length","tags":"","loc":"module/asfc.html"},{"title":"grad_curv – TPGLIB","text":"Routines to calculate surface gradients and curvatures Uses sort_arrays surfile filter data_arch fftw3 module~~grad_curv~~UsesGraph module~grad_curv grad_curv data_arch data_arch module~grad_curv->data_arch fftw3 fftw3 module~grad_curv->fftw3 module~filter filter module~grad_curv->module~filter sort_arrays sort_arrays module~grad_curv->sort_arrays surfile surfile module~grad_curv->surfile module~filter->data_arch module~filter->fftw3 module~filter->sort_arrays module~filter->surfile module~stat_mom stat_mom module~filter->module~stat_mom module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~grad_curv~~UsedByGraph module~grad_curv grad_curv program~test_grad_curv test_grad_curv program~test_grad_curv->module~grad_curv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine curv2 (tab, nx, ny, dx, dy, gradxx, gradyy) Function to calculate the double derivatives of a 2D array Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradxx double derivative along x, x 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradyy double derivative along y, y 2D array public  subroutine curvature (tab, nx, ny, dx, dy, S_param_grad, S_param_curv, gcurvt) Function to calculate the gaussian curvature of a 2D array,\n       its mean quadratic value and the gradient mean quadratic value Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out) :: S_param_grad mean quadratic gradient value real(kind=R8), intent(out) :: S_param_curv mean quadratic curvature value real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gcurvt gaussian curvature  2D array private  subroutine deriv_N (x, y, mat_d) Function to provide the interpolation functions of a QU9 element, as well as its derivatives Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: x abscissa between -1 and +1 real(kind=R8), intent(in) :: y ordinate between -1 and +1 real(kind=R8), intent(out), dimension(1:9, 1:6) :: mat_d array containing N, dN/di, d2N/di2 public  subroutine gauss_curv (gradx, grady, nx, ny, dx, dy, gradxx, gradyy, gradxy) Function to calculate the double derivatives of a 2D array Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: gradx derivative along x 2D array real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: grady derivative along y 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradxx double derivative along x, x 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradyy double derivative along y, y 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradxy double derivative along x, y 2D array public  subroutine gradient (tab, nx, ny, dx, dy, gradx, grady) Function to calculate the gradient of a 2D array Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab Input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: gradx derivative along x 2D array real(kind=R8), intent(out), dimension(1:nx, 1:ny) :: grady derivative along y 2D array private  subroutine gradient_corner (hgt, gdx, gdy) Function that gives the nodal height gradients Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:3, 1:3) :: hgt local height 2D array real(kind=R8), intent(out), dimension(1:3) :: gdx nodal x gradient real(kind=R8), intent(out), dimension(1:3) :: gdy nodal x gradient public  subroutine label_surf_summits (tab, nx, ny, valleys, peaks, saddles, nb_summits) Function to output the extrema of a 2D array, as peaks, valleys or saddles. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along y integer(kind=I4), intent(out), dimension(:,:), allocatable :: valleys list of valley coordinates integer(kind=I4), intent(out), dimension(:,:), allocatable :: peaks list of peaks coordinates integer(kind=I4), intent(out), dimension(:,:), allocatable :: saddles list of saddles coordinates integer(kind=I4), intent(out), dimension(1:3) :: nb_summits number of extrema of each kind private  subroutine labelize_point (height, label, x, y) Function to label a point as: peak, valley, saddle or nothing particular Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:3, 1:3) :: height nodal height values as a 2D array character(len=1), intent(out) :: label kind of point real(kind=R8), intent(out), optional :: x coordinates of the extremum found real(kind=R8), intent(out), optional :: y coordinates of the extremum found public  subroutine peaks_and_pits_curvatures (heights, nx, ny, dx, dy, S_param_grad, S_param_curv, peak_curv, pits_curv) Function to calculate and output the peaks and pits curvatures as well as then mean quadratic\n       gradient value and the mean quadratic curvature value. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: heights input 2D array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along x real(kind=R8), intent(in) :: dx x lag real(kind=R8), intent(in) :: dy y lag real(kind=R8), intent(out) :: S_param_grad mean quadratic gradient value real(kind=R8), intent(out) :: S_param_curv mean quadratic curvature value real(kind=R8), intent(out) :: peak_curv 3 first peaks mean curvature real(kind=R8), intent(out) :: pits_curv 3 first pits  mean curvature public  subroutine test_label_surf_summits () Function to test the capicity in detecting peaks, pits and saddles in a simple double sinus\n       surface. Arguments None public  subroutine test_labelize_point () Function to test the function “labelize_point” on a QU9 domain with a 2nd order polynomial\n       along x and y Arguments None public  subroutine test_peaks_and_pits_curvatures () Function to test the function “peaks_and_pits_curvatures” on a real rough surface.\n       Outputs surface gradients and curvatures as 2D arrays or single values. Arguments None","tags":"","loc":"module/grad_curv.html"},{"title":"filter – TPGLIB","text":"Surface smoothers Morphological Filter Expand / reduce The morphological filter is a technique in surface processing used to process geometrical structures within a surface. Imagine a ball rolling over the surface. Depending on the size and shape of the ball, it modifies the surface differently: larger balls can bridge small gaps, while smaller balls can fall into minor crevices. This filter is particularly useful in operations such as closing and opening, which can help in joining narrow breaks and eliminating small holes within objects in an image, respectively. Median Filter 1 Expand / reduce The median filter is a non-linear digital filtering technique, often used to remove noise from surfaces. It works by moving through each point of the surface, and considering a small neighborhood around that element. The filter then replaces the element with the median of its neighboring values. This method is particularly effective because, unlike mean filtering, it can remove noise while preserving edges in the surfaces. The median filter maintains sharp edges in surfaces and is robust against the introduction of noise. Median Filter 2 Expand / reduce This median filter is a bit more complex than the classical median filter. An outlying observation, or “outlier”, is one that appears to deviate markedly from other members of the sample in which it occurs.\nTherefore no universal procedure exists to remove extra points: it depends on the kind of outliers and the surrounding data. In the present case several procedures have been tested and the one that best suits our need is the following: A 5x5 kernel median filter is applied to S1, giving S2. S3 = S1 -S2 represents the S1 deviation from the median. S3 is divided in 10 parts in each direction, and for each part the standard deviation is calculated. The global S3 deviation σ is defined as the median value of the 10x10 standard deviations Inspired by the normal law, the procedure ends with the substitution of heights, for which abs(S1-S2) > 3σ, by median heights. The cleaned surface which is obtained will be called SA in what follows. Eventhough the procedure is unusual, it provides satisfactory results in cleaning the primary extracted surfaces, without altering “real” points. Smoothing Filter Expand / reduce The 2D smoothing kernel with a stencil of [1 2 1] represents a simple, yet effective method for smoothing a surface. This stencil typically forms a part of a larger convolution kernel applied over an image to average height values, effectively reducing noise and detail. This kernel is often used in conjunction with a similar vertical stencil to create a two-dimensional convolution mask. In practice, the [1 2 1] stencil is one row of a matrix, with possibly a corresponding column vector [1; 2; 1], used to perform a 2D convolution operation on a surface. When applied, each height in the resulting surface is a weighted average of its neighbors with the weights given by the kernel: The central height in the neighborhood receives the highest weight, typically reflecting higher importance or influence on the resulting height value. The adjacent heights horizontally (and vertically, when combined with the vertical vector) receive a lower weight than the central height but contribute significantly to the smoothing effect. Corner heights, if included by expanding the kernel to a full 2x2 or 3x3 matrix using both horizontal and vertical components, would receive the lowest weights. In terms of application, the resulting convolution matrix for the two-dimensional case is :\n\n\n\\begin{matrix}\n1 & 2 & 1 \\\\\n2 & 4 & 2 \\\\\n1 & 2 & 1\n\\end{matrix}\n\n\nThis configuration spreads the influence of a single height to its eight neighbors in a weighted manner, with a stronger influence horizontally and vertically, rather than diagonally. The strength of smoothing is adjusted by normalizing this kernel (dividing all entries by the sum of the entries, which is 16 in the standard case), thereby ensuring that the total influence in the area remains constant, preserving overall height. Gaussian Filter Expand / reduce EN ISO 16610-61 septembre 2015 - Geometrical product specification (GPS) - Filtration - Part 61: Linear areal filters: Gaussian filters\n\n\n\nThe weighting function of an areal filter has the formula of a rotationally symmetric Gaussian function with a cut-off wavelength, \\lambda_c , given by :\n\n\nS(x,y)=\\frac{1}{\\alpha&#94;2 \\lambda_c&#94;2} \\; \\exp \\left[-\\frac{\\pi}{\\alpha&#94;2} \\; \\left( \\frac{x&#94;2 + y&#94;2}{\\lambda_c&#94;2} \\right) \\right]\n x is the distance from the centre (maximum) of the weighting function in X direction; y is the distance from the centre (maximum) of the weighting function in Y direction; \\lambda_c is the cut-off wavelength; \\alpha is the constant, to provide 50% transmission characteristic at the cut-off \\lambda_c. Therefore, \\displaystyle \\alpha = \\sqrt{\\frac{\\log 2}{\\pi}} The Gaussian filter is employed in surface processing for reducing detail and noise, effectively smoothing the surface. This filter utilizes a Gaussian function for calculating the transformation to apply to each point in the surface. It assigns weights to pixels with distances based on the Gaussian function's characteristics, heavily weighting pixels nearer to the central pixel and progressively less to those farther away. This creates a blurring effect that is very effective at high-frequency noise reduction, leading to a smoother appearance in surfaces. Uses sort_arrays surfile stat_mom data_arch fftw3 module~~filter~~UsesGraph module~filter filter data_arch data_arch module~filter->data_arch fftw3 fftw3 module~filter->fftw3 module~stat_mom stat_mom module~filter->module~stat_mom sort_arrays sort_arrays module~filter->sort_arrays surfile surfile module~filter->surfile module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~filter~~UsedByGraph module~filter filter module~anisotropy anisotropy module~anisotropy->module~filter module~grad_curv grad_curv module~grad_curv->module~filter program~test_smooth test_smooth program~test_smooth->module~filter program~test_anisotropy test_anisotropy program~test_anisotropy->module~anisotropy program~test_grad_curv test_grad_curv program~test_grad_curv->module~grad_curv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=R8), public :: PAD_FFT_FILTER = PAD_FFT Subroutines public  subroutine fft_filter (tab, long, larg, cutoff, bf_tab, multi_fft, pad, ext, type_apo) Classical Gaussian filter Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab 2D array in integer(kind=I4), intent(in) :: long 2D array width integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(in) :: cutoff cut-off wavelength real(kind=R8), intent(out), dimension(1:long, 1:larg) :: bf_tab 2D array out logical(kind=I4), intent(in) :: multi_fft multiple fft at once ? real(kind=R8), intent(in), optional :: pad fft padding character(len=*), intent(in), optional :: ext extension character(len=*), intent(in), optional :: type_apo apodization type private  subroutine gaussian_filter (long, larg, xc, gauss_filt) Gaussian kernel Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in) :: xc the cut-off wavelength real(kind=R8), intent(out), dimension(1:long, 1:larg) :: gauss_filt 2D array out public  subroutine median_filter (tab, long, larg, snb, kernel, sig, omp) A bit more complex filter: the overall height standard deviation is taken into account Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:long, 1:larg) :: tab 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width integer(kind=I4), intent(in) :: snb patch number along a direction integer(kind=I4), intent(in) :: kernel kernel size real(kind=R8), intent(in) :: sig error std logical(kind=I4), intent(in) :: omp if multithreading public  subroutine median_smooth (tab, long, larg, kernel, omp) Very classical smoothing Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:long, 1:larg) :: tab 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width integer(kind=I4), intent(in) :: kernel kernel size logical(kind=I4), intent(in) :: omp if multithreading public  subroutine morpho_filter (tabin, tabou, long, larg, scale_xyz, ray, omp, nb_div, mtype) Morphological filter: uses combinations of roll_smooth to provide all kind of transformation : Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin 2D array in real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tabou 2D array out integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz lag along x, y and scale z real(kind=R8), intent(in) :: ray roll radius logical(kind=I4), intent(in) :: omp if multithreading integer(kind=I4), intent(in) :: nb_div number of macro elements along an axis character(len=*), intent(in) :: mtype closing, opening, dilation or erosion private  subroutine roll_smooth (tabin, tabou, long, larg, scale_xyz, sgn, ray, omp, nb_div) A ball of radius “ray” rolls on / below the surface, hence defining a closing or an opening enveloppe. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin 2D array in real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tabou 2D array out integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz lag along x, y and scale z integer(kind=I4), intent(in) :: sgn + 1: dilation, -1:erosion real(kind=R8), intent(in) :: ray roll radius logical(kind=I4), intent(in) :: omp if multithreading integer(kind=I4), intent(in) :: nb_div number of macro elements along an axis public  subroutine soften (tabin, mask, tabout, long, larg) Function to smooth out a 2D array: each point is replaced by a weighted mean of its neighbors. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin 2D array in integer(kind=I4), intent(in), optional, dimension(1:long, 1:larg) :: mask mask real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tabout 2D array out integer(kind=I4), intent(in) :: long 2D array width integer(kind=I4), intent(in) :: larg 2D array height","tags":"","loc":"module/filter.html"},{"title":"morpho – TPGLIB","text":"Morphological operations Uses data_arch stat_mom miscellaneous module~~morpho~~UsesGraph module~morpho morpho data_arch data_arch module~morpho->data_arch miscellaneous miscellaneous module~morpho->miscellaneous module~stat_mom stat_mom module~morpho->module~stat_mom module~stat_mom->data_arch sort_arrays sort_arrays module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~morpho~~UsedByGraph module~morpho morpho program~test_morpho test_morpho program~test_morpho->module~morpho Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine calcul_normales (tab_in, long, larg, scale_xyz, cone_angle, hori, print_mask) Function that returns the fraction of surface nearly horizontal (normal less than 5 degrees\n       from a vertical line) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long,1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long surface array length integer(kind=I4), intent(in) :: larg surface array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz lag along x, y and scale z real(kind=R8), intent(in) :: cone_angle cone angle real(kind=R8), intent(out) :: hori fraction of facets nearly horizontal logical(kind=I4), intent(in), optional :: print_mask mask output ? public  subroutine count_cell (msk, long, larg, nbr_cell, med_cell) Calculate the number of cells in a mask, as well as the cell median size Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(inout), dimension(1:long, 1:larg) :: msk mask integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height integer(kind=I4), intent(out) :: nbr_cell number of cells real(kind=R8), intent(out), optional :: med_cell median size of the cells public  subroutine def_masque (msk, tab, long, larg, crit1, crit2, top) Height mask without deepest pits and highest peaks Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(1:long, 1:larg) :: msk mask real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab heights 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(in) :: crit1 %age for deepest pits to remove real(kind=R8), intent(in) :: crit2 %age for highest peaks to remove real(kind=R8), intent(out) :: top %age of surface masked public  subroutine erode_dilate (msk, long, larg, val, act) Perform erosion or dilation on a binary mask depending on the value of act.\nThe operations utilize a defined kernel to affect neighboring pixels based on the specified val Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(inout), dimension(1:long,1:larg) :: msk 2D mask integer(kind=I4), intent(in) :: long 2D mask length integer(kind=I4), intent(in) :: larg 2D mask height integer(kind=I4), intent(in) :: val size of the structuring element for the erosion/dilation operation character(len=5), intent(in) :: act action to be performed, either “erode” or another operation, presumably “dilate”. private  subroutine flood (masque, taille, nx, ny, niv) Perform some kind of flood fill or connected component labeling on a grid (masque),\nstarting from an initial ‘1’ element found and spreading out to adjacent ‘1’ elements,\nupdating them to a specified value or zero if no value (niv) is specified. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(inout), dimension(1:nx, 1:ny) :: masque Input/output matrix integer(kind=I4), intent(out) :: taille Output scalar integer(kind=I4), intent(in) :: nx Input dimensions integer(kind=I4), intent(in) :: ny Input dimensions integer(kind=I4), intent(in), optional :: niv Optional input level private  subroutine make_composite_mask (msk, n_cells, locus, a, b, width, height, shap, long, larg) The subroutine generates a composite mask based on specified parameters.\nThe mask is filled with a number of shapes (in this case, ellipses) placed randomly within a defined area, while ensuring that the shapes do not overlap. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(1:long, 1:larg) :: msk Output mask that will be filled with shapes integer(kind=I4), intent(in) :: n_cells Number of cells to create in the composite mask character(len=6), intent(in) :: locus Position of the shape (e.g., ‘center’ for centering) integer(kind=I4), intent(in) :: a ellipsis first parameter integer(kind=I4), intent(in) :: b ellipsis second parameter integer(kind=I4), intent(in) :: width Width of each shape to be drawn in the mask integer(kind=I4), intent(in) :: height Height of each shape to be drawn in the mask character(len=8), intent(in) :: shap Type of shape to be drawn (here, ‘ellipsis’ is used) integer(kind=I4), intent(in) :: long Length (dimensions) of the mask integer(kind=I4), intent(in) :: larg Width (dimensions) of the mask private  subroutine make_mask (x0, y0, a, b, shap, msk, long, larg) Mask a region within a given shape (for the moment an ellipsis) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: x0 mask shape center 1st coordinate integer(kind=I4), intent(in) :: y0 mask shape center 2nd coordinate integer(kind=I4), intent(in) :: a ellipsis semi-length integer(kind=I4), intent(in) :: b ellipsis semi-height character(len=8), intent(in) :: shap kind of mask shape integer(kind=I4), intent(inout), dimension(1:long, 1:larg) :: msk mask integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height public  subroutine surf_area (tab_in, long, larg, scale_xyz, aire) Function that returns the relative area of a surface minus 1. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long,1:larg) :: tab_in surface array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width real(kind=R8), intent(in), dimension(1:3) :: scale_xyz scale along x, y, z real(kind=R8), intent(out) :: aire computed area public  subroutine topology (tab, long, larg, res) The function performs the following operations on a surface: Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab heights 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(out), dimension(1:6) :: res results","tags":"","loc":"module/morpho.html"},{"title":"anisotropy – TPGLIB","text":"Subroutines for anisotropy detection in surfaces Anistropy analysis Autocorrelation function The autocorrelation function searches for correspondences of a surface with itself. If the surface heights are white noise, the only shift that matches the original surface is : and elsewhere. Conversely if the surface exhibits “macro” features, like peaks, valleys, scratches, etc. then decreases more slowly from its\nmaximum value 1 (reached in , ). If the surface is isotropic (no preferred direction) is axisymmetric, otherwise has a higher decreasing rate across the pattern direction. Therefore decreasing behavior is a means to catch the direction of anisotropy when it occurs, and especially it quantifies the amount of anisotropy, as explained on\nfigure the figure below. Autocorrelation function ellipsis Expand / reduce The aforementioned method needs a height z for the cutting plane. The *ISO 25178* norm suggests z=0.2, however it is\nnot suitable (it is too low) for numerous anisotropic surfaces. We propose to average the values of Sal and Rmax for\nz=0.3, 0.4 and 0.5. - (a) A typical surface to be analyzed.\n- (b) The normalized 2D autocorrelation function.\n- (c) Two profiles are extracted along directions #1 and #2; #1 across the scratches and #2 along the scratches.\n- (d) The profile #1 (red curve) is more self repeating than the profile #2 because of shorter wavelengths.\n- (e) A plane that cuts the 2D f_{ACF} surface at height z, defines an ellipsis—or just a part of it—with the small axis in direction #1 and the big axis in direction #2. The anisotropy can be quantified by Rmax/Sal, and the groove length by Rmax.\n\n(Rmax: semi-major axis, Sal: semi-minor axis)\n\nA complementary way of catching the decreasing behavior of f_{ACF} is to directly study its slope around\n(0,0), as explained below. Autocorrelation function slopes Expand / reduce - (a) In each direction, the point of maximum slope is recorded.\n- (b) At the minimum radius of the curve, the slopes are determined. The highest is located in A and the lowest in point B.\n- (c) Three parameters are built: b.sl=\\alpha_A , s.sl=\\alpha_B and r.sl = b.sl/s.sl. Simple / multiple anisotropy Expand / reduce Uses miscellaneous tchebychev sort_arrays filter surfile stat_mom data_arch fftw3 module~~anisotropy~~UsesGraph module~anisotropy anisotropy data_arch data_arch module~anisotropy->data_arch fftw3 fftw3 module~anisotropy->fftw3 miscellaneous miscellaneous module~anisotropy->miscellaneous module~filter filter module~anisotropy->module~filter module~stat_mom stat_mom module~anisotropy->module~stat_mom sort_arrays sort_arrays module~anisotropy->sort_arrays surfile surfile module~anisotropy->surfile tchebychev tchebychev module~anisotropy->tchebychev module~filter->data_arch module~filter->fftw3 module~filter->module~stat_mom module~filter->sort_arrays module~filter->surfile module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~anisotropy~~UsedByGraph module~anisotropy anisotropy program~test_anisotropy test_anisotropy program~test_anisotropy->module~anisotropy Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=6), public :: APO_FFT_ANI dimension multiplier for 0-padding real(kind=R8), public :: PAD_FFT_ANI dimension multiplier for 0-padding Subroutines public  subroutine acv (tab_in, tab_out, long, larg) Function that returns the acf of an array. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input array real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out acf of the input array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width public  subroutine correlation_parameters (tab, long, larg, res, cut, sub_plane, scale_xy, omp) Function that returns ellipse_acf parameters calculated on the autocorrelation\nfunction. But prior to the acf calculation, the mean plane is subtracted. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab 2D array in integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array height real(kind=R8), intent(out), dimension(1:8) :: res correlation parameters real(kind=R8), intent(in), optional :: cut cut height logical(kind=I4), intent(in) :: sub_plane subtract least square plane ? real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x and y in micrometers logical(kind=I4), intent(in) :: omp multithreaded ? public  subroutine ellipse_acf (tabin, long, larg, p_acv, cut, scale_xy, omp) Function that returns p_acv which contains parameters on anisotropy. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin surface acf array integer(kind=I4), intent(in) :: long surface length integer(kind=I4), intent(in) :: larg surface width real(kind=R8), intent(out), dimension(1:8) :: p_acv vector containing anisotropy outputs real(kind=R8), intent(in), optional :: cut cut height real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x and y in micrometers logical(kind=I4), intent(in) :: omp multithreaded ? public  subroutine multiple_anisotropy (tabin, long, larg, scale_xy, multi_fft, vec_ani) Function that returns simple_anisotropy min, max and max/min for different Gaussian filter\ncutoff Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin surface acf array integer(kind=I4), intent(in) :: long surface length integer(kind=I4), intent(in) :: larg surface width real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x and y logical(kind=I4), intent(in) :: multi_fft parallel ffts? real(kind=R8), intent(out), dimension(1:9) :: vec_ani anisotropy parameters public  subroutine simple_anisotropy (tabin, long, larg, vec_len, vec_pks, vec_slp, scale_xy, multi_fft) Function that returns some anisotropy parameters calculated on a polar representation,\nfor each angle from 0 to 179 Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tabin surface acf array integer(kind=I4), intent(in) :: long surface length integer(kind=I4), intent(in) :: larg surface width real(kind=R8), intent(out), dimension(0:179) :: vec_len vector containing path length ratios real(kind=R8), intent(out), dimension(0:179) :: vec_pks vector containing peak mean width real(kind=R8), intent(out), dimension(0:179) :: vec_slp vector containing RMS slopes real(kind=R8), intent(in), dimension(1:2) :: scale_xy lag along x, y logical(kind=I4), intent(in) :: multi_fft parallel ffts?","tags":"","loc":"module/anisotropy.html"},{"title":"test_stat – TPGLIB","text":"Uses data_arch stat_mom program~~test_stat~~UsesGraph program~test_stat test_stat data_arch data_arch program~test_stat->data_arch module~stat_mom stat_mom program~test_stat->module~stat_mom module~stat_mom->data_arch sort_arrays sort_arrays module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Routines to calculate statistical moments. Example of use. Calls program~~test_stat~~CallsGraph program~test_stat test_stat proc~calc_median calc_median program~test_stat->proc~calc_median proc~calc_moments calc_moments program~test_stat->proc~calc_moments proc~rnorm_vec rnorm_vec program~test_stat->proc~rnorm_vec sort_array2 sort_array2 proc~calc_median->sort_array2 proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d proc~rnorm rnorm proc~rnorm_vec->proc~rnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), allocatable, dimension(:) :: array real(kind=R8), allocatable, dimension(:,:) :: array2D logical(kind=I4), allocatable, dimension(:) :: array_mask logical(kind=I4), allocatable, dimension(:,:) :: array_mask2D integer(kind=I4) :: i integer(kind=I4) :: ipow integer(kind=I4) :: iter real(kind=R8) :: median type( moment_stat ) :: mom real(kind=R8), parameter :: mu = 2.0_R8 integer(kind=I4), parameter :: n = rn**2 integer(kind=I4), parameter :: nn = 1e7 real(kind=R8), dimension(1:6) :: results integer(kind=I4), parameter :: rn = 1e3 real(kind=R8), parameter :: sigma = 3.0_R8 real(kind=R8), allocatable, dimension(:) :: vx real(kind=R8) :: x Source Code program test_stat use data_arch , only : I4 , R8 , PI_R8 use stat_mom implicit none real ( kind = R8 ), allocatable , dimension (:) :: array logical ( kind = I4 ), allocatable , dimension (:) :: array_mask real ( kind = R8 ), allocatable , dimension (:,:) :: array2D logical ( kind = I4 ), allocatable , dimension (:,:) :: array_mask2D real ( kind = R8 ), dimension ( 1 : 6 ) :: results integer ( kind = I4 ), parameter :: rn = 1e3 integer ( kind = I4 ), parameter :: n = rn ** 2 type ( moment_stat ) :: mom integer ( kind = I4 ) :: i real ( kind = R8 ) :: x , median real ( kind = R8 ), allocatable , dimension (:) :: vx real ( kind = R8 ), parameter :: mu = 2.0_R8 , sigma = 3.0_R8 integer ( kind = I4 ), parameter :: nn = 1e7 integer ( kind = I4 ) :: ipow , iter allocate ( array ( 1 : n ) ) allocate ( array_mask ( 1 : n ) ) allocate ( array2D ( 1 : rn , 1 : rn ) ) allocate ( array_mask2D ( 1 : rn , 1 : rn ) ) array_mask = . false . do i = 0 , n - 1 x = real ( i , kind = R8 ) / ( n - 1 ) array ( i + 1 ) = sin ( 4 * PI_R8 * x ) * exp ( - 5 * x ) + x ** 2 if ( mod ( i , 2 ) == 0 ) array_mask ( i + 1 ) = . True . enddo array2D = reshape ( array ( 1 : n ), [ rn , rn ] ) array_mask2D = reshape ( array_mask ( 1 : n ), [ rn , rn ] ) !============================================================================== 1D WITH MASK call calc_moments ( tab = array , mask = array_mask , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , mask = array_mask , md = median ) results = [ 0.4015711287531725 , 0.08020113698321299 , 0.28319805257666053 , 0.07977645748158539 , 2.1330678728336125 , 0.42620050599180814 ] ! python !         [ 0.40157112875317|66, 0.08020113698321|186, 0.2831980525766|5853, 0.0797764574815|4369, 2.1330678728336|414, 0.42620050599180814 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median !============================================================================== 1D NO MASK call calc_moments ( tab = array , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , md = median ) results = [ 0.4015716287568354 , 0.08020123540993489 , 0.28319822635379427 , 0.07977715735614675 , 2.1330700214753766 , 0.42620146392518804 ] ! python !         [ 0.4015716287568|2495, 0.08020123540993|2986,  0.28319822635379|088,  0.079777157356|279285, 2.133070021475|4486, 0.426201463925188|10 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With NO mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median !============================================================================== 2D WITH MASK call calc_moments ( tab = array2D , mask = array_mask2D , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , mask = array_mask , md = median ) results = [ 0.4015711287531725 , 0.08020113698321299 , 0.28319805257666053 , 0.07977645748158539 , 2.1330678728336125 , 0.42620050599180814 ] ! python !         [ 0.40157112875317|66, 0.08020113698321|186, 0.2831980525766|5853, 0.0797764574815|4369, 2.1330678728336|414, 0.42620050599180814 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median !============================================================================== 2D NO MASK call calc_moments ( tab = array2D , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , md = median ) results = [ 0.4015716287568354 , 0.08020123540993489 , 0.28319822635379427 , 0.07977715735614675 , 2.1330700214753766 , 0.42620146392518804 ] ! python !         [ 0.4015716287568|2495, 0.08020123540993|2986,  0.28319822635379|088,  0.079777157356|279285, 2.133070021475|4486, 0.426201463925188|10 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With NO mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median deallocate ( array , array_mask , array2D , array_mask2D ) !============================================================================== TEST RND NORM call random_seed () allocate ( vx ( 1 : nn ) ) write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'Test random normal' write ( * , \"(*(a8))\" ) \"n\" , \"mu\" , \"sigma\" write ( * , \"(i8,2f8.4)\" ) nn , mu , sigma write ( * , \"(/,'central moments',/,*(i10))\" ) ( ipow , ipow = 1 , 4 ) do iter = 1 , 5 vx = rnorm_vec ( nn , mu , sigma ) vx = vx - sum ( vx ) / nn write ( * , \"(*(f10.4))\" ) ( sum ( vx ** ipow ) / nn , ipow = 1 , 4 ) enddo write ( * , * ) \"theoretical\" write ( * , \"(*(f10.4))\" ) 0.0_R8 , sigma ** 2 , 0.0_R8 , 3 * sigma ** 4 deallocate ( vx ) stop endprogram test_stat","tags":"","loc":"program/test_stat.html"},{"title":"test_smooth – TPGLIB","text":"Uses miscellaneous surfile filter data_arch fftw3 program~~test_smooth~~UsesGraph program~test_smooth test_smooth data_arch data_arch program~test_smooth->data_arch fftw3 fftw3 program~test_smooth->fftw3 miscellaneous miscellaneous program~test_smooth->miscellaneous module~filter filter program~test_smooth->module~filter surfile surfile program~test_smooth->surfile module~filter->data_arch module~filter->fftw3 module~filter->surfile module~stat_mom stat_mom module~filter->module~stat_mom sort_arrays sort_arrays module~filter->sort_arrays module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_smooth~~CallsGraph program~test_smooth test_smooth end_fftw3 end_fftw3 program~test_smooth->end_fftw3 extend extend program~test_smooth->extend fftw_plan_with_nthreads fftw_plan_with_nthreads program~test_smooth->fftw_plan_with_nthreads init_fftw3 init_fftw3 program~test_smooth->init_fftw3 omp_get_max_threads omp_get_max_threads program~test_smooth->omp_get_max_threads proc~fft_filter fft_filter program~test_smooth->proc~fft_filter proc~median_filter median_filter program~test_smooth->proc~median_filter proc~median_smooth median_smooth program~test_smooth->proc~median_smooth proc~morpho_filter morpho_filter program~test_smooth->proc~morpho_filter proc~soften soften program~test_smooth->proc~soften read_surf read_surf program~test_smooth->read_surf unit2IUf unit2IUf program~test_smooth->unit2IUf write_surf write_surf program~test_smooth->write_surf proc~fft_filter->extend calc_fftw3_real_bwd calc_fftw3_real_bwd proc~fft_filter->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~fft_filter->calc_fftw3_real_fwd proc~gaussian_filter gaussian_filter proc~fft_filter->proc~gaussian_filter tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~fft_filter->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~fft_filter->tab_calc_fftw3_real_fwd proc~median_filter->proc~median_smooth proc~calc_median calc_median proc~median_filter->proc~calc_median proc~calc_moments calc_moments proc~median_filter->proc~calc_moments omp_get_num_procs omp_get_num_procs proc~median_smooth->omp_get_num_procs proc~median_smooth->proc~calc_median sort_array2 sort_array2 proc~median_smooth->sort_array2 proc~roll_smooth roll_smooth proc~morpho_filter->proc~roll_smooth proc~calc_median->sort_array2 proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d proc~roll_smooth->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8) :: dx real(kind=R8) :: dy real(kind=R8) :: dz real(kind=R8), allocatable, dimension(:,:) :: ext_heights real(kind=R8) :: fft_cutoff real(kind=R8), allocatable, dimension(:,:) :: heights real(kind=R8), allocatable, dimension(:,:) :: heights_copy real(kind=R8), allocatable, dimension(:,:) :: heights_out real(kind=R8), allocatable, dimension(:,:) :: mask integer(kind=I4) :: n_th integer(kind=I4) :: nx integer(kind=I4) :: nx2 integer(kind=I4) :: ny integer(kind=I4) :: ny2 real(kind=R8) :: pad type( SCALE_SURF ) :: scal_mask type( SCALE_SURF ) :: scal_surf Source Code program test_smooth use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use surfile , only : read_surf , write_surf , init_scal , SCALE_SURF , unit2IUf use filter , only : median_smooth , median_filter , soften , morpho_filter , fft_filter , PAD_FFT_FILTER use fftw3 , only : fftw_plan_with_nthreads , init_fftw3 , end_fftw3 , extend !$ use omp_lib implicit none real ( kind = R8 ), allocatable , dimension (:,:) :: heights , heights_out , heights_copy , mask , ext_heights real ( kind = R8 ) :: dx , dy , dz , fft_cutoff , pad integer ( kind = I4 ) :: nx , ny , nx2 , ny2 , n_th type ( SCALE_SURF ) :: scal_surf , scal_mask !========================================================================= padding / windowing call read_surf ( nom_fic = \"sur/AB-Zinv-ART-8-21-200x200.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres pad = 1.5 !PAD_FFT_FILTER nx2 = 2 * ( nint ( pad * nx ) / 2 ) ny2 = 2 * ( nint ( pad * ny ) / 2 ) allocate ( ext_heights ( 1 : nx2 , 1 : ny2 ) ) call extend ( tab_in = heights ( 1 : nx , 1 : ny ), & ! tab_out = ext_heights ( 1 : nx2 , 1 : ny2 ), & ! nx = nx , & ! ny = ny , & ! nx2 = nx2 , & ! ny2 = ny2 , & ! ext = 'constant' , & ! type_apo = 'hann__' ) ! scal_surf % xres = nx2 scal_surf % yres = ny2 call write_surf ( nom_fic = \"out/test_extend.sur\" , & ! tab_s = ext_heights ( 1 : nx2 , 1 : ny2 ), & ! scal = scal_surf ) ! deallocate ( ext_heights ) !========================================================================= fft_filter 5 µm call read_surf ( nom_fic = \"sur/AB-Zinv-ART-8-21-200x200.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres dx = scal_surf % dx * unit2IUf ( scal_surf % dx_unit ) dy = scal_surf % dy * unit2IUf ( scal_surf % dy_unit ) dz = 0 write ( * , * ) 'nx, ny = ' , nx , ny write ( * , * ) 'dx, dy = ' , dx , dy allocate ( heights_out ( 1 : nx , 1 : ny ) ) n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) nx2 = 2 * ( nint ( PAD_FFT_FILTER * nx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT_FILTER * ny ) / 2 ) fft_cutoff = dx / 5.e-6 call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! cutoff = fft_cutoff , & ! bf_tab = heights_out ( 1 : nx , 1 : ny ), & ! multi_fft = . FALSE .) ! call write_surf ( nom_fic = \"out/test_fft_filter_005µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'gaussian filter cutoff = 5 µm' !========================================================================= fft_filter 80 µm fft_cutoff = dx / 8 0.e-6 call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! cutoff = fft_cutoff , & ! bf_tab = heights_out ( 1 : nx , 1 : ny ), & ! multi_fft = . FALSE .) ! call write_surf ( nom_fic = \"out/test_fft_filter_080µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'gaussian filter cutoff = 80 µm' !========================================================================= fft_filter 150 µm fft_cutoff = dx / 15 0.e-6 call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! cutoff = fft_cutoff , & ! bf_tab = heights_out ( 1 : nx , 1 : ny ), & ! multi_fft = . FALSE .) ! call write_surf ( nom_fic = \"out/test_fft_filter_150µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'gaussian filter cutoff = 150 µm' call end_fftw3 () !========================================================================= ROLL +, RAY = 10 µm call morpho_filter ( mtype = \"dilation\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_dilation_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: dilation disk 10 µm' !------------------------------------------------------------------------- ROLL -, RAY = 10 µm call morpho_filter ( mtype = \"erosion\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_erosion_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: erosion disk 10 µm' !------------------------------------------------------------------------- CLOSING, RAY = 10 µm call morpho_filter ( mtype = \"closing\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_closing_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: closing disk 10 µm' !------------------------------------------------------------------------- OPENING, RAY = 10 µm call morpho_filter ( mtype = \"opening\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_opening_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: opening disk 10 µm' !========================================================================= KERNEL SIZE = 3 allocate ( heights_copy ( 1 : nx , 1 : ny ) ) heights_copy ( 1 : nx , 1 : ny ) = heights ( 1 : nx , 1 : ny ) call median_smooth ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 3 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_smooth_3.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'median filter kernel: 3' !========================================================================= KERNEL SIZE = 5 heights ( 1 : nx , 1 : ny ) = heights_copy ( 1 : nx , 1 : ny ) call median_smooth ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 5 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_smooth_5.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'median filter kernel: 5' !========================================================================= KERNEL SIZE = 9 heights ( 1 : nx , 1 : ny ) = heights_copy ( 1 : nx , 1 : ny ) call median_smooth ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 9 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_smooth_9.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'median filter kernel: 9' !========================================================================= SOFTEN NO MASK heights ( 1 : nx , 1 : ny ) = heights_copy ( 1 : nx , 1 : ny ) call soften ( tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabout = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny ) ! IN call write_surf ( nom_fic = \"out/test_soften_no_mask.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'simple smooth with no mask' !========================================================================= SOFTEN WITH MASK call read_surf ( nom_fic = \"sur/test_mask.sur\" , & ! IN tab_s = mask , & ! OUT scal = scal_mask ) ! OUT call soften ( tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabout = heights_out ( 1 : nx , 1 : ny ), & ! OUT mask = nint ( mask ( 1 : nx , 1 : ny )), & ! IN long = nx , & ! IN larg = ny ) ! IN call write_surf ( nom_fic = \"out/test_soften_with_mask.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'simple smooth in upper mask' !========================================================================= MEDIAN FILTER SNB = 10, KERN = 15 call median_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 15 , & ! IN snb = 10 , & ! IN sig = 3._R8 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_filt_k15_s10.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! deallocate ( heights , heights_copy , heights_out , mask ) stop endprogram test_smooth","tags":"","loc":"program/test_smooth.html"},{"title":"test_abbott – TPGLIB","text":"Uses data_arch abbott surfile miscellaneous program~~test_abbott~~UsesGraph program~test_abbott test_abbott data_arch data_arch program~test_abbott->data_arch miscellaneous miscellaneous program~test_abbott->miscellaneous module~abbott abbott program~test_abbott->module~abbott surfile surfile program~test_abbott->surfile module~abbott->data_arch module~abbott->miscellaneous gnufor gnufor module~abbott->gnufor least_squares least_squares module~abbott->least_squares module~stat_mom stat_mom module~abbott->module~stat_mom pikaia_oop pikaia_oop module~abbott->pikaia_oop sort_arrays sort_arrays module~abbott->sort_arrays module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Firestone Abbott’s curve. Example of use Calls program~~test_abbott~~CallsGraph program~test_abbott test_abbott proc~abbott_param abbott_param program~test_abbott->proc~abbott_param read_surf read_surf program~test_abbott->read_surf get_unit get_unit proc~abbott_param->get_unit init pikaia_class%init proc~abbott_param->init moindres_carres_lineaire moindres_carres_lineaire proc~abbott_param->moindres_carres_lineaire proc~calc_moments calc_moments proc~abbott_param->proc~calc_moments run_gnuplot run_gnuplot proc~abbott_param->run_gnuplot solve pikaia_class%solve proc~abbott_param->solve sort_array2 sort_array2 proc~abbott_param->sort_array2 proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), allocatable, dimension(:,:) :: heights integer(kind=I4) :: nx integer(kind=I4) :: ny real(kind=R8), dimension(1:11) :: res type( SCALE_SURF ) :: scal_surf real(kind=R8), allocatable, dimension(:) :: vec_heights Source Code program test_abbott use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use surfile , only : read_surf , write_surf , SCALE_SURF use abbott , only : abbott_param implicit none real ( kind = R8 ), allocatable , dimension (:) :: vec_heights real ( kind = R8 ), allocatable , dimension (:,:) :: heights real ( kind = R8 ), dimension ( 1 : 11 ) :: res integer ( kind = I4 ) :: nx , ny type ( SCALE_SURF ) :: scal_surf call read_surf ( nom_fic = \"sur/test.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres allocate ( vec_heights ( 1 : nx * ny ) ) vec_heights ( 1 : nx * ny ) = reshape ( heights , [ nx * ny ] ) call abbott_param ( tab = vec_heights ( 1 : nx * ny ), & ! lg = nx * ny , & ! nom = 'out/test' , & ! curves = [. true ., . true ., . true .], & ! results = res ( 1 : 11 ), & ! omp = . true . ) ! write ( * , * ) 'smr1, iso 25178.................: ' , res ( 1 ) write ( * , * ) 'smr2, iso 25178.................: ' , res ( 2 ) write ( * , * ) 'spk , iso 25178.................: ' , res ( 3 ) write ( * , * ) 'svk , iso 25178.................: ' , res ( 4 ) write ( * , * ) 'off1, ordonnée de spk...........: ' , res ( 5 ) write ( * , * ) 'off2, ordonnée de svk...........: ' , res ( 6 ) write ( * , * ) 'sk  , iso 25178.................: ' , res ( 7 ) write ( * , * ) 'core slope..................... : ' , res ( 8 ) write ( * , * ) 'adjustment factor (tangent fit) : ' , res ( 9 ) write ( * , * ) 'coeffa_tan        (tangent fit) : ' , res ( 10 ) write ( * , * ) 'coeffb_tan        (tangent fit) : ' , res ( 11 ) write ( * , * ) write ( * , * ) 'NB: on a reduced Abbott curve, the tangent fit is not so good' // & ! ' because the beginning and the end of the data points are kept' // & ! ' making the curve too much sharp.' ! deallocate ( heights , vec_heights ) stop endprogram test_abbott","tags":"","loc":"program/test_abbott.html"},{"title":"test_asfc – TPGLIB","text":"Uses miscellaneous files asfc surfile data_arch program~~test_asfc~~UsesGraph program~test_asfc test_asfc data_arch data_arch program~test_asfc->data_arch files files program~test_asfc->files miscellaneous miscellaneous program~test_asfc->miscellaneous module~asfc asfc program~test_asfc->module~asfc surfile surfile program~test_asfc->surfile module~asfc->data_arch module~asfc->miscellaneous module~asfc->surfile bspline bspline module~asfc->bspline least_squares least_squares module~asfc->least_squares minpack minpack module~asfc->minpack module~stat_mom stat_mom module~asfc->module~stat_mom module~stat_mom->data_arch sort_arrays sort_arrays module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Asfc. Example of use Calls program~~test_asfc~~CallsGraph program~test_asfc test_asfc clean_scratch clean_scratch program~test_asfc->clean_scratch list_files list_files program~test_asfc->list_files proc~calcul_asfc_hermite calcul_asfc_hermite program~test_asfc->proc~calcul_asfc_hermite proc~indice_fractal indice_fractal program~test_asfc->proc~indice_fractal read_surf read_surf program~test_asfc->read_surf get_unit get_unit proc~calcul_asfc_hermite->get_unit lmder1 lmder1 proc~calcul_asfc_hermite->lmder1 omp_get_num_procs omp_get_num_procs proc~calcul_asfc_hermite->omp_get_num_procs proc~df_boltz df_boltz proc~calcul_asfc_hermite->proc~df_boltz proc~dnq_et_i dnq_et_i proc~calcul_asfc_hermite->proc~dnq_et_i proc~dnq_xi_i dnq_xi_i proc~calcul_asfc_hermite->proc~dnq_xi_i proc~f_boltz f_boltz proc~calcul_asfc_hermite->proc~f_boltz proc~init_beta_boltz init_beta_boltz proc~calcul_asfc_hermite->proc~init_beta_boltz proc~locate locate proc~calcul_asfc_hermite->proc~locate proc~locate2 locate2 proc~calcul_asfc_hermite->proc~locate2 proc~nq_i nq_i proc~calcul_asfc_hermite->proc~nq_i moindres_carres_lineaire moindres_carres_lineaire proc~indice_fractal->moindres_carres_lineaire proc~calc_moments calc_moments proc~indice_fractal->proc~calc_moments proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d proc~dn_i dn_i proc~dnq_et_i->proc~dn_i proc~n_i n_i proc~dnq_et_i->proc~n_i proc~dnq_xi_i->proc~dn_i proc~dnq_xi_i->proc~n_i proc~nq_i->proc~n_i Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=I4) :: i_g real(kind=R8), dimension(1:3) :: ind_frac result: indice fractal character(len=512), allocatable, dimension(:) :: list_sur character(len=512), allocatable, dimension(:) :: list_sur1 character(len=512), allocatable, dimension(:) :: list_sur2 integer(kind=I4) :: n1_g integer(kind=I4) :: n2_g integer(kind=I4) :: n_g integer(kind=I4) :: nx integer(kind=I4) :: ny real(kind=R8), dimension(1:2) :: res_asfc result: asfc, adjustment factor type( SCALE_SURF ) :: scal_surf object SCALE_SURF real(kind=R8), dimension(:,:), allocatable :: tab_surf height array Source Code program test_asfc use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use surfile , only : read_surf , SCALE_SURF use asfc , only : calcul_asfc_hermite , indice_fractal use files , only : list_files , clean_scratch implicit none type ( SCALE_SURF ) :: scal_surf !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension (:,:), allocatable :: tab_surf !! *height array* real ( kind = R8 ), dimension ( 1 : 2 ) :: res_asfc !! *result: asfc, adjustment factor* real ( kind = R8 ), dimension ( 1 : 3 ) :: ind_frac !! *result: indice fractal* character ( len = 512 ), allocatable , dimension (:) :: list_sur character ( len = 512 ), allocatable , dimension (:) :: list_sur1 character ( len = 512 ), allocatable , dimension (:) :: list_sur2 integer ( kind = I4 ) :: i_g , n_g , n1_g , n2_g , nx , ny call clean_scratch () call list_files ( dir = \"sur\" , list = list_sur1 , ext = \"sur\" ) call list_files ( dir = \"sur\" , list = list_sur2 , ext = \"SUR\" ) n1_g = ubound ( list_sur1 , 1 ) n2_g = ubound ( list_sur2 , 1 ) n_g = n1_g + n2_g allocate ( list_sur ( 1 : n_g ) ) list_sur ( 1 : n1_g ) = list_sur1 ( 1 : n1_g ) list_sur ( n1_g + 1 : n_g ) = list_sur2 ( 1 : n2_g ) do i_g = 1 , n_g write ( * , * ) '===============================================' write ( * , * ) trim ( list_sur ( i_g ) ) call read_surf ( nom_fic = trim ( list_sur ( i_g ) ), & ! IN mu = 0._R8 , & ! IN , OPT tab_s = tab_surf , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres call calcul_asfc_hermite ( tab_in = tab_surf , & ! scal = scal_surf , & ! asfc_res = res_asfc , & ! omp = . true .) ! call indice_fractal ( tab_in = tab_surf ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! indf = ind_frac ( 1 : 3 ) ) ! write ( * , * ) 'Asfc2 (asfc2 + correlation):             ' , res_asfc ( 1 : 2 ) write ( * , * ) 'Box counting (frac. ind. + correlation): ' , ind_frac ( 1 ), ind_frac ( 3 ) enddo deallocate ( list_sur , list_sur1 , list_sur2 ) endprogram test_asfc","tags":"","loc":"program/test_asfc.html"},{"title":"test_anisotropy – TPGLIB","text":"Uses miscellaneous anisotropy surfile data_arch fftw3 program~~test_anisotropy~~UsesGraph program~test_anisotropy test_anisotropy data_arch data_arch program~test_anisotropy->data_arch fftw3 fftw3 program~test_anisotropy->fftw3 miscellaneous miscellaneous program~test_anisotropy->miscellaneous module~anisotropy anisotropy program~test_anisotropy->module~anisotropy surfile surfile program~test_anisotropy->surfile module~anisotropy->data_arch module~anisotropy->fftw3 module~anisotropy->miscellaneous module~anisotropy->surfile module~filter filter module~anisotropy->module~filter module~stat_mom stat_mom module~anisotropy->module~stat_mom sort_arrays sort_arrays module~anisotropy->sort_arrays tchebychev tchebychev module~anisotropy->tchebychev module~filter->data_arch module~filter->fftw3 module~filter->surfile module~filter->module~stat_mom module~filter->sort_arrays module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Anisotropy detection. Example of use Calls program~~test_anisotropy~~CallsGraph program~test_anisotropy test_anisotropy apod apod program~test_anisotropy->apod end_fftw3 end_fftw3 program~test_anisotropy->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads program~test_anisotropy->fftw_plan_with_nthreads init_fftw3 init_fftw3 program~test_anisotropy->init_fftw3 init_scal init_scal program~test_anisotropy->init_scal omp_get_max_threads omp_get_max_threads program~test_anisotropy->omp_get_max_threads proc~correlation_parameters correlation_parameters program~test_anisotropy->proc~correlation_parameters proc~ellipse_acf ellipse_acf program~test_anisotropy->proc~ellipse_acf proc~fake_acv fake_acv program~test_anisotropy->proc~fake_acv proc~multiple_anisotropy multiple_anisotropy program~test_anisotropy->proc~multiple_anisotropy read_surf read_surf program~test_anisotropy->read_surf unit2IUf unit2IUf program~test_anisotropy->unit2IUf write_surf write_surf program~test_anisotropy->write_surf proc~correlation_parameters->proc~ellipse_acf least_squares_tcheby least_squares_tcheby proc~correlation_parameters->least_squares_tcheby proc~acv acv proc~correlation_parameters->proc~acv get_unit get_unit proc~ellipse_acf->get_unit omp_get_num_procs omp_get_num_procs proc~ellipse_acf->omp_get_num_procs sort_array2 sort_array2 proc~ellipse_acf->sort_array2 proc~multiple_anisotropy->init_scal proc~multiple_anisotropy->write_surf proc~fft_filter fft_filter proc~multiple_anisotropy->proc~fft_filter proc~simple_anisotropy simple_anisotropy proc~multiple_anisotropy->proc~simple_anisotropy proc~acv->apod proc~acv->init_scal proc~acv->write_surf calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acv->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acv->calc_fftw3_real_fwd proc~calc_moments calc_moments proc~acv->proc~calc_moments trans_corner2center trans_corner2center proc~acv->trans_corner2center proc~fft_filter->calc_fftw3_real_bwd proc~fft_filter->calc_fftw3_real_fwd extend extend proc~fft_filter->extend proc~gaussian_filter gaussian_filter proc~fft_filter->proc~gaussian_filter tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~fft_filter->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~fft_filter->tab_calc_fftw3_real_fwd proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), allocatable, dimension(:,:) :: array real(kind=R8), allocatable, dimension(:,:) :: array_tmp real(kind=R8) :: dx real(kind=R8) :: dy real(kind=R8), dimension(1:2) :: ech_param real(kind=R8), dimension(1:3) :: ell_param real(kind=R8) :: lx integer(kind=I4) :: n_th integer(kind=I4) :: nnx integer(kind=I4) :: nny integer(kind=I4), parameter :: nx = 800 integer(kind=I4) :: nx2 integer(kind=I4), parameter :: ny = 400 integer(kind=I4) :: ny2 real(kind=R8), dimension(1:8) :: param_acv real(kind=R8), dimension(1:9) :: param_ani type( SCALE_SURF ) :: scal_surf real(kind=R8), dimension(1:2) :: scale_xy Subroutines subroutine fake_acv (acv_array, long, larg, param, ech) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), allocatable, dimension(:,:) :: acv_array integer(kind=I4), intent(in) :: long integer(kind=I4), intent(in) :: larg real(kind=R8), intent(in), dimension(1:3) :: param real(kind=R8), intent(in), dimension(1:2) :: ech Source Code program test_anisotropy use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use surfile , only : init_scal , read_surf , write_surf , SCALE_SURF , unit2IUf use fftw3 use anisotropy !$ use omp_lib implicit none integer ( kind = I4 ), parameter :: nx = 800 , ny = 400 real ( kind = R8 ), allocatable , dimension (:,:) :: array , array_tmp real ( kind = R8 ), dimension ( 1 : 3 ) :: ell_param real ( kind = R8 ), dimension ( 1 : 2 ) :: ech_param real ( kind = R8 ), dimension ( 1 : 8 ) :: param_acv real ( kind = R8 ), dimension ( 1 : 9 ) :: param_ani real ( kind = R8 ), dimension ( 1 : 2 ) :: scale_xy real ( kind = R8 ) :: lx , dx , dy type ( SCALE_SURF ) :: scal_surf integer ( kind = I4 ) :: nnx , nny , n_th , nx2 , ny2 !----------------------------------------------------------------------------------------------------------------- call read_surf ( nom_fic = \"sur/test1.sur\" , & ! tab_s = array , & ! scal = scal_surf ) ! nnx = scal_surf % xres nny = scal_surf % yres scale_xy = [ scal_surf % dx * unit2IUf ( scal_surf % dx_unit ), & ! scal_surf % dy * unit2IUf ( scal_surf % dy_unit ) ] ! n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) nx2 = 2 * ( nint ( PAD_FFT * nnx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT * nny ) / 2 ) call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! call multiple_anisotropy ( tabin = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! scale_xy = scale_xy , & ! multi_fft = . false ., & ! vec_ani = param_ani ( 1 : 9 ) ) ! call end_fftw3 () write ( * , '(e12.4, T20, a)' ) param_ani ( 1 ) , 'bmp, maximum over [0,179°] of the peaks mean width' write ( * , '(e12.4, T20, a)' ) param_ani ( 2 ) , 'smp, minimum over [0,179°] of the peaks mean width' write ( * , '(e12.4, T20, a)' ) param_ani ( 3 ) , 'rmp, ratio bmp/smp' write ( * , '(e12.4, T20, a)' ) param_ani ( 4 ) , 'bml, maximum over [0,179°] of the path length' write ( * , '(e12.4, T20, a)' ) param_ani ( 5 ) , 'sml, minimum over [0,179°] of the path length' write ( * , '(e12.4, T20, a)' ) param_ani ( 6 ) , 'rml, ratio bml/sml' write ( * , '(e12.4, T20, a)' ) param_ani ( 7 ) , 'bms, maximum over [0,179°] of the standard deviation of slope' write ( * , '(e12.4, T20, a)' ) param_ani ( 8 ) , 'sms, minimum over [0,179°] of the standard deviation of slope' write ( * , '(e12.4, T20, a)' ) param_ani ( 9 ) , 'rms, ratio bms/sms' deallocate ( array ) !----------------------------------------------------------------------------------------------------------------- ell_param = [ 4 0.e-6_R8 , 1 0.e-6_R8 , 2 5._R8 ] ! big semi-axis, small semi-axis, angle (°) ech_param = [ 0.25e-6_R8 , 0.25e-6_R8 ] ! scale x (m/pix), scale_y (m/pix) ! domain is (800 * 0.25e-6) X (400 * 0.25e-6) = 200 µm X 100 µm call fake_acv ( acv_array = array , & ! long = nx , & ! larg = ny , & ! param = ell_param ( 1 : 3 ), & ! ech = ech_param ( 1 : 2 ) ) ! call init_scal ( scal = scal_surf , & ! nx = nx , & ! ny = ny , & ! lx = nx * ech_param ( 1 ), & ! ly = ny * ech_param ( 2 ), & ! unit_z = 'm ' ) ! call write_surf ( nom_fic = \"out/fake_acv.sur\" , & ! tab_s = array ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! call ellipse_acf ( tabin = array ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! p_acv = param_acv ( 1 : 8 ), & ! cut = 0.5_R8 , & ! scale_xy = ech_param ( 1 : 2 ), & ! omp = . true . ) ! write ( * , '(    a, T20, a)' ) '************' , '*******************************************************************' write ( * , '(e12.4, T20, a)' ) param_acv ( 1 ) , 'axe_a,                                ellipsis big axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 2 ) , 'axe_b,                                ellipsis small axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 3 ) , 'axe_a/axe_b                           another anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 4 ) , 'nint(angle/inc_a),                    main texture orientation' write ( * , '(e12.4, T20, a)' ) param_acv ( 5 ) , 'ray_pente,                            radius of greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 6 ) , 'max_pente,                            greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 7 ) , 'max_pente/min_pente                   slope anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 8 ) , 'highest curvature/smallest curvature, curvature anisotropy factor' deallocate ( array ) !----------------------------------------------------------------------------------------------------------------- allocate ( array ( 1 : nx , 1 : ny ) ) allocate ( array_tmp ( 1 : nx , 1 : ny ) ) array ( 1 : nx , 1 : ny ) = 1 call apod ( tab_in = array ( 1 : nx , 1 : ny ), & ! tab_out = array_tmp ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! type_apo = 'tuckey' ) ! call write_surf ( nom_fic = \"out/apod_tuckey.sur\" , & ! tab_s = array_tmp ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! call apod ( tab_in = array ( 1 : nx , 1 : ny ), & ! tab_out = array_tmp ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! type_apo = 'blackm' ) ! call write_surf ( nom_fic = \"out/apod_blackman.sur\" , & ! tab_s = array_tmp ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! call apod ( tab_in = array ( 1 : nx , 1 : ny ), & ! tab_out = array_tmp ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! type_apo = 'hann__' ) ! call write_surf ( nom_fic = \"out/apod_hann.sur\" , & ! tab_s = array_tmp ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! deallocate ( array , array_tmp ) !----------------------------------------------------------------------------------------------------------------- allocate ( array_tmp ( 1 : nx , 1 : ny ) ) call read_surf ( nom_fic = \"sur/verif_corr.sur\" , & ! tab_s = array , & ! scal = scal_surf ) ! nnx = scal_surf % xres nny = scal_surf % yres ! let suppose that the length along x is 100 µm lx = 10 0.e-6_R8 ; dx = lx / nnx ; dy = dx n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) nx2 = 2 * ( nint ( PAD_FFT * nnx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT * nny ) / 2 ) call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! ! results gwyddion : correlation length between 3.7 and 4.2 µm !                    no particular angle call correlation_parameters ( tab = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! res = param_acv ( 1 : 8 ), & ! cut = 0.5_R8 , & ! sub_plane = . true ., & ! scale_xy = [ dx , dy ], & ! omp = . true . ) ! write ( * , '(    a, T20, a)' ) '************' , '*******************************************************************' write ( * , '(e12.4, T20, a)' ) param_acv ( 1 ) , 'axe_a,                                ellipsis big axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 2 ) , 'axe_b,                                ellipsis small axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 3 ) , 'axe_a/axe_b                           another anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 4 ) , 'nint(angle/inc_a),                    main texture orientation' write ( * , '(e12.4, T20, a)' ) param_acv ( 5 ) , 'ray_pente,                            radius of greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 6 ) , 'max_pente,                            greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 7 ) , 'max_pente/min_pente                   slope anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 8 ) , 'highest curvature/smallest curvature, curvature anisotropy factor' call end_fftw3 () deallocate ( array ) stop contains subroutine fake_acv ( acv_array , long , larg , param , ech ) implicit none real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: acv_array integer ( kind = I4 ), intent ( in ) :: long , larg real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: param real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: ech integer ( kind = I4 ) :: i , j , ia , ib , i0 , j0 real ( kind = R8 ) :: a , b , ang , c , s , echx , echy allocate ( acv_array ( 1 : long , 1 : larg ) ) a = param ( 1 ) b = param ( 2 ) ang = param ( 3 ) echx = ech ( 1 ) echy = ech ( 2 ) ia = int ( a / echx ) ib = int ( b / echy ) i0 = long / 2 + 1 j0 = larg / 2 + 1 c = cos ( ang * PI_R8 / 180 ) s = sin ( ang * PI_R8 / 180 ) do j = 1 , larg do i = 1 , long acv_array ( i , j ) = exp ( log ( 1. / 2. ) * sqrt ( ( ( + c * ( i - i0 ) + s * ( j - j0 ) ) / ia ) ** 2 + & ! ( ( - s * ( i - i0 ) + c * ( j - j0 ) ) / ib ) ** 2 ) ) ! enddo enddo return endsubroutine fake_acv endprogram test_anisotropy","tags":"","loc":"program/test_anisotropy.html"},{"title":"test_grad_curv – TPGLIB","text":"Uses grad_curv program~~test_grad_curv~~UsesGraph program~test_grad_curv test_grad_curv module~grad_curv grad_curv program~test_grad_curv->module~grad_curv data_arch data_arch module~grad_curv->data_arch fftw3 fftw3 module~grad_curv->fftw3 module~filter filter module~grad_curv->module~filter sort_arrays sort_arrays module~grad_curv->sort_arrays surfile surfile module~grad_curv->surfile module~filter->data_arch module~filter->fftw3 module~filter->sort_arrays module~filter->surfile module~stat_mom stat_mom module~filter->module~stat_mom module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Surface gradients and curvatures. Example of use. Calls program~~test_grad_curv~~CallsGraph program~test_grad_curv test_grad_curv proc~test_label_surf_summits test_label_surf_summits program~test_grad_curv->proc~test_label_surf_summits proc~test_labelize_point test_labelize_point program~test_grad_curv->proc~test_labelize_point proc~test_peaks_and_pits_curvatures test_peaks_and_pits_curvatures program~test_grad_curv->proc~test_peaks_and_pits_curvatures init_scal init_scal proc~test_label_surf_summits->init_scal proc~label_surf_summits label_surf_summits proc~test_label_surf_summits->proc~label_surf_summits write_surf write_surf proc~test_label_surf_summits->write_surf proc~deriv_n deriv_N proc~test_labelize_point->proc~deriv_n proc~labelize_point labelize_point proc~test_labelize_point->proc~labelize_point selectcase selectcase proc~test_labelize_point->selectcase end_fftw3 end_fftw3 proc~test_peaks_and_pits_curvatures->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~test_peaks_and_pits_curvatures->fftw_plan_with_nthreads init_fftw3 init_fftw3 proc~test_peaks_and_pits_curvatures->init_fftw3 omp_get_max_threads omp_get_max_threads proc~test_peaks_and_pits_curvatures->omp_get_max_threads proc~curv2 curv2 proc~test_peaks_and_pits_curvatures->proc~curv2 proc~curvature curvature proc~test_peaks_and_pits_curvatures->proc~curvature proc~fft_filter fft_filter proc~test_peaks_and_pits_curvatures->proc~fft_filter proc~gauss_curv gauss_curv proc~test_peaks_and_pits_curvatures->proc~gauss_curv proc~gradient gradient proc~test_peaks_and_pits_curvatures->proc~gradient proc~peaks_and_pits_curvatures peaks_and_pits_curvatures proc~test_peaks_and_pits_curvatures->proc~peaks_and_pits_curvatures read_surf read_surf proc~test_peaks_and_pits_curvatures->read_surf unit2IUf unit2IUf proc~test_peaks_and_pits_curvatures->unit2IUf proc~test_peaks_and_pits_curvatures->write_surf proc~curvature->proc~gauss_curv proc~curvature->proc~gradient calc_fftw3_real_bwd calc_fftw3_real_bwd proc~fft_filter->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~fft_filter->calc_fftw3_real_fwd extend extend proc~fft_filter->extend proc~gaussian_filter gaussian_filter proc~fft_filter->proc~gaussian_filter tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~fft_filter->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~fft_filter->tab_calc_fftw3_real_fwd proc~gauss_curv->proc~gradient proc~label_surf_summits->proc~labelize_point proc~label_surf_summits->selectcase proc~gradient_corner gradient_corner proc~label_surf_summits->proc~gradient_corner proc~labelize_point->proc~deriv_n proc~peaks_and_pits_curvatures->proc~curvature proc~peaks_and_pits_curvatures->proc~label_surf_summits sort_array2 sort_array2 proc~peaks_and_pits_curvatures->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_grad_curv use grad_curv , only : test_labelize_point , test_label_surf_summits , test_peaks_and_pits_curvatures implicit none call test_label_surf_summits () call test_labelize_point () call test_peaks_and_pits_curvatures () stop !~  expected output: !~            9          10           9 !~  numerical h      :    1.8512999999999997       ; theoretical h      :    1.8512999999999999 !~  numerical dhdx   :  -0.44879999999999987       ; theoretical dhdx   :  -0.44879999999999992 !~  numerical dhdy   :   -1.3200000000000001       ; theoretical dhdy   :   -1.3200000000000001 !~  numerical d2hdx2 :    1.7952000000000008       ; theoretical d2hdx2 :    1.7951999999999999 !~  numerical d2hdy2 :   -4.1249999999999991       ; theoretical d2hdy2 :   -4.1250000000000000 !~  numerical d2hdxdy:   0.31999999999999984       ; theoretical d2hdxdy:   0.31999999999999995 !~  theoretical xx0:  -0.10000000000000001      numerical xx0:   -9.9999999744180723E-002 !~  theoretical yy0:   0.20000000000000001      numerical yy0:   0.19999999780599384 !~  theoretical point: S numerical point: S !~  nx, ny =         1551        1555 !~  dx, dy =    1.2899998437499999E-007   1.2899998437499999E-007 !~  S_param_grad:    9.1818702650203546E-002 !~  S_param_curv:    32734.346139266941 !~  peak_curv:   -15965527969.430788 !~  pits_curv:    66825282090.434196 endprogram test_grad_curv","tags":"","loc":"program/test_grad_curv.html"},{"title":"test_morpho – TPGLIB","text":"Uses miscellaneous sort_arrays morpho surfile stat_mom data_arch program~~test_morpho~~UsesGraph program~test_morpho test_morpho data_arch data_arch program~test_morpho->data_arch miscellaneous miscellaneous program~test_morpho->miscellaneous module~morpho morpho program~test_morpho->module~morpho module~stat_mom stat_mom program~test_morpho->module~stat_mom sort_arrays sort_arrays program~test_morpho->sort_arrays surfile surfile program~test_morpho->surfile module~morpho->data_arch module~morpho->miscellaneous module~morpho->module~stat_mom module~stat_mom->data_arch module~stat_mom->sort_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Morphological operations.  Example of use. Calls program~~test_morpho~~CallsGraph program~test_morpho test_morpho get_unit get_unit program~test_morpho->get_unit init_scal init_scal program~test_morpho->init_scal proc~calc_moments calc_moments program~test_morpho->proc~calc_moments proc~calcul_normales calcul_normales program~test_morpho->proc~calcul_normales proc~count_cell count_cell program~test_morpho->proc~count_cell proc~def_masque def_masque program~test_morpho->proc~def_masque proc~erode_dilate erode_dilate program~test_morpho->proc~erode_dilate proc~plane plane program~test_morpho->proc~plane proc~surf_area surf_area program~test_morpho->proc~surf_area read_surf read_surf program~test_morpho->read_surf sort_array2 sort_array2 program~test_morpho->sort_array2 write_surf write_surf program~test_morpho->write_surf proc~calc_moments_1d calc_moments_1D proc~calc_moments->proc~calc_moments_1d proc~calcul_normales->get_unit proc~calc_median calc_median proc~count_cell->proc~calc_median proc~flood flood proc~count_cell->proc~flood proc~calc_median->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8) :: angle real(kind=R8) :: area real(kind=R8), allocatable, dimension(:,:) :: array real(kind=R8) :: c1 real(kind=R8) :: c2 real(kind=R8) :: cp real(kind=R8) :: dx real(kind=R8) :: dy integer(kind=I4) :: i integer(kind=I4) :: ii integer(kind=I4), allocatable, dimension(:,:) :: imask integer(kind=I4) :: j integer(kind=I4) :: jj integer(kind=I4) :: k real(kind=R8), allocatable, dimension(:,:) :: mask real(kind=R8) :: maxtab real(kind=R8) :: median_size real(kind=R8) :: mintab type( moment_stat ) :: mom integer(kind=I4) :: nb_cells integer(kind=I4) :: ni integer(kind=I4) :: nj integer(kind=I4) :: nnx integer(kind=I4) :: nny real(kind=R8) :: res_hori type( SCALE_SURF ) :: scal_surf real(kind=R8) :: sp real(kind=R8) :: t real(kind=R8) :: topo integer(kind=I4) :: ua real(kind=R8), allocatable, dimension(:) :: vec real(kind=R8), allocatable, dimension(:) :: vec_tmp Functions function plane (a, b, c, x, y) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: a real(kind=R8), intent(in) :: b real(kind=R8), intent(in) :: c real(kind=R8), intent(in) :: x real(kind=R8), intent(in) :: y Return Value real(kind=r8) Source Code program test_morpho use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use surfile , only : init_scal , read_surf , write_surf , SCALE_SURF use sort_arrays , only : sort_array2 use stat_mom , only : calc_moments , moment_stat use morpho , only : calcul_normales , surf_area , count_cell , erode_dilate , def_masque implicit none real ( kind = R8 ), allocatable , dimension (:,:) :: mask , array real ( kind = R8 ), allocatable , dimension (:) :: vec , vec_tmp integer ( kind = I4 ), allocatable , dimension (:,:) :: imask type ( SCALE_SURF ) :: scal_surf integer ( kind = I4 ) :: i , nnx , nny , nb_cells real ( kind = R8 ) :: median_size , c1 , c2 , topo , mintab , maxtab integer ( kind = I4 ) :: ni , nj , ii , jj , j , k , ua real ( kind = R8 ) :: angle , dx , dy , t , cp , sp , res_hori , area type ( moment_stat ) :: mom !---------------------------------------------------------------------------------- !---------- Returns the number of cells of a given mask --------------------------- !---------------------------------------------------------------------------------- call read_surf ( nom_fic = \"sur/mask.sur\" , & ! tab_s = mask , & ! scal = scal_surf ) ! nnx = scal_surf % xres nny = scal_surf % yres allocate ( imask ( 1 : nnx , 1 : nny ) ) imask ( 1 : nnx , 1 : nny ) = nint ( mask ( 1 : nnx , 1 : nny ) ) call count_cell ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! nbr_cell = nb_cells , & ! med_cell = median_size ) ! call write_surf ( nom_fic = \"out/res_count_cell.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! write ( * , '(a, T25, I3, a, E12.4, a)' ) 'initial mask:' , nb_cells , ' cells, ' , median_size , ' % surface' !---------------------------------------------------------------------------------- !---- Returns the number of cells of a given mask after erosion ------------------- !---------------------------------------------------------------------------------- imask ( 1 : nnx , 1 : nny ) = nint ( mask ( 1 : nnx , 1 : nny ) ) call erode_dilate ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! val = 6 , & ! act = 'erode' ) ! call count_cell ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! nbr_cell = nb_cells , & ! med_cell = median_size ) ! call write_surf ( nom_fic = \"out/res_count_cell_erode.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! write ( * , '(a, T25, I3, a, E12.4, a)' ) 'mask after erode:' , nb_cells , ' cells, ' , median_size , ' % surface' !---------------------------------------------------------------------------------- !----- Returns the number of cells of a given mask after erosion and dilation ----- !---------------------------------------------------------------------------------- where ( imask ( 1 : nnx , 1 : nny ) >= 1 ) imask ( 1 : nnx , 1 : nny ) = 1 call erode_dilate ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! val = 6 , & ! act = 'dilat' ) ! call count_cell ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! nbr_cell = nb_cells , & ! med_cell = median_size ) ! call write_surf ( nom_fic = \"out/res_count_cell_erode_dilat.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! write ( * , '(a, T25, I3, a, E12.4, a)' ) 'mask erode + dilate:' , nb_cells , ' cells, ' , median_size , ' % surface' write ( * , * ) '--------------------------------------------------------' !---------------------------------------------------------------------------------- !---------- Returns the % age of heights above c2, once c1 heights are removed ---- !---------------------------------------------------------------------------------- allocate ( array ( 1 : nnx , 1 : nny ) ) allocate ( vec ( 1 : nnx * nny ), vec_tmp ( 1 : nnx * nny ) ) ! thresholds c1 = 0.15_R8 c2 = 0.85_R8 ! surface made of increasing integers vec ( 1 : nnx * nny ) = [ ( i , i = 1 , nnx * nny ) ] mintab = minval ( vec ( 1 : nnx * nny ) ) maxtab = maxval ( vec ( 1 : nnx * nny ) ) ! heights rescaled between 0 and 1 vec_tmp ( 1 : nnx * nny ) = ( vec ( 1 : nnx * nny ) - mintab ) / ( maxtab - mintab ) ! shuffle heights call random_number ( vec ( 1 : nnx * nny ) ) call sort_array2 ( tab_inout = vec ( 1 : nnx * nny ), & ! tab1 = vec_tmp ( 1 : nnx * nny ), & ! n = nnx * nny ) ! array ( 1 : nnx , 1 : nny ) = reshape ( vec_tmp ( 1 : nnx * nny ), [ nnx , nny ] ) ! mask heights above c2, when heights below c1 are ignored call def_masque ( msk = imask ( 1 : nnx , 1 : nny ), & ! tab = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! crit1 = c1 , & ! crit2 = c2 , & ! top = topo ) ! call write_surf ( nom_fic = \"out/mask_after_threshold.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! ! topo is the fraction of heights that are involved write ( * , * ) 'percentage of heights abobe 85%, without the first 15%: ' , topo ! = 100. - 100 * ( c1 + c2 * (1. - c1) ) write ( * , * ) '--------------------------------------------------------' deallocate ( array , mask , imask , vec , vec_tmp ) !---------------------------------------------------------------------------------- !--------- Returns the % age of surface nearly horizontal ------------------------- !---------------------------------------------------------------------------------- nnx = 512 ; nny = 512 allocate ( array ( 1 : nnx , 1 : nny ) ) allocate ( vec ( 1 : nnx * nny ) ) ! the domain is divided into 4x4 patches ni = 512 / 4 nj = 512 / 4 ! cone half angle angle = 5._R8 ! lag along x and y dx = 1.e-7_R8 dy = 1.e-7_R8 k = 0 do i = 1 , 4 do j = 1 , 4 k = k + 1 ! subdomain number ! the subdomain is a plane of equation: z = -a.x -b.y -c ! the normal coordinates are (-a, -b, +1)/sqrt(a**2 + b**2 + 1) ! and the scalar product with \\vec{k} is 1/sqrt(a**2 + b**2 + 1) ! which is also cos(\\theta). ! Therefore a**2 + b**2 = tan(\\theta)**2, so if a = cos(\\phi).tan(\\theta) ! b = sin(\\phi).tan(\\theta), the relationship is satisfied (whatever \\phi). ! With \\theta = k * 0.11 * angle, 9 subdomains are concerned. t = tan ( k * 0.11 * angle * PI_R8 / 180 ) call random_number ( cp ) cp = 2 * ( cp - 0.5 ) call random_number ( sp ) if ( sp > 0.5_R8 ) then sp = + sqrt ( 1._R8 - cp ** 2 ) else sp = - sqrt ( 1._R8 - cp ** 2 ) endif do ii = ( i - 1 ) * ni + 1 , i * ni do jj = ( j - 1 ) * nj + 1 , j * nj array ( ii , jj ) = plane ( a = cp * t , & ! b = sp * t , & ! c = 0._R8 , & ! x = ii * dx , & ! y = jj * dy ) ! enddo enddo enddo enddo call calc_moments ( tab = reshape ( array ( 1 : nnx , 1 : nny ), [ nnx * nny ] ), & ! mx = mom , & ! nb_mom = 2 ) ! array ( 1 : nnx , 1 : nny ) = ( array ( 1 : nnx , 1 : nny ) - mom % mu ) / mom % si call init_scal ( scal = scal_surf , & ! nx = nnx , & ! ny = nny , & ! lx = nnx * dx , & ! ly = nny * dy , & ! unit_z = 'm ' ) ! call write_surf ( nom_fic = \"out/hori.sur\" , & ! tab_s = array ( 1 : nnx , 1 : nny ), & ! scal = scal_surf ) ! call calcul_normales ( tab_in = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! scale_xyz = [ dx , dy , mom % si ], & ! cone_angle = angle , & ! print_mask = . true ., & ! hori = res_hori ) ! call surf_area ( tab_in = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! scale_xyz = [ dx , dy , mom % si ], & ! aire = area ) ! call get_unit ( ua ) open ( unit = ua , file = \"out/mask_angle.txt\" ) read ( ua , * ) ( vec ( i ), i = 1 , nnx * nny ) close ( ua ) call write_surf ( nom_fic = \"out/mask_hori.sur\" , & ! tab_s = reshape ( vec ( 1 : nnx * nny ), [ nnx , nny ] ), & ! scal = scal_surf ) ! write ( * , * ) 'Percentage of nearly horizontal surface (+/- 5°): ' , res_hori write ( * , * ) 'Relativea area minus 1 and z scale:               ' , area , mom % si deallocate ( array , vec ) contains real ( kind = R8 ) function plane ( a , b , c , x , y ) implicit none real ( kind = R8 ), intent ( in ) :: a , b , c , x , y plane = a * x + b * y + c return endfunction plane endprogram test_morpho","tags":"","loc":"program/test_morpho.html"},{"title":"mod_stat_mom.f90 – TPGLIB","text":"Files dependent on this one sourcefile~~mod_stat_mom.f90~~AfferentGraph sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_abbott.f90 mod_abbott.f90 sourcefile~mod_abbott.f90->sourcefile~mod_stat_mom.f90 sourcefile~mod_anisotropy.f90 mod_anisotropy.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_stat_mom.f90 sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_filter.f90 sourcefile~mod_asfc.f90 mod_asfc.f90 sourcefile~mod_asfc.f90->sourcefile~mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 sourcefile~mod_morpho.f90 mod_morpho.f90 sourcefile~mod_morpho.f90->sourcefile~mod_stat_mom.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_stat_mom.f90 sourcefile~prg.f90~7 prg.f90 sourcefile~prg.f90~7->sourcefile~mod_stat_mom.f90 sourcefile~prg.f90~7->sourcefile~mod_morpho.f90 sourcefile~mod_grad_curv.f90 mod_grad_curv.f90 sourcefile~mod_grad_curv.f90->sourcefile~mod_filter.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_filter.f90 sourcefile~prg.f90~3 prg.f90 sourcefile~prg.f90~3->sourcefile~mod_abbott.f90 sourcefile~prg.f90~4 prg.f90 sourcefile~prg.f90~4->sourcefile~mod_asfc.f90 sourcefile~prg.f90~5 prg.f90 sourcefile~prg.f90~5->sourcefile~mod_anisotropy.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_grad_curv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: may, 03 2019 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Routines to calculate statistical moments, and some utilities** !<  </span> module stat_mom use data_arch , only : I4 , R8 , HIG_R8 use sort_arrays , only : sort_array2 implicit none private type moment_stat !! statistical moments real ( kind = R8 ) :: mu !! *mean* real ( kind = R8 ) :: va !! *variance* real ( kind = R8 ) :: si !! *standard deviation* real ( kind = R8 ) :: Sk !! *skewness* real ( kind = R8 ) :: Ku !! *kurtosis* real ( kind = R8 ) :: Ss !! *fifth moment* real ( kind = R8 ) :: Kk !! *sixth moment* endtype moment_stat public :: moment_stat , calc_moments , calc_median , rnorm_vec , rnorm , scramble , random_normal contains subroutine scramble ( tab , lg ) !================================================================================================ !! scramble a vector of reals !------------------------------------------------------------------------------------------------ implicit none integer ( kind = i4 ), intent ( in ) :: lg real ( kind = r8 ) , intent ( inout ), dimension ( 1 : lg ) :: tab real ( kind = r8 ), dimension ( 1 : lg ) :: tmp integer ( kind = i4 ) :: i call random_number ( harvest = tmp ( 1 : lg ) ) call sort_array2 ( tab_inout = tmp ( 1 : lg ), & ! tab1 = tab ( 1 : lg ), n = lg ) ! return endsubroutine scramble function random_normal () implicit none !================================================================================================ !< @note !< !< Adapted from the following fortran 77 code !<      algorithm 712, collected algorithms from acm. !<      this work published in transactions on mathematical software, !<      vol. 18, no. 4, december, 1992, pp. 434-435. !< !<  + The function random_normal() returns a normally distributed pseudo-random !<     number with zero mean and unit variance. !<  + The algorithm uses the ratio of uniforms method of a.j. kinderman !<    and j.f. monahan augmented with quadratic bounding curves. !< !<     Author: !< !<     + Alan Miller !<     + csiro division of mathematical & information sciences !<     + private bag 10, clayton south mdc !<     + clayton 3169, victoria, australia !< !< @endnote !------------------------------------------------------------------------------------------------ real ( kind = r8 ) :: random_normal real ( kind = r8 ) :: s , t , a , b , r1 , r2 , u , v , x , y , q s = 0.449871_r8 t = - 0.386595_r8 a = 0.19600_r8 b = 0.25472_r8 r1 = 0.27597_r8 r2 = 0.27846_r8 !     generate p = (u,v) uniform in rectangle enclosing acceptance region do call random_number ( u ) call random_number ( v ) v = 1.7156 * ( v - 0.5_r8 ) !     evaluate the quadratic form x = u - s y = abs ( v ) - t q = x ** 2 + y * ( a * y - b * x ) !     accept p if inside inner ellipse if ( q < r1 ) exit !     reject p if outside outer ellipse if ( q > r2 ) cycle !     reject p if outside acceptance region if ( v ** 2 < - 4.0 * log ( u ) * u ** 2 ) exit enddo !     return ratio of p's coordinates as the normal deviate random_normal = v / u return endfunction random_normal subroutine calc_moments ( tab , mask , mx , nb_mom ) !================================================================================================ !< @note Function to calculate the statistical moments of an array with mask, of shape dim. 1 or 2 !< !< \\begin{align*} !<     mu &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}\\eta_{i,j} \\\\ !<     va &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}(\\eta_{i,j}-\\mu)&#94;2 \\\\ !<     Sk &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}\\left(\\frac{\\eta_{i,j}-\\mu}{\\sigma}\\right)&#94;3 \\\\ !<     Ku &= \\frac{1}{n&#94;2}\\sum_{i,j=1}&#94;{n}\\left(\\frac{\\eta_{i,j}-\\mu}{\\sigma}\\right)&#94;4 !< \\end{align*} !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_mom !! *number of desired moments* real ( kind = R8 ), intent ( in ), dimension (..) :: tab !! *1D or 2D array* logical ( kind = I4 ), intent ( in ), dimension (..), optional :: mask !! *1D or 2D mask* type ( moment_stat ), intent ( out ) :: mx !! [[moment_stat]] *result* integer ( kind = I4 ) :: size_tab real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp logical ( kind = I4 ), allocatable , dimension (:) :: msk_tmp select rank ( tab ) rank ( 1 ) if ( present ( mask ) ) then select rank ( mask ) rank ( 1 ) call calc_moments_1D ( tab , mask , mx , nb_mom ) rank default stop \"bad rank in mask 'calc_moments'\" endselect else call calc_moments_1D ( tab = tab , mx = mx , nb_mom = nb_mom ) endif rank ( 2 ) size_tab = product ( shape ( tab ) ) allocate ( tab_tmp ( 1 : size_tab ) ) tab_tmp = reshape ( tab , [ size_tab ] ) if ( present ( mask ) ) then allocate ( msk_tmp ( 1 : size_tab ) ) select rank ( mask ) rank ( 2 ) msk_tmp = reshape ( mask , [ size_tab ] ) call calc_moments_1D ( tab_tmp , msk_tmp , mx , nb_mom ) deallocate ( msk_tmp ) rank default stop \"bad rank in mask 'calc_moments'\" endselect else call calc_moments_1D ( tab = tab_tmp , mx = mx , nb_mom = nb_mom ) endif deallocate ( tab_tmp ) rank default stop \"bad rank in 'calc_moments'\" endselect return endsubroutine calc_moments subroutine calc_moments_1D ( tab , mask , mx , nb_mom ) !================================================================================================ !! Function to calculate the statistical moments of a 1D array with mask, see [[calc_moments]] !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_mom !! *number of desired moments* real ( kind = R8 ), intent ( in ), dimension (:) :: tab !! *1D array* logical ( kind = I4 ), intent ( in ), dimension (:), optional :: mask !! *1D mask* type ( moment_stat ), intent ( out ) :: mx !! [[moment_stat]] *result* integer ( kind = I4 ) :: lg , nz integer ( kind = I4 ) :: i , ii real ( kind = R8 ) :: tmp real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp lg = size ( tab ) nz = lg if ( present ( mask ) ) then nz = count ( mask ) allocate ( tab_tmp ( 1 : nz ) ) ii = 0 do i = 1 , lg if ( mask ( i ) ) then ii = ii + 1 tab_tmp ( ii ) = tab ( i ) endif enddo if ( ii /= nz ) stop 'error calc_moments' else tab_tmp = tab endif mx % mu = 0 mx % si = 0 mx % va = 0 mx % Sk = 0 mx % Ku = 0 mx % Ss = 0 mx % Kk = 0 do i = 1 , nz mx % mu = mx % mu + tab_tmp ( i ) / nz enddo if ( nb_mom == 1 ) return do i = 1 , nz mx % va = mx % va + ( ( tab_tmp ( i ) - mx % mu ) ** 2 ) / nz enddo mx % si = sqrt ( mx % va ) if ( nb_mom == 2 ) return ! don't go further if ( mx % si < 1.e-15_R8 ) then ! if the standard deviation is too small, quit stop 'calc_moments, std too small' endif do i = 1 , nz tmp = ( tab_tmp ( i ) - mx % mu ) / mx % si mx % Sk = mx % Sk + ( tmp ** 3 ) / nz mx % Ku = mx % Ku + ( tmp ** 4 ) / nz enddo if ( nb_mom == 4 ) return do i = 1 , nz tmp = ( tab_tmp ( i ) - mx % mu ) / mx % si mx % Ss = mx % Ss + ( tmp ** 5 ) / nz mx % Kk = mx % Kk + ( tmp ** 6 ) / nz enddo deallocate ( tab_tmp ) return endsubroutine calc_moments_1D subroutine calc_median ( tab , mask , md ) !================================================================================================ !! Function to calculate the median value of a series. !! !! + Input array containing the values for which the median is to be calculated !! + Optional mask to include/exclude certain values from the array !! + Output: the calculated median value !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:) :: tab !! *series 1D array* logical ( kind = I4 ), intent ( in ), dimension (:), optional :: mask !! *mask* real ( kind = R8 ), intent ( out ) :: md !! *result: series median value* integer ( kind = I4 ) :: lg , nz ! lg: size of the tab array; nz: number of elements to consider integer ( kind = I4 ) :: i , ii ! i: loop counter; ii: counter for tab_tmp real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp ! Temporary array to store filtered values md = 0._R8 ! Initialize the median value to 0 lg = size ( tab ) ! Get the size of the input array nz = lg ! Initialize the number of elements to lg if ( present ( mask ) ) then ! Check if a mask is provided nz = count ( mask ) ! Count the number of true elements in the mask allocate ( tab_tmp ( 1 : nz ) ) ! Allocate memory for the temporary array based on the number of elements to consider ii = 0 ! Initialize the counter for tab_tmp do i = 1 , lg ! Loop through each element of the input array if ( mask ( i ) ) then ! If the element is included in the mask ii = ii + 1 ! Increment the counter tab_tmp ( ii ) = tab ( i ) ! Copy the corresponding value into the temporary array endif enddo if ( ii /= nz ) stop 'error calc_median' ! Check if the number of copied elements matches nz; if not, stop the program else ! If no mask is provided tab_tmp = tab ! Copy the input array into tab_tmp endif if ( nz == 1 ) then ! If only one element is present md = tab_tmp ( 1 ) ! The median is the single element return ! Exit the subroutine endif if ( nz == 2 ) then ! If two elements are present md = 0.5_R8 * ( tab_tmp ( 1 ) + tab_tmp ( 2 )) ! The median is the average of the two elements return ! Exit the subroutine endif call sort_array2 ( tab_inout = tab_tmp ( 1 : nz ), n = nz ) ! Call a subroutine to sort the temporary array if ( mod ( nz , 2 ) == 0 ) then ! Check if the number of elements is even md = 0.5_R8 * ( tab_tmp ( nz / 2 ) + tab_tmp ( nz / 2 + 1 ) ) ! The median is the average of the two middle elements else ! If the number of elements is odd md = tab_tmp ( ( nz - 1 ) / 2 ) ! The median is the middle element endif deallocate ( tab_tmp ) ! Free the allocated memory for tab_tmp return ! Exit the subroutine endsubroutine calc_median function rnorm_vec ( n , mu , sigma ) result ( variates ) !================================================================================================ !! Vector of reals that follow a normal law !! !! [source](https://fortran-lang.discourse.group/t/normal-random-number-generator/3724/2) !! !! authors: Beliavsky, Miller !------------------------------------------------------------------------------------------------ integer ( kind = I4 ), intent ( in ) :: n !! *vector size* real ( kind = R8 ), intent ( in ), optional :: mu !! *distribution mean* real ( kind = R8 ), intent ( in ) , optional :: sigma !! *distribution std* real ( kind = R8 ), dimension ( 1 : n ) :: variates !! *output vector* integer ( kind = I4 ) :: i do i = 1 , n variates ( i ) = rnorm () enddo if ( present ( sigma ) ) variates = sigma * variates if ( present ( mu ) ) variates = variates + mu return endfunction rnorm_vec function rnorm () result ( fn_val ) !================================================================================================ !! Generate a random normal deviate using the polar method. !! !! *reference*: marsaglia,g. & bray,t.a. 'a convenient method for generating !!              normal variables', siam rev., vol.6, 260-264, 1964. !! !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ) :: fn_val real ( kind = R8 ) :: u , sum real ( kind = R8 ), save :: v , sln logical ( kind = I4 ), save :: second = . false . real ( kind = R8 ), parameter :: one = 1.0_R8 , vsmall = tiny ( one ) if ( second ) then ! if second, use the second random number generated on last call second = . false . fn_val = v * sln else ! first call; generate a pair of random normals second = . true . do call random_number ( u ) call random_number ( v ) u = scale ( u , 1 ) - one v = scale ( v , 1 ) - one sum = u * u + v * v + vsmall ! vsmall added to prevent log(zero) / zero if ( sum < one ) exit enddo sln = sqrt ( - scale ( log ( sum ), 1 ) / sum ) fn_val = u * sln endif return endfunction rnorm endmodule stat_mom","tags":"","loc":"sourcefile/mod_stat_mom.f90.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~~EfferentGraph sourcefile~prg.f90 prg.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~prg.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: may, 03 2019 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Routines to calculate statistical moments. Example of use.** !<  </span> program test_stat use data_arch , only : I4 , R8 , PI_R8 use stat_mom implicit none real ( kind = R8 ), allocatable , dimension (:) :: array logical ( kind = I4 ), allocatable , dimension (:) :: array_mask real ( kind = R8 ), allocatable , dimension (:,:) :: array2D logical ( kind = I4 ), allocatable , dimension (:,:) :: array_mask2D real ( kind = R8 ), dimension ( 1 : 6 ) :: results integer ( kind = I4 ), parameter :: rn = 1e3 integer ( kind = I4 ), parameter :: n = rn ** 2 type ( moment_stat ) :: mom integer ( kind = I4 ) :: i real ( kind = R8 ) :: x , median real ( kind = R8 ), allocatable , dimension (:) :: vx real ( kind = R8 ), parameter :: mu = 2.0_R8 , sigma = 3.0_R8 integer ( kind = I4 ), parameter :: nn = 1e7 integer ( kind = I4 ) :: ipow , iter allocate ( array ( 1 : n ) ) allocate ( array_mask ( 1 : n ) ) allocate ( array2D ( 1 : rn , 1 : rn ) ) allocate ( array_mask2D ( 1 : rn , 1 : rn ) ) array_mask = . false . do i = 0 , n - 1 x = real ( i , kind = R8 ) / ( n - 1 ) array ( i + 1 ) = sin ( 4 * PI_R8 * x ) * exp ( - 5 * x ) + x ** 2 if ( mod ( i , 2 ) == 0 ) array_mask ( i + 1 ) = . True . enddo array2D = reshape ( array ( 1 : n ), [ rn , rn ] ) array_mask2D = reshape ( array_mask ( 1 : n ), [ rn , rn ] ) !============================================================================== 1D WITH MASK call calc_moments ( tab = array , mask = array_mask , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , mask = array_mask , md = median ) results = [ 0.4015711287531725 , 0.08020113698321299 , 0.28319805257666053 , 0.07977645748158539 , 2.1330678728336125 , 0.42620050599180814 ] ! python !         [ 0.40157112875317|66, 0.08020113698321|186, 0.2831980525766|5853, 0.0797764574815|4369, 2.1330678728336|414, 0.42620050599180814 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median !============================================================================== 1D NO MASK call calc_moments ( tab = array , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , md = median ) results = [ 0.4015716287568354 , 0.08020123540993489 , 0.28319822635379427 , 0.07977715735614675 , 2.1330700214753766 , 0.42620146392518804 ] ! python !         [ 0.4015716287568|2495, 0.08020123540993|2986,  0.28319822635379|088,  0.079777157356|279285, 2.133070021475|4486, 0.426201463925188|10 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With NO mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median !============================================================================== 2D WITH MASK call calc_moments ( tab = array2D , mask = array_mask2D , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , mask = array_mask , md = median ) results = [ 0.4015711287531725 , 0.08020113698321299 , 0.28319805257666053 , 0.07977645748158539 , 2.1330678728336125 , 0.42620050599180814 ] ! python !         [ 0.40157112875317|66, 0.08020113698321|186, 0.2831980525766|5853, 0.0797764574815|4369, 2.1330678728336|414, 0.42620050599180814 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median !============================================================================== 2D NO MASK call calc_moments ( tab = array2D , mx = mom , nb_mom = 4 ) call calc_median ( tab = array , md = median ) results = [ 0.4015716287568354 , 0.08020123540993489 , 0.28319822635379427 , 0.07977715735614675 , 2.1330700214753766 , 0.42620146392518804 ] ! python !         [ 0.4015716287568|2495, 0.08020123540993|2986,  0.28319822635379|088,  0.079777157356|279285, 2.133070021475|4486, 0.426201463925188|10 ] ! fortran write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'With NO mask :' write ( * , * ) 'sum of abs error: ' , abs ( mom % mu - results ( 1 )) + & ! abs ( mom % va - results ( 2 )) + & ! abs ( mom % si - results ( 3 )) + & ! abs ( mom % Sk - results ( 4 )) + & ! abs ( mom % Ku - results ( 5 )) + & ! abs ( median - results ( 6 )) ! write ( * , * ) 'detail: ' , mom % mu , mom % va , mom % si , mom % Sk , mom % Ku , median deallocate ( array , array_mask , array2D , array_mask2D ) !============================================================================== TEST RND NORM call random_seed () allocate ( vx ( 1 : nn ) ) write ( * , * ) '-----------------------------------------------------------------' write ( * , * ) 'Test random normal' write ( * , \"(*(a8))\" ) \"n\" , \"mu\" , \"sigma\" write ( * , \"(i8,2f8.4)\" ) nn , mu , sigma write ( * , \"(/,'central moments',/,*(i10))\" ) ( ipow , ipow = 1 , 4 ) do iter = 1 , 5 vx = rnorm_vec ( nn , mu , sigma ) vx = vx - sum ( vx ) / nn write ( * , \"(*(f10.4))\" ) ( sum ( vx ** ipow ) / nn , ipow = 1 , 4 ) enddo write ( * , * ) \"theoretical\" write ( * , \"(*(f10.4))\" ) 0.0_R8 , sigma ** 2 , 0.0_R8 , 3 * sigma ** 4 deallocate ( vx ) stop endprogram test_stat","tags":"","loc":"sourcefile/prg.f90.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~2~~EfferentGraph sourcefile~prg.f90~2 prg.f90 sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~prg.f90~2->sourcefile~mod_filter.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_smooth use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use surfile , only : read_surf , write_surf , init_scal , SCALE_SURF , unit2IUf use filter , only : median_smooth , median_filter , soften , morpho_filter , fft_filter , PAD_FFT_FILTER use fftw3 , only : fftw_plan_with_nthreads , init_fftw3 , end_fftw3 , extend !$ use omp_lib implicit none real ( kind = R8 ), allocatable , dimension (:,:) :: heights , heights_out , heights_copy , mask , ext_heights real ( kind = R8 ) :: dx , dy , dz , fft_cutoff , pad integer ( kind = I4 ) :: nx , ny , nx2 , ny2 , n_th type ( SCALE_SURF ) :: scal_surf , scal_mask !========================================================================= padding / windowing call read_surf ( nom_fic = \"sur/AB-Zinv-ART-8-21-200x200.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres pad = 1.5 !PAD_FFT_FILTER nx2 = 2 * ( nint ( pad * nx ) / 2 ) ny2 = 2 * ( nint ( pad * ny ) / 2 ) allocate ( ext_heights ( 1 : nx2 , 1 : ny2 ) ) call extend ( tab_in = heights ( 1 : nx , 1 : ny ), & ! tab_out = ext_heights ( 1 : nx2 , 1 : ny2 ), & ! nx = nx , & ! ny = ny , & ! nx2 = nx2 , & ! ny2 = ny2 , & ! ext = 'constant' , & ! type_apo = 'hann__' ) ! scal_surf % xres = nx2 scal_surf % yres = ny2 call write_surf ( nom_fic = \"out/test_extend.sur\" , & ! tab_s = ext_heights ( 1 : nx2 , 1 : ny2 ), & ! scal = scal_surf ) ! deallocate ( ext_heights ) !========================================================================= fft_filter 5 µm call read_surf ( nom_fic = \"sur/AB-Zinv-ART-8-21-200x200.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres dx = scal_surf % dx * unit2IUf ( scal_surf % dx_unit ) dy = scal_surf % dy * unit2IUf ( scal_surf % dy_unit ) dz = 0 write ( * , * ) 'nx, ny = ' , nx , ny write ( * , * ) 'dx, dy = ' , dx , dy allocate ( heights_out ( 1 : nx , 1 : ny ) ) n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) nx2 = 2 * ( nint ( PAD_FFT_FILTER * nx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT_FILTER * ny ) / 2 ) fft_cutoff = dx / 5.e-6 call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! cutoff = fft_cutoff , & ! bf_tab = heights_out ( 1 : nx , 1 : ny ), & ! multi_fft = . FALSE .) ! call write_surf ( nom_fic = \"out/test_fft_filter_005µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'gaussian filter cutoff = 5 µm' !========================================================================= fft_filter 80 µm fft_cutoff = dx / 8 0.e-6 call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! cutoff = fft_cutoff , & ! bf_tab = heights_out ( 1 : nx , 1 : ny ), & ! multi_fft = . FALSE .) ! call write_surf ( nom_fic = \"out/test_fft_filter_080µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'gaussian filter cutoff = 80 µm' !========================================================================= fft_filter 150 µm fft_cutoff = dx / 15 0.e-6 call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! cutoff = fft_cutoff , & ! bf_tab = heights_out ( 1 : nx , 1 : ny ), & ! multi_fft = . FALSE .) ! call write_surf ( nom_fic = \"out/test_fft_filter_150µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'gaussian filter cutoff = 150 µm' call end_fftw3 () !========================================================================= ROLL +, RAY = 10 µm call morpho_filter ( mtype = \"dilation\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_dilation_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: dilation disk 10 µm' !------------------------------------------------------------------------- ROLL -, RAY = 10 µm call morpho_filter ( mtype = \"erosion\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_erosion_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: erosion disk 10 µm' !------------------------------------------------------------------------- CLOSING, RAY = 10 µm call morpho_filter ( mtype = \"closing\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_closing_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: closing disk 10 µm' !------------------------------------------------------------------------- OPENING, RAY = 10 µm call morpho_filter ( mtype = \"opening\" , & ! IN tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabou = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny , & ! IN scale_xyz = [ dx , dy , dz ], & ! IN ray = 1 0.e-6_R8 , & ! IN omp = . true ., & ! IN nb_div = 50 ) ! IN call write_surf ( nom_fic = \"out/test_roll_smooth_opening_10µm.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'morpho filter: opening disk 10 µm' !========================================================================= KERNEL SIZE = 3 allocate ( heights_copy ( 1 : nx , 1 : ny ) ) heights_copy ( 1 : nx , 1 : ny ) = heights ( 1 : nx , 1 : ny ) call median_smooth ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 3 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_smooth_3.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'median filter kernel: 3' !========================================================================= KERNEL SIZE = 5 heights ( 1 : nx , 1 : ny ) = heights_copy ( 1 : nx , 1 : ny ) call median_smooth ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 5 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_smooth_5.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'median filter kernel: 5' !========================================================================= KERNEL SIZE = 9 heights ( 1 : nx , 1 : ny ) = heights_copy ( 1 : nx , 1 : ny ) call median_smooth ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 9 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_smooth_9.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'median filter kernel: 9' !========================================================================= SOFTEN NO MASK heights ( 1 : nx , 1 : ny ) = heights_copy ( 1 : nx , 1 : ny ) call soften ( tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabout = heights_out ( 1 : nx , 1 : ny ), & ! OUT long = nx , & ! IN larg = ny ) ! IN call write_surf ( nom_fic = \"out/test_soften_no_mask.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'simple smooth with no mask' !========================================================================= SOFTEN WITH MASK call read_surf ( nom_fic = \"sur/test_mask.sur\" , & ! IN tab_s = mask , & ! OUT scal = scal_mask ) ! OUT call soften ( tabin = heights ( 1 : nx , 1 : ny ), & ! IN tabout = heights_out ( 1 : nx , 1 : ny ), & ! OUT mask = nint ( mask ( 1 : nx , 1 : ny )), & ! IN long = nx , & ! IN larg = ny ) ! IN call write_surf ( nom_fic = \"out/test_soften_with_mask.sur\" , & ! tab_s = heights_out ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! write ( * , * ) 'simple smooth in upper mask' !========================================================================= MEDIAN FILTER SNB = 10, KERN = 15 call median_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! INOUT long = nx , & ! IN larg = ny , & ! IN kernel = 15 , & ! IN snb = 10 , & ! IN sig = 3._R8 , & ! IN omp = . true . ) ! IN call write_surf ( nom_fic = \"out/test_med_filt_k15_s10.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! deallocate ( heights , heights_copy , heights_out , mask ) stop endprogram test_smooth","tags":"","loc":"sourcefile/prg.f90~2.html"},{"title":"mod_abbott.f90 – TPGLIB","text":"This file depends on sourcefile~~mod_abbott.f90~~EfferentGraph sourcefile~mod_abbott.f90 mod_abbott.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_abbott.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_abbott.f90~~AfferentGraph sourcefile~mod_abbott.f90 mod_abbott.f90 sourcefile~prg.f90~3 prg.f90 sourcefile~prg.f90~3->sourcefile~mod_abbott.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.1.0 !<  date: april, 07 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Returns the Firestone Abbott's curve as well as some ISO 25178 parameters** !<  </span> module abbott use data_arch , only : I4 , R4 , R8 , UN , EPS_R8 , PI_R8 use miscellaneous , only : get_unit use stat_mom , only : calc_moments , moment_stat use sort_arrays , only : sort_array2 use least_squares , only : moindres_carres_lineaire use gnufor , only : run_gnuplot use pikaia_oop , only : pikaia_class !$ use omp_lib implicit none contains subroutine abbott_param ( tab , lg , nom , curves , results , omp ) !================================================================================================ !< @note Function that returns the Abbott's curve in a svg file as well as smrk1, smrk2, spk, svk, sk ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *surface total number of points* character ( len =* ), intent ( in ) :: nom !! *output generic name* logical ( kind = I4 ), intent ( in ), dimension ( 1 : 3 ) :: curves !! *if true, generates a svg drawing* !! 1: histogram 2: Abbott 3: tangent fit real ( kind = R8 ), intent ( inout ), dimension ( 1 : lg ) :: tab !! *surface in a 1D vector* real ( kind = R8 ), intent ( out ), dimension ( 1 : 11 ) :: results !! *surface parameters output* !! !!  +  1 **smrk1**, iso 25178 !!  +  2 **smrk2**, iso 25178 !!  +  3 **spk**  , iso 25178 !!  +  4 **svk**  , iso 25178 !!  +  5 **off1** , ordonnée de spk !!  +  6 **off2** , ordonnée de svk !!  +  7 **sk**   , iso 25178 !!  +  8 **core slope** !!  +  9 **adjustment factor** (tangent fit) !!  + 10 **coeffa_tan**        (tangent fit) !!  + 11 **coeffb_tan**        (tangent fit) logical ( kind = I4 ), intent ( in ) :: omp !! *if true, openmp used* integer ( kind = I4 ), parameter :: nb_points = 4 * 4096 ! nb points kept for the curve integer ( kind = I4 ) :: i , ua , icat , ncat , nb_paquets , inc , reste integer ( kind = I4 ) :: len_reg , beg_reg , end_reg integer ( kind = I4 ) :: smrk1 , smrk2 , ios integer ( kind = I4 ) :: status ! PIKAIA: status real ( kind = R8 ) :: hmin , hmax , delt , seuil , reduction real ( kind = R8 ) :: tmp , off1 , off2 , spk , svk , sk real ( kind = R8 ) :: f ! PIKAIA: best cost type ( moment_stat ) :: mx real ( kind = R8 ), dimension ( 1 : 2 ) :: vec_reg real ( kind = R8 ), dimension ( 1 : 4 ) :: xx ! PIKAIA: chromosom real ( kind = R8 ), dimension ( 1 : 4 ) :: xl , xu ! PIKAIA: lower and upper bonds of xx integer ( kind = I4 ), allocatable , dimension (:) :: tab_abbott real ( kind = R8 ), allocatable , dimension (:) :: tab_moy real ( kind = R8 ), allocatable , dimension (:,:) :: jac_reg type ( pikaia_class ) :: p ! PIKAIA: class instanciation ! center heights call calc_moments ( tab = tab ( 1 : lg ), & ! mx = mx , & ! nb_mom = 2 ) ! tab ( 1 : lg ) = tab ( 1 : lg ) - mx % mu ! sort in decreasing order tab ( 1 : lg ) = - tab ( 1 : lg ) call sort_array2 ( tab_inout = tab ( 1 : lg ), & ! n = lg ) ! tab ( 1 : lg ) = - tab ( 1 : lg ) ! reduction factor to stay between 1 and 100 because there are ! too many points in array tab reduction = nb_points / 10 0. ! array of points for the curve allocate ( tab_moy ( 1 : nb_points ) ) ! nb heights of tab representing each point of the curve nb_paquets = lg / ( nb_points - 1 ) ! ... and remaining heights reste = lg - nb_paquets * ( nb_points - 1 ) ! array of points; the first point and the last one are ! the first and last height to keep the extrema. inc = 1 do i = 1 , nb_points - 1 tab_moy ( i ) = tab ( inc ) inc = inc + nb_paquets if ( i == nb_points / 2 ) inc = inc + reste - 1 ! the remaing heights are added to ! the middle points, where it makes less difference enddo tab_moy ( nb_points ) = tab ( lg ) if ( curves ( 1 ) ) then ! print histogram ? ncat = 100 !  nombre de \"classes\" pour l'histogramme allocate ( tab_abbott ( 1 : ncat ) ) ; tab_abbott ( 1 : ncat ) = 0 hmin = tab ( lg ) - 100 * EPS_R8 !  pour être sûr d'attraper le min hmax = tab ( 1 ) + 100 * EPS_R8 !  idem pour le max delt = ( hmax - hmin ) / ncat ! categories width (heights) seuil = hmax - delt i = 0 do icat = 1 , ncat do i = i + 1 ; if ( i > lg ) exit if ( tab ( i ) < seuil ) exit tab_abbott ( icat ) = tab_abbott ( icat ) + 1 enddo seuil = seuil - delt enddo call get_unit ( ua ) open ( unit = ua , file = trim ( nom ) // '_histo.txt' ) do icat = 1 , ncat write ( ua , * ) real ( hmax + delt / 2 - icat * delt , kind = R4 ), 100 * real ( tab_abbott ( icat ), kind = R4 ) / lg enddo close ( ua ) deallocate ( tab_abbott ) endif ! nb points for the line regression! between 30% and 60% of the curve len_reg = int ( 0.4 * nb_points ) beg_reg = int ( 0.3 * nb_points ) end_reg = beg_reg + len_reg - 1 allocate ( jac_reg ( 1 : len_reg , 1 : 2 ) ) ! jacobian regression : vec_reg(1) * Xi + vec_reg(2) * 1 jac_reg ( 1 : len_reg , 1 ) = [ ( beg_reg + i , i = 0 , len_reg - 1 ) ] jac_reg ( 1 : len_reg , 2 ) = 1._R8 call moindres_carres_lineaire ( nb_var = 2 , & ! number of parameters to be determined nb_pts = len_reg , & ! number of points for function evaluation hij = tab_moy ( beg_reg : end_reg ), & ! vector of evaluation points (1:nb_pts) beta = vec_reg ( 1 : 2 ), & ! parameters vector (1:nb_var) Jf = jac_reg ( 1 : len_reg , 1 : 2 ) ) ! Jacobian (1:nb_pts, 1:nb_var) ! f(smrk1) coordinates off1 = vec_reg ( 2 ) ! (0._R8, off1) do i = 1 , nb_points if ( tab_moy ( i ) < off1 ) exit enddo smrk1 = i ! (UN*smrk1, off1) tmp = 0. do i = 1 , smrk1 tmp = tmp + ( tab_moy ( i ) - off1 ) enddo spk = 2 * tmp / smrk1 ! areas equivalency spk = abs ( spk ) ! f(smrk2) coordinates off2 = vec_reg ( 1 ) * nb_points + vec_reg ( 2 ) ! (nb_points, off2) do i = nb_points , 1 , - 1 if ( tab_moy ( i ) > off2 ) exit enddo smrk2 = i ! (UN*smrk2, off2) tmp = 0. do i = smrk2 , nb_points tmp = tmp + ( tab_moy ( i ) - off2 ) enddo svk = 2 * tmp / ( nb_points - smrk2 + 1 ) ! areas equivalency sk = tab_moy ( smrk1 ) - tab_moy ( smrk2 ) if ( curves ( 2 ) ) then ! print Abbott ? call get_unit ( ua ) open ( unit = ua , file = trim ( nom ) // '.dat' ) do i = 1 , nb_points write ( ua , * ) 100 * real ( i - 1 , kind = R4 ) / ( nb_points - 1 ), & ! real ( tab_moy ( i ), kind = R4 ), & ! real ( vec_reg ( 1 ) * i + vec_reg ( 2 ), kind = R4 ) ! enddo close ( ua ) open ( unit = ua , file = trim ( nom ) // '.gpl' , status = 'replace' , iostat = ios ) write ( ua , '(a)' ) 'set terminal svg dashed size 350,262 font \"Verdana, 10\"' write ( ua , '(a)' ) 'set output \"' // trim ( nom ) // '.svg\"' write ( ua , '(a)' ) 'set title \"Abbott\"' write ( ua , '(a)' ) 'set xlabel \"%age\"' write ( ua , '(a)' ) 'set ylabel \"h\"' write ( ua , '(a)' ) \"set style line 1 lc rgb 'dark-green' lt 1 lw 1\" write ( ua , '(a)' ) \"set style line 2 lc rgb 'dark-green' lt 5 lw 1\" ! tracé du segment horizontal de A1 (cf norme 25178) write ( ua , * ) 'set arrow 1 from ' , 0._R8 / reduction , ',' , off1 , ' to ' , UN * smrk1 / reduction , ',' , off1 , ' nohead front ls 1' ! tracé du segment incliné de A1 write ( ua , * ) 'set arrow 2 from ' , UN * smrk1 / reduction , ',' , off1 , ' to ' , 0._R8 / reduction , ',' , spk + off1 , ' nohead front ls 1' ! tracé de la droite haute horizontale write ( ua , * ) 'set arrow 5 from ' , 0._R8 / reduction , ',' , off1 , ' to ' , UN * nb_points / reduction , ',' , off1 , ' nohead front ls 2' ! tracé du segment horizontal de A2 (cf norme 25178) write ( ua , * ) 'set arrow 3 from ' , UN * smrk2 / reduction , ',' , off2 , ' to ' , UN * nb_points / reduction , ',' , off2 , ' nohead front ls 1' ! tracé du segment incliné de A2 write ( ua , * ) 'set arrow 4 from ' , UN * smrk2 / reduction , ',' , off2 , ' to ' , UN * nb_points / reduction , ',' , svk + off2 , ' nohead front ls 1' ! tracé de la droite basse horizontale write ( ua , * ) 'set arrow 6 from ' , UN * nb_points / reduction , ',' , off2 , ' to ' , 0._R8 / reduction , ',' , off2 , ' nohead front ls 2' ! tracé du segment vertical correspondant à sk write ( ua , * ) 'set arrow 7 from ' , 5 0. , ',' , off2 , ' to ' , 5 0. , ',' , off2 + sk , ' nohead front ls 1' write ( ua , '(a)' ) 'plot \"' // trim ( nom ) // '.dat\" ' // 'using 1:2  title \"Abbott-Firestone curve\" with lines,\\' write( ua, ' ( a ) ' )     ' \"' // trim(nom)//'.dat\" ' // ' using 1 : 3 notitle with lines ls 1 ' close(unit = ua) call run_gnuplot (trim(nom)//' . gpl ') endif deallocate( jac_reg ) !----------------------------------------------------------- call sort_array2( tab_inout = tab_moy(1:nb_points), &  ! n         = nb_points )              ! xx(1:4) = 0.0_R8 ! vector of parameters xl(1:4) = 0.0_R8 ! lower bound xu(1:4) = 1.0_R8 ! upper bound !initialize the class: call p%init(           n = 4,                   &  ! IN           ; the parameter space dimension, i.e., the number of !                adjustable parameters (size of the x vector). xl = xl,                  &  ! IN, DIM(n)   ; vector of lower bounds for x xu = xu,                  &  ! IN, DIM(n)   ; vector of upper bounds for x f = cost,                &  !              ; user-supplied scalar function of n variables, which !                must have the pikaia_func procedure interface. status = status,              &  ! OUT          ; status output flag (0 if there were no errors) np = 100,                 &  ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000,                &  ! IN, OPT      ; maximum number of iterations nd = 9,                   &  ! IN           ; number of significant digits (i.e., number of genes) !                retained in chromosomal encoding pcross = 0.85_R8,             &  ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85) !                If crossover takes place, either one or two splicing points are used, !                with equal probabilities pmutmn = 0.0005_R8,           &  ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8,             &  ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8,            &  ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) !                (Note: the mutation rate is the probability that any one gene !                 locus will mutate in any one generation.) imut = 2,                   &  ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !                1=one-point mutation, fixed rate. !                2=one-point, adjustable rate based on fitness. !                3=one-point, adjustable rate based on distance. !                4=one-point+creep, fixed rate. !                5=one-point+creep, adjustable rate based on fitness. !                6=one-point+creep, adjustable rate based on distance. fdif = 1._R8,               &  ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). !                (default is 1.0) irep = 3,                   &  ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/ !                                         Steady-state-replace-random/ !                                         Steady- state-replace-worst (default is 3) ielite = 0,                   &  ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) !                (Applies only to reproduction plans 1 and 2) ivrb = 0,                   &  ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8,           &  ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 400,                 &  ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive !                solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8,              &  ! IN, OPT      ; raction of the initial population to set equal to the initial guess. !                Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999)                    ! IN, OPT      ; random seed value; must be > 0 (default is 999) !Now call pikaia: call p%solve(      x = xx(1:4),     &  ! INOUT, DIM(*) ; f = f,           &  !   OUT         ; status = status,      &  !   OUT         ; omp = omp )           ! IN xx(3:4) = xx(3:4) * mx%si if ( curves(3) ) then ! print tangent fit ? call get_unit(ua) open( unit = ua, file = trim(nom)//' _ tan . datt ') do i = 1, nb_points write(ua, *) 100 * real( i - 1, kind = R4) / (nb_points - 1),                                      &  ! real( tab_moy(i), kind = R4 ),                                                  &  ! real( tg( real( i - 1, kind = R8) / ( nb_points - 1 ), xx(1:4) ), kind = R4 )      ! enddo close(ua) open( unit = ua, file = trim(nom)//' _ tan . gplt ', status = ' replace ', iostat = ios ) write( ua, ' ( a ) ' ) ' set terminal svg size 350 , 262 font \"Verdana, 10\" ' write( ua, ' ( a ) ' ) ' set output \"'//trim(nom)//'_tan.svgt\" ' write( ua, ' ( a ) ' ) ' set title \"Abbott-Firestone curve\" ' write( ua, ' ( a ) ' ) ' set xlabel \"%age\" ' write( ua, ' ( a ) ' ) ' set ylabel \"h\" ' write( ua, ' ( a ) ' ) ' plot \"' // trim(nom)//'_tan.datt\" ' // ' using 1 : 2 title \"Abbott-Firestone\" with lines , \\ ' write( ua, ' ( a ) ' )     ' \"' // trim(nom)//'_tan.datt\" ' // ' using 1 : 3 title \"tangent regression\" with lines ' close(unit = ua) call run_gnuplot (trim(nom)//' _ tan . gplt ' ) endif results ( 1 : 11 ) = [ real ( smrk1 , kind = R8 ) * 100 / nb_points , & !  1 smrk1, iso 25178 real ( smrk2 , kind = R8 ) * 100 / nb_points , & !  2 smrk2, iso 25178 spk , & !  3 spk , iso 25178 abs ( svk ), & !  4 svk , iso 25178 spk + off1 , & !  5 off1, ordonnée de spk abs ( svk + off2 ), & !  6 off2, ordonnée de svk sk , & !  7 sk  , iso 25178 vec_reg ( 1 ) * nb_points / 10 0. , & !  8 core slope f , & !  9 adjustment factor (tangent fit) xx ( 1 ), & ! 10 coeffa_tan        (tangent fit) xx ( 2 ) ] ! 11 coeffb_tan        (tangent fit) deallocate ( tab_moy ) contains subroutine cost ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = 1. / ( 1. + diff_abb_tan ( chrom = x ( 1 : 4 ))) return endsubroutine cost real ( kind = R8 ) function diff_abb_tan ( chrom ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 4 ) :: chrom integer ( kind = I4 ) :: i ! the height array is standardize to avoid too small values diff_abb_tan = sum ( [ ( ( tg ( real ( i - 1 , kind = R8 ) / ( nb_points - 1 ), chrom ) - tab_moy ( i ) / mx % si ) ** 2. , i = 1 , nb_points , 8 ) ] ) return endfunction diff_abb_tan real ( kind = R8 ) function tg ( xi , chrom ) implicit none real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ), dimension ( 1 : 4 ) :: chrom tg = chrom ( 3 ) * tan ( ( PI_R8 / 2 ) * ( - ( 1._R8 - chrom ( 1 )) + xi * ( 2._R8 - ( chrom ( 1 ) + chrom ( 2 ) ) ) ) ) + chrom ( 4 ) return endfunction tg endsubroutine abbott_param endmodule abbott","tags":"","loc":"sourcefile/mod_abbott.f90.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~3~~EfferentGraph sourcefile~prg.f90~3 prg.f90 sourcefile~mod_abbott.f90 mod_abbott.f90 sourcefile~prg.f90~3->sourcefile~mod_abbott.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_abbott.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: november, 01 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Firestone Abbott's curve. Example of use** !<  </span> program test_abbott use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use surfile , only : read_surf , write_surf , SCALE_SURF use abbott , only : abbott_param implicit none real ( kind = R8 ), allocatable , dimension (:) :: vec_heights real ( kind = R8 ), allocatable , dimension (:,:) :: heights real ( kind = R8 ), dimension ( 1 : 11 ) :: res integer ( kind = I4 ) :: nx , ny type ( SCALE_SURF ) :: scal_surf call read_surf ( nom_fic = \"sur/test.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres allocate ( vec_heights ( 1 : nx * ny ) ) vec_heights ( 1 : nx * ny ) = reshape ( heights , [ nx * ny ] ) call abbott_param ( tab = vec_heights ( 1 : nx * ny ), & ! lg = nx * ny , & ! nom = 'out/test' , & ! curves = [. true ., . true ., . true .], & ! results = res ( 1 : 11 ), & ! omp = . true . ) ! write ( * , * ) 'smr1, iso 25178.................: ' , res ( 1 ) write ( * , * ) 'smr2, iso 25178.................: ' , res ( 2 ) write ( * , * ) 'spk , iso 25178.................: ' , res ( 3 ) write ( * , * ) 'svk , iso 25178.................: ' , res ( 4 ) write ( * , * ) 'off1, ordonnée de spk...........: ' , res ( 5 ) write ( * , * ) 'off2, ordonnée de svk...........: ' , res ( 6 ) write ( * , * ) 'sk  , iso 25178.................: ' , res ( 7 ) write ( * , * ) 'core slope..................... : ' , res ( 8 ) write ( * , * ) 'adjustment factor (tangent fit) : ' , res ( 9 ) write ( * , * ) 'coeffa_tan        (tangent fit) : ' , res ( 10 ) write ( * , * ) 'coeffb_tan        (tangent fit) : ' , res ( 11 ) write ( * , * ) write ( * , * ) 'NB: on a reduced Abbott curve, the tangent fit is not so good' // & ! ' because the beginning and the end of the data points are kept' // & ! ' making the curve too much sharp.' ! deallocate ( heights , vec_heights ) stop endprogram test_abbott","tags":"","loc":"sourcefile/prg.f90~3.html"},{"title":"mod_asfc.f90 – TPGLIB","text":"This file depends on sourcefile~~mod_asfc.f90~~EfferentGraph sourcefile~mod_asfc.f90 mod_asfc.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_asfc.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_asfc.f90~~AfferentGraph sourcefile~mod_asfc.f90 mod_asfc.f90 sourcefile~prg.f90~4 prg.f90 sourcefile~prg.f90~4->sourcefile~mod_asfc.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: may, 03 2019 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **A fast and accurate way of determining the area-scale fractal analysis complexity parameter Asfc** !<  </span> module asfc use data_arch , only : I4 , R8 , UN , EPS_R8 use miscellaneous , only : get_unit use surfile , only : read_surf , write_surf , SCALE_SURF use bspline , only : db2ink , db2val use minpack , only : lmder1 use least_squares , only : moindres_carres_lineaire use stat_mom , only : moment_stat , calc_moments !$ use omp_lib implicit none !> {!ASFC2/src/inc_doc/Asfc.md!} private integer ( kind = I4 ), parameter :: npp = 128 !! *number of points for the asfc determination* integer ( kind = I4 ), parameter :: long0 = 8 !! *roughest grid* integer ( kind = I4 ), parameter :: larg0 = 8 !! *roughest grid* integer ( kind = I4 ), parameter :: kx = 3 !! *x bspline order* integer ( kind = I4 ), parameter :: ky = 3 !! *y bspline order* integer ( kind = I4 ), parameter :: nb_beta = 4 !! *number of parameters to be determined when optimizing* integer ( kind = I4 ), parameter :: lin_all = 0 !! *linear interpolation between grids* integer ( kind = I4 ), parameter :: spl_all = 2 !! *spline interpolation between grids* integer ( kind = I4 ), parameter :: hermite = 4 !! *Hermite interpolation between grids* integer ( kind = I4 ), parameter :: method_asfc = hermite !! *default* integer ( kind = I4 ) :: unit_out_lin !! *output unit for the linear case* integer ( kind = I4 ) :: unit_out_spl !! *output unit for the spline case* integer ( kind = I4 ) :: unit_out_her !! *output unit for the Hermite case* logical ( kind = I4 ), parameter :: live = . false . !! *default for file outputs* logical ( kind = I4 ), parameter :: out_lin = live !! *default for file outputs, linear case* logical ( kind = I4 ), parameter :: out_spl = live !! *default for file outputs, spline case* logical ( kind = I4 ), parameter :: out_her = live !! *default for file outputs, Hermite case* logical ( kind = I4 ), parameter :: out_ter = live !! *default for terminal output* public :: calcul_asfc_hermite , indice_fractal contains subroutine calcul_aire ( tab_in , long , larg , hx , hy , aire ) !================================================================================================ !! Return the area of a surface implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ) :: hx !! *increment along x* real ( kind = R8 ), intent ( in ) :: hy !! *increment along y* real ( kind = R8 ), intent ( out ) :: aire !! *computed area* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: z1 , z2 , z3 , z4 , si si = 1 !SCALE_IMG%si ! Raisonnement sur chaque carré du domaine aire = 0. do j = 1 , larg - 1 do i = 1 , long - 1 z1 = tab_in ( i , j ) * si z2 = tab_in ( i , j + 1 ) * si z3 = tab_in ( i + 1 , j + 1 ) * si z4 = tab_in ( i + 1 , j ) * si aire = aire + 0.5_R8 * ( sqrt ( UN + (( z1 - z2 ) / hx ) ** 2 + (( z1 - z4 ) / hy ) ** 2 ) + & sqrt ( UN + (( z3 - z2 ) / hy ) ** 2 + (( z3 - z4 ) / hx ) ** 2 ) ) enddo enddo aire = aire / ( ( long - 1 ) * ( larg - 1 ) ) return endsubroutine calcul_aire subroutine calcul_asfc_lin_all ( tab_in , scal , asfc_res ) !================================================================================================ !! Return the *asfc* of a surface. The different grids are obtained by linear interpolation implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* real ( kind = R8 ), allocatable , dimension (:) :: x ! x points in original grid real ( kind = R8 ), allocatable , dimension (:) :: y ! y points in original grid integer ( kind = I4 ) :: long_new ! number of points in x dimension for new grid integer ( kind = I4 ) :: larg_new ! number of points in y dimension for new grid real ( kind = R8 ), allocatable , dimension (:) :: x_new ! new grid x points real ( kind = R8 ), allocatable , dimension (:) :: y_new ! new grid y points real ( kind = R8 ), allocatable , dimension (:,:) :: tab_ou ! new grid function evaluations real ( kind = R8 ) :: rr integer ( kind = I4 ) :: i , ii , j , jj , ip , long_tmp , larg_tmp integer ( kind = I4 ) :: nb_pt real ( kind = R8 ), dimension ( 1 : nb_beta ) :: beta real ( kind = R8 ), dimension ( 1 : npp ) :: vec_l real ( kind = R8 ), dimension ( 1 : npp ) :: vec_x ! points coordinates real ( kind = R8 ), dimension ( 1 : npp ) :: vec_y ! points coordinates real ( kind = R8 ) :: asfc1 , asfc2 , aire_lin , xm , xp , ym , yp , hx , hy , hhx , hhy , h1 , h2 , h3 , h4 , width , height logical ( kind = I4 ) :: new_it integer ( kind = I4 ) :: long , larg long = scal % xres larg = scal % yres if ( out_lin ) open ( unit = unit_out_lin , file = \"out/asfc_lin_lin_all.txt\" ) width = scal % lx height = scal % ly hx = width / ( long - 1 ) hy = height / ( larg - 1 ) ! définition d'abscisses pour l'interpolation par splines allocate ( x ( 1 : long ), y ( 1 : larg ) ) do i = 1 , long x ( i ) = hx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg y ( j ) = hy * real ( j - 1 , kind = R8 ) enddo rr = ( real ( long0 , kind = R8 ) / long ) ** ( UN / npp ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points rr = max ( rr , ( real ( larg0 , kind = R8 ) / larg ) ** ( UN / npp ) ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points allocate ( x_new ( 1 : long ), & y_new ( 1 : larg ), & ! nouvelles abscisses tab_ou ( 1 : long , 1 : larg ) ) x_new ( 1 : long ) = x ( 1 : long ) y_new ( 1 : larg ) = y ( 1 : larg ) tab_ou ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) ! pour chaque réduction de maillage, calcul du maillage résultant et de l'aire relative associée !............................................................. long_new = long larg_new = larg hhx = hx hhy = hy new_it = . true . nb_pt = 1 do ip = 1 , npp + 1 if ( new_it ) then long_tmp = long_new larg_tmp = larg_new ! calcul de l'aire relative call calcul_aire ( tab_ou ( 1 : long_tmp , 1 : larg_tmp ), long_tmp , larg_tmp , hhx , hhy , aire_lin ) if ( nb_pt > 1 ) then vec_x ( nb_pt - 1 ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) vec_l ( nb_pt - 1 ) = log ( aire_lin ) endif if ( out_lin . and . nb_pt > 1 ) write ( unit_out_lin , * ) vec_x ( nb_pt - 1 ), vec_l ( nb_pt - 1 ) if ( out_ter ) write ( * , * ) aire_lin , long_tmp , larg_tmp endif if ( ip == npp + 1 ) then deallocate ( x_new , y_new , x , y , tab_ou ) exit endif long_new = nint ( long * ( rr ** ip )) ! nb points en suite géométrique larg_new = nint ( larg * ( rr ** ip )) new_it = . true . if ( long_new == long_tmp . or . larg_new == larg_tmp ) then new_it = . false . cycle ! à découper trop fin, on peut tomber sur les mêmes entiers endif hhx = width / ( long_new - 1 ) hhy = height / ( larg_new - 1 ) deallocate ( x_new , y_new , tab_ou ) allocate ( x_new ( 1 : long_new ), & y_new ( 1 : larg_new ), & ! nouvelles abscisses tab_ou ( 1 : long_new , 1 : larg_new ) ) nb_pt = nb_pt + 1 do i = 1 , long_new x_new ( i ) = hhx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg_new y_new ( j ) = hhy * real ( j - 1 , kind = R8 ) enddo do j = 1 , larg_new jj = locate ( n = larg , xx = y ( 1 : larg ), x = y_new ( j )) ym = y_new ( j ) - y ( jj ) ; yp = y_new ( j ) - y ( jj + 1 ) ym = ym / hy ; yp = yp / hy do i = 1 , long_new ii = locate ( n = long , xx = x ( 1 : long ), x = x_new ( i )) xm = x_new ( i ) - x ( ii ) ; xp = x_new ( i ) - x ( ii + 1 ) xm = xm / hx ; xp = xp / hx h1 = tab_in ( ii , jj ) h2 = tab_in ( ii + 1 , jj ) h3 = tab_in ( ii + 1 , jj + 1 ) h4 = tab_in ( ii , jj + 1 ) tab_ou ( i , j ) = h1 * xp * yp - h2 * xm * yp + h3 * xm * ym - h4 * xp * ym enddo enddo enddo if ( out_lin ) close ( unit_out_lin ) !call system('python pyt/filetoplot.py &') !............................................................. nb_pt = nb_pt - 1 vec_y ( 1 : nb_pt ) = vec_l ( 1 : nb_pt ) call interpolate_asfc ( bt = beta ( 1 : nb_beta ), & n_bt = nb_beta , & n_pt = nb_pt , & asf = asfc1 , & r2 = asfc2 ) asfc_res = [ - 1000 * asfc1 , asfc2 ] return contains subroutine interpolate_asfc ( bt , n_bt , n_pt , asf , r2 ) !================================================================================================ !< @note Function that fits the data points for the asfc determination.<br/> !        f\\_boltz(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( out ) :: asf !! *Asfc number* real ( kind = R8 ), intent ( out ) :: r2 !! *correlation number to assess validity of the Asfc calculus* real ( kind = R8 ), dimension ( 1 : n_pt , 1 : n_bt ) :: jacob real ( kind = R8 ), dimension ( 1 : n_pt ) :: v_x , v_y , res_y , pentes integer ( kind = I4 ) :: i0 , i , j , info real ( kind = R8 ) :: delta1 , delta2 , y_mean v_x ( 1 : n_pt ) = vec_x ( 1 : n_pt ) ! smoothing v_y ( 1 ) = vec_y ( 1 ) do i = 1 + 1 , n_pt - 1 v_y ( i ) = 0.25_R8 * ( vec_y ( i - 1 ) + 2 * vec_y ( i ) + vec_y ( i + 1 ) ) enddo v_y ( n_pt ) = vec_y ( n_pt ) call init_beta_boltz ( bt = bt ( 1 : n_bt ), & ! n_bt = n_bt , & ! v_x = v_x ( 1 : n_pt ), & ! v_y = v_y ( 1 : n_pt ), & ! n_pt = n_pt ) ! res_y ( 1 : n_pt ) = 0._R8 jacob ( 1 : n_pt , 1 : n_bt ) = 0._R8 call lmder1 ( fcn = lmder1_f , & ! m = n_pt , & ! n = n_bt , & ! x = bt ( 1 : n_bt ), & ! fvec = res_y ( 1 : n_pt ), & ! fjac = jacob ( 1 : n_pt , 1 : n_bt ), & ! ldfjac = n_pt , & ! tol = 1.0e-8_R8 , & ! info = info ) ! delta1 = 0._R8 delta2 = 0._R8 y_mean = sum ( vec_y ( 1 : n_pt ) ) / n_pt do i = 1 , n_pt delta1 = delta1 + ( vec_y ( i ) - f_boltz ( xi = vec_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt ) & ! ) ** 2 delta2 = delta2 + ( vec_y ( i ) - y_mean ) ** 2 enddo r2 = 1._R8 - delta1 / delta2 !~       if (r2<0) then !~       do i=1,n_pt !~       write(99,*) v_x(i), v_y(i) !~       enddo !~       stop 'error' !~       endif i0 = locate ( n = n_pt , & ! xx = v_x ( 1 : n_pt ), & ! x = bt ( 1 )) ! j = 0 do i = i0 - 5 , i0 + 5 if ( i < 1 . or . i > n_pt ) cycle j = j + 1 pentes ( j ) = + df_boltz ( xi = v_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt , & ! ivar = 0 ) ! enddo asf = sum ( pentes ( 1 : j ) / j ) return endsubroutine interpolate_asfc subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !================================================================================================ !< @note Function called by [[lmder1]] as part of **minpack**, modified by !        [Burkardt](https://people.sc.fsu.edu/~jburkardt/f_src/minpack/minpack.html) <br/> !        According *iflag* value it calculates the function [[f_boltz]] at the data points !        or the jacobian. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: m !! *number of points* integer ( kind = I4 ), intent ( in ) :: n !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ldfjac !! *leading dimension of fjac, which must be at least n* integer ( kind = I4 ), intent ( in ) :: iflag !! *which calculus to perform* real ( kind = R8 ), intent ( out ), dimension ( 1 : m ) :: fvec !! *vector of f_boltz(xi)* real ( kind = R8 ), intent ( out ), dimension ( 1 : ldfjac , 1 : n ) :: fjac !! *jacobian* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n ) :: x !! *parameter values* integer ( kind = I4 ) :: i , k select case ( iflag ) case ( 0 ) continue case ( 1 ) do i = 1 , m fvec ( i ) = f_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! n_beta = n ) & ! - vec_y ( i ) enddo case ( 2 ) do i = 1 , m do k = 1 , n fjac ( i , k ) = df_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! ivar = k , & ! n_beta = n ) ! enddo enddo case default write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop endselect return endsubroutine lmder1_f endsubroutine calcul_asfc_lin_all subroutine calcul_asfc_spl_all ( tab_in , scal , asfc_res ) !================================================================================================ !! Return the *asfc* of a surface. The different grids are obtained by spline of degree 3 implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* integer ( kind = I4 ), parameter :: idx = 0 ! [[db2val]] input integer ( kind = I4 ), parameter :: idy = 0 ! [[db2val]] input real ( kind = R8 ), allocatable , dimension (:) :: x ! x points in original grid real ( kind = R8 ), allocatable , dimension (:) :: y ! y points in original grid integer ( kind = I4 ) :: long_new ! number of points in x dimension for new grid integer ( kind = I4 ) :: larg_new ! number of points in y dimension for new grid real ( kind = R8 ), allocatable , dimension (:) :: x_new ! new grid x points real ( kind = R8 ), allocatable , dimension (:) :: y_new ! new grid y points real ( kind = R8 ), allocatable , dimension (:,:) :: tab_ou ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: coeff , coeff_tmp real ( kind = R8 ), allocatable , dimension (:) :: tx , tx_tmp ! x knots real ( kind = R8 ), allocatable , dimension (:) :: ty , ty_tmp ! y knots real ( kind = R8 ) :: val , rr integer ( kind = I4 ) :: i , j , k , ip , long_tmp , larg_tmp integer ( kind = I4 ) :: iflag integer ( kind = I4 ) :: inbvx , inbvy , iloy integer ( kind = I4 ) :: nb_pt integer ( kind = I4 ), dimension ( 1 : 8 ) :: d1 , d2 real ( kind = R8 ), dimension ( 1 : nb_beta ) :: beta real ( kind = R8 ), dimension ( 1 : npp ) :: vec_l , vec_s real ( kind = R8 ), dimension ( 1 : npp ) :: vec_x ! points coordinates real ( kind = R8 ), dimension ( 1 : npp ) :: vec_y ! points coordinates real ( kind = R8 ), dimension ( 1 : 8 ) :: gx , gy , vf real ( kind = R8 ) :: asfc1 , asfc2 , aire , aire_lin , aire_tmp , x1 , x2 , y1 , y2 , val_x , val_y , width , height , hx , hy , hhx , hhy logical ( kind = I4 ) :: new_it integer ( kind = I4 ) :: long , larg long = scal % xres larg = scal % yres if ( out_lin ) open ( unit = unit_out_lin , file = \"out/asfc_lin_spl_all.txt\" ) if ( out_spl ) open ( unit = unit_out_spl , file = \"out/asfc_spl_spl_all.txt\" ) width = scal % lx height = scal % ly hx = width / ( long - 1 ) hy = height / ( larg - 1 ) ! définition d'abscisses pour l'interpolation par splines allocate ( x ( 1 : long ), y ( 1 : larg ) ) do i = 1 , long x ( i ) = hx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg y ( j ) = hy * real ( j - 1 , kind = R8 ) enddo rr = ( real ( long0 , kind = R8 ) / long ) ** ( UN / npp ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points rr = max ( rr , ( real ( larg0 , kind = R8 ) / larg ) ** ( UN / npp ) ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points allocate ( x_new ( 1 : long ), & y_new ( 1 : larg ), & ! nouvelles abscisses tab_ou ( 1 : long , 1 : larg ) ) x_new ( 1 : long ) = x ( 1 : long ) y_new ( 1 : larg ) = y ( 1 : larg ) tab_ou ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) ! pour chaque réduction de maillage, calcul du maillage résultant et de l'aire relative associée !............................................................. long_new = long larg_new = larg hhx = hx hhy = hy nb_pt = 1 new_it = . true . do ip = 1 , npp + 1 if ( new_it ) then long_tmp = long_new larg_tmp = larg_new ! calcul de l'aire relative call calcul_aire ( tab_ou ( 1 : long_tmp , 1 : larg_tmp ), long_tmp , larg_tmp , hhx , hhy , aire_lin ) !, rx=real(long-1, kind=R8)/(long_tmp-1), & ! ry=real(larg-1, kind=R8)/(larg_tmp-1)) allocate ( coeff_tmp ( 1 : long_tmp , 1 : larg_tmp ) ) allocate ( tx_tmp ( 1 :( long_tmp + kx )), & ty_tmp ( 1 :( larg_tmp + ky )) ) iflag = 0 call db2ink ( x = x_new ( 1 : long_tmp ), & nx = long_tmp , & y = y_new ( 1 : larg_tmp ), & ny = larg_tmp , & fcn = tab_ou ( 1 : long_tmp , 1 : larg_tmp ), & kx = kx , & ky = ky , & tx = tx_tmp ( 1 :( long_tmp + kx )), & ty = ty_tmp ( 1 :( larg_tmp + ky )), & bcoef = coeff_tmp ( 1 : long_tmp , 1 : larg_tmp ), & iflag = iflag ) if ( iflag /= 1 ) then write ( * , * ) iflag , long_tmp , larg_tmp , kx , ky stop 'error calling db2ink' endif if ( ip == 1 ) then allocate ( coeff ( 1 : long , 1 : larg ) ) allocate ( tx ( 1 :( long + kx )), & ty ( 1 :( larg + ky )) ) coeff ( 1 : long , 1 : larg ) = coeff_tmp ( 1 : long , 1 : larg ) tx ( 1 :( long + kx )) = tx_tmp ( 1 :( long + kx )) ty ( 1 :( larg + ky )) = ty_tmp ( 1 :( larg + ky )) endif inbvx = 1 inbvy = 1 iloy = 1 aire_tmp = 0._R8 !~             !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_PROCS) IF(MULTI_PROCS2) !~             !$OMP DO SCHEDULE (STATIC,(larg_tmp-1)/NB_PROCS) PRIVATE(i, k, iflag, val, y1, y2, x1, x2, d1, d2, gx, gy, vf) FIRSTPRIVATE(inbvx, inbvy, iloy) REDUCTION(+:aire_tmp) do j = 1 , larg_tmp - 1 y1 = y_new ( j ) + ( hhy / 2 ) * ( UN - UN / sqrt ( 3._R8 )) y2 = y_new ( j ) + ( hhy / 2 ) * ( UN + UN / sqrt ( 3._R8 )) do i = 1 , long_tmp - 1 x1 = x_new ( i ) + ( hhx / 2 ) * ( UN - UN / sqrt ( 3._R8 )) x2 = x_new ( i ) + ( hhx / 2 ) * ( UN + UN / sqrt ( 3._R8 )) d1 ( 1 : 8 ) = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] d2 ( 1 : 8 ) = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] gx ( 1 : 8 ) = [ x1 , x1 , x1 , x1 , x2 , x2 , x2 , x2 ] gy ( 1 : 8 ) = [ y1 , y1 , y2 , y2 , y1 , y1 , y2 , y2 ] do k = 1 , 8 call db2val ( xval = gx ( k ), & yval = gy ( k ), & idx = d1 ( k ), & idy = d2 ( k ), & tx = tx_tmp ( 1 :( long_tmp + kx )), & ty = ty_tmp ( 1 :( larg_tmp + ky )), & nx = long_tmp , & ny = larg_tmp , & kx = kx , & ky = ky , & bcoef = coeff_tmp ( 1 : long_tmp , 1 : larg_tmp ), & f = vf ( k ), & iflag = iflag , & inbvx = inbvx , & inbvy = inbvy , & iloy = iloy ) if ( iflag /= 0 ) then write ( * , * ) iflag stop 'error calling db2val' endif enddo do k = 1 , 4 val_x = vf ( 2 * k - 1 ) val_y = vf ( 2 * k ) aire_tmp = aire_tmp + sqrt ( UN + val_x ** 2 + val_y ** 2 ) enddo enddo enddo !~             !$OMP END DO !~             !$OMP END PARALLEL aire = aire_tmp * ( hhx / 2 ) * ( hhy / 2 ) aire = aire / ( width * height ) vec_x ( nb_pt ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) vec_l ( nb_pt ) = log ( aire_lin ) vec_s ( nb_pt ) = log ( aire ) if ( out_lin . and . nb_pt > 1 ) write ( unit_out_lin , * ) vec_x ( nb_pt - 1 ), vec_l ( nb_pt - 1 ) if ( out_spl . and . nb_pt > 1 ) write ( unit_out_spl , * ) vec_x ( nb_pt - 1 ), vec_s ( nb_pt - 1 ) if ( out_ter ) write ( * , * ) hhx , hhy , aire , ip endif if ( ip == npp + 1 ) then deallocate ( x_new , y_new , x , y , tab_ou , coeff , tx , ty , coeff_tmp , tx_tmp , ty_tmp ) exit endif long_new = nint ( long * ( rr ** ip )) ! nb points en suite géométrique larg_new = nint ( larg * ( rr ** ip )) new_it = . true . if ( long_new == long_tmp . or . larg_new == larg_tmp ) then new_it = . false . cycle ! à découper trop fin, on peut tomber sur les mêmes entiers endif hhx = width / ( long_new - 1 ) hhy = height / ( larg_new - 1 ) nb_pt = nb_pt + 1 deallocate ( x_new , y_new , tab_ou ) allocate ( x_new ( 1 : long_new ), & y_new ( 1 : larg_new ), & ! nouvelles abscisses tab_ou ( 1 : long_new , 1 : larg_new ) ) do i = 1 , long_new x_new ( i ) = hhx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg_new y_new ( j ) = hhy * real ( j - 1 , kind = R8 ) enddo inbvx = 1 inbvy = 1 iloy = 1 ! calcul des hauteurs de la surface interpolée !~          !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_PROCS) IF(MULTI_PROCS2) !~          !$OMP DO SCHEDULE (STATIC,larg_new/NB_PROCS) PRIVATE(i, iflag, val) FIRSTPRIVATE(inbvx, inbvy, iloy) do j = 1 , larg_new do i = 1 , long_new call db2val ( xval = x_new ( i ), & yval = y_new ( j ), & idx = idx , & idy = idy , & tx = tx ( 1 :( long + kx )), & ty = ty ( 1 :( larg + ky )), & nx = long , & ny = larg , & kx = kx , & ky = ky , & bcoef = coeff ( 1 : long , 1 : larg ), & f = val , & iflag = iflag , & inbvx = inbvx , & inbvy = inbvy , & iloy = iloy ) if ( iflag /= 0 ) error stop 'error calling db2val' iflag = 0 tab_ou ( i , j ) = val enddo enddo !~          !$OMP END DO !~          !$OMP END PARALLEL deallocate ( coeff_tmp , tx_tmp , ty_tmp ) enddo if ( out_lin ) close ( unit_out_lin ) if ( out_spl ) close ( unit_out_spl ) !............................................................. nb_pt = nb_pt - 1 vec_y ( 1 : nb_pt ) = vec_s ( 1 : nb_pt ) call interpolate_asfc ( bt = beta ( 1 : nb_beta ), & n_bt = nb_beta , & n_pt = nb_pt , & asf = asfc1 , & r2 = asfc2 ) asfc_res = [ - 1000 * asfc1 , asfc2 ] return contains subroutine interpolate_asfc ( bt , n_bt , n_pt , asf , r2 ) !================================================================================================ !< @note Function that fits the data points for the asfc determination.<br/> !        f\\_boltz(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( out ) :: asf !! *Asfc number* real ( kind = R8 ), intent ( out ) :: r2 !! *correlation number to assess validity of the Asfc calculus* real ( kind = R8 ), dimension ( 1 : n_pt , 1 : n_bt ) :: jacob real ( kind = R8 ), dimension ( 1 : n_pt ) :: v_x , v_y , res_y , pentes integer ( kind = I4 ) :: i0 , i , j , info real ( kind = R8 ) :: delta1 , delta2 , y_mean v_x ( 1 : n_pt ) = vec_x ( 1 : n_pt ) ! smoothing v_y ( 1 ) = vec_y ( 1 ) do i = 1 + 1 , n_pt - 1 v_y ( i ) = 0.25_R8 * ( vec_y ( i - 1 ) + 2 * vec_y ( i ) + vec_y ( i + 1 ) ) enddo v_y ( n_pt ) = vec_y ( n_pt ) call init_beta_boltz ( bt = bt ( 1 : n_bt ), & ! n_bt = n_bt , & ! v_x = v_x ( 1 : n_pt ), & ! v_y = v_y ( 1 : n_pt ), & ! n_pt = n_pt ) ! res_y ( 1 : n_pt ) = 0._R8 jacob ( 1 : n_pt , 1 : n_bt ) = 0._R8 call lmder1 ( fcn = lmder1_f , & ! m = n_pt , & ! n = n_bt , & ! x = bt ( 1 : n_bt ), & ! fvec = res_y ( 1 : n_pt ), & ! fjac = jacob ( 1 : n_pt , 1 : n_bt ), & ! ldfjac = n_pt , & ! tol = 1.0e-8_R8 , & ! info = info ) ! delta1 = 0._R8 delta2 = 0._R8 y_mean = sum ( vec_y ( 1 : n_pt ) ) / n_pt do i = 1 , n_pt delta1 = delta1 + ( vec_y ( i ) - f_boltz ( xi = vec_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt ) & ! ) ** 2 delta2 = delta2 + ( vec_y ( i ) - y_mean ) ** 2 enddo r2 = 1._R8 - delta1 / delta2 !~       if (r2<0) then !~       do i=1,n_pt !~       write(99,*) v_x(i), v_y(i) !~       enddo !~       stop 'error' !~       endif i0 = locate ( n = n_pt , & ! xx = v_x ( 1 : n_pt ), & ! x = bt ( 1 )) ! j = 0 do i = i0 - 5 , i0 + 5 if ( i < 1 . or . i > n_pt ) cycle j = j + 1 pentes ( j ) = + df_boltz ( xi = v_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt , & ! ivar = 0 ) ! enddo asf = sum ( pentes ( 1 : j ) / j ) return endsubroutine interpolate_asfc subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !================================================================================================ !< @note Function called by [[lmder1]] as part of **minpack**, modified by !        [Burkardt](https://people.sc.fsu.edu/~jburkardt/f_src/minpack/minpack.html) <br/> !        According *iflag* value it calculates the function [[f_boltz]] at the data points !        or the jacobian. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: m !! *number of points* integer ( kind = I4 ), intent ( in ) :: n !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ldfjac !! *leading dimension of fjac, which must be at least n* integer ( kind = I4 ), intent ( in ) :: iflag !! *which calculus to perform* real ( kind = R8 ), intent ( out ), dimension ( 1 : m ) :: fvec !! *vector of f_boltz(xi)* real ( kind = R8 ), intent ( out ), dimension ( 1 : ldfjac , 1 : n ) :: fjac !! *jacobian* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n ) :: x !! *parameter values* integer ( kind = I4 ) :: i , k select case ( iflag ) case ( 0 ) continue case ( 1 ) do i = 1 , m fvec ( i ) = f_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! n_beta = n ) & ! - vec_y ( i ) enddo case ( 2 ) do i = 1 , m do k = 1 , n fjac ( i , k ) = df_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! ivar = k , & ! n_beta = n ) ! enddo enddo case default write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop endselect return endsubroutine lmder1_f endsubroutine calcul_asfc_spl_all subroutine calcul_asfc_hermite ( tab_in , scal , asfc_res , omp ) !================================================================================================ !! Return the *asfc* of a surface. The different grids are obtained by Hermite interpolation implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* logical ( kind = I4 ), intent ( in ) :: omp !! *with openmp ?* real ( kind = R8 ), allocatable , dimension (:) :: x ! x points in original grid real ( kind = R8 ), allocatable , dimension (:) :: y ! y points in original grid integer ( kind = I4 ) :: long_new ! number of points in x dimension for new grid integer ( kind = I4 ) :: larg_new ! number of points in y dimension for new grid real ( kind = R8 ), allocatable , dimension (:) :: x_new ! new grid x points real ( kind = R8 ), allocatable , dimension (:) :: y_new ! new grid y points real ( kind = R8 ), allocatable , dimension (:,:) :: tab_ou ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_in_dx ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_in_dy ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_in_xy ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:) :: gx real ( kind = R8 ), allocatable , dimension (:) :: gy real ( kind = R8 ), allocatable , dimension (:) :: gw real ( kind = R8 ), allocatable , dimension (:) :: tab_dnq real ( kind = R8 ) :: rr integer ( kind = I4 ) :: i , ii , j , jj , k , long_tmp , larg_tmp real ( kind = R8 ), dimension ( 1 : nb_beta ) :: beta real ( kind = R8 ), dimension ( 1 : npp ) :: vec_s real ( kind = R8 ), dimension ( 1 : npp ) :: vec_x ! points coordinates real ( kind = R8 ), dimension ( 1 : npp ) :: vec_y ! points coordinates real ( kind = R8 ) :: asfc1 , asfc2 , aire , hx , hy , hhx , hhy , width , height real ( kind = R8 ) :: xi , yi , eps_x integer ( kind = I4 ) :: it , ng , nbpt integer ( kind = I4 ) :: long , larg integer ( kind = I4 ) :: nb_th long = scal % xres larg = scal % yres if ( out_her ) call get_unit ( unit_out_her ) if ( out_her ) open ( unit = unit_out_her , file = \"out/asfc_her_her_all.txt\" ) width = scal % lx height = scal % ly hx = width / ( long - 1 ) hy = height / ( larg - 1 ) eps_x = min ( hx / 10 ** 3 , hy / 10 ** 3 ) ! définition d'abscisses pour l'interpolation par splines allocate ( x ( 1 : long ), y ( 1 : larg ) ) do i = 1 , long x ( i ) = hx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg y ( j ) = hy * real ( j - 1 , kind = R8 ) enddo allocate ( x_new ( 1 : long ), & ! y_new ( 1 : larg ), & ! tab_ou ( 1 : long , 1 : larg ), & ! tab_in_dx ( 1 : long , 1 : larg ), & ! tab_in_dy ( 1 : long , 1 : larg ), & ! tab_in_xy ( 1 : long , 1 : larg ) ) ! rr = ( real ( long0 , kind = R8 ) / long ) ** ( UN / npp ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points rr = max ( rr , ( real ( larg0 , kind = R8 ) / larg ) ** ( UN / npp ) ) ! facteur de réduction pour aller du maillage initial au maillage minimal avec npp points x_new ( 1 : long ) = x ( 1 : long ) y_new ( 1 : larg ) = y ( 1 : larg ) tab_ou ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call init_aire_hermite ( gx = gx , gy = gy , gw = gw , tab_dnq = tab_dnq , ng = ng ) ! pour chaque réduction de maillage, calcul du maillage résultant et de l'aire relative associée !............................................................. long_new = long larg_new = larg hhx = hx hhy = hy call calcul_aire_hermite ( tab_in = tab_ou ( 1 : long_new , 1 : larg_new ), & ! long = long_new , & ! larg = larg_new , & ! gw = gw ( 1 : ng ), & ! tab_dnq = tab_dnq ( 1 : ng ), & ! ng = ng , & ! hx = hhx , & ! hy = hhy , & ! width = width , & ! height = height , & ! aire = aire ) ! vec_s ( 1 ) = log ( aire ) vec_x ( 1 ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) call calcul_tabd_hermite ( tab_in = tab_in ( 1 : long , 1 : larg ), & ! tab_dx = tab_in_dx ( 1 : long , 1 : larg ), & ! tab_dy = tab_in_dy ( 1 : long , 1 : larg ), & ! tab_xy = tab_in_xy ( 1 : long , 1 : larg ), & ! long = long , & ! larg = larg , & ! hx = hx , & ! hy = hy ) ! nb_th = 1 if ( omp ) then nb_th = omp_get_num_procs () endif !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO ORDERED SCHEDULE (STATIC,1) PRIVATE(it, long_tmp, larg_tmp, long_new, larg_new, hhx, hhy, i, x_new, j, y_new, yi, jj, xi, ii, tab_ou, aire) do it = 1 , npp - 1 long_tmp = nint ( long * ( rr ** it )) ! nb points en suite géométrique larg_tmp = nint ( larg * ( rr ** it )) if ( long_new == long_tmp . or . larg_new == larg_tmp ) then vec_s ( it + 1 ) = 0 cycle ! à découper trop fin, on peut tomber sur les mêmes entiers endif long_new = long_tmp larg_new = larg_tmp hhx = width / ( long_new - 1 ) hhy = height / ( larg_new - 1 ) vec_x ( it + 1 ) = log ( ( hhx * 1e6 ) * ( hhy * 1e6 ) / 2 ) deallocate ( x_new , y_new , tab_ou ) allocate ( x_new ( 1 : long_new ), & ! y_new ( 1 : larg_new ), & ! nouvelles abscisses tab_ou ( 1 : long_new , 1 : larg_new ) ) ! do i = 1 , long_new x_new ( i ) = hhx * real ( i - 1 , kind = R8 ) enddo do j = 1 , larg_new y_new ( j ) = hhy * real ( j - 1 , kind = R8 ) enddo do j = 1 , larg_new yi = y_new ( j ) jj = locate2 ( n = larg , xx = y ( 1 : larg ), x = yi , eps = eps_x ) yi = ( yi - ( y ( jj ) + y ( jj + 1 )) / 2 ) / ( hy / 2 ) do i = 1 , long_new xi = x_new ( i ) ii = locate2 ( n = long , xx = x ( 1 : long ), x = xi , eps = eps_x ) xi = ( xi - ( x ( ii ) + x ( ii + 1 )) / 2 ) / ( hx / 2 ) tab_ou ( i , j ) = & ! nq_i ( xi , yi , 1 , 1 ) * tab_in ( ii , jj ) + & !  u1 nq_i ( xi , yi , 2 , 1 ) * tab_in ( ii + 1 , jj ) + & !  u2 nq_i ( xi , yi , 3 , 1 ) * tab_in ( ii + 1 , jj + 1 ) + & !  u3 nq_i ( xi , yi , 4 , 1 ) * tab_in ( ii , jj + 1 ) + & !  u4 nq_i ( xi , yi , 1 , 2 ) * tab_in_dx ( ii , jj ) * hx / 2 + & ! du1/dx nq_i ( xi , yi , 2 , 2 ) * tab_in_dx ( ii + 1 , jj ) * hx / 2 + & ! du2/dx nq_i ( xi , yi , 3 , 2 ) * tab_in_dx ( ii + 1 , jj + 1 ) * hx / 2 + & ! du3/dx nq_i ( xi , yi , 4 , 2 ) * tab_in_dx ( ii , jj + 1 ) * hx / 2 + & ! du4/dx nq_i ( xi , yi , 1 , 3 ) * tab_in_dy ( ii , jj ) * hy / 2 + & ! du1/dy nq_i ( xi , yi , 2 , 3 ) * tab_in_dy ( ii + 1 , jj ) * hy / 2 + & ! du2/dy nq_i ( xi , yi , 3 , 3 ) * tab_in_dy ( ii + 1 , jj + 1 ) * hy / 2 + & ! du3/dy nq_i ( xi , yi , 4 , 3 ) * tab_in_dy ( ii , jj + 1 ) * hy / 2 + & ! du4/dy nq_i ( xi , yi , 1 , 4 ) * tab_in_xy ( ii , jj ) * hx * hy / 4 + & ! du1/dxdy nq_i ( xi , yi , 2 , 4 ) * tab_in_xy ( ii + 1 , jj ) * hx * hy / 4 + & ! du2/dxdy nq_i ( xi , yi , 3 , 4 ) * tab_in_xy ( ii + 1 , jj + 1 ) * hx * hy / 4 + & ! du3/dxdy nq_i ( xi , yi , 4 , 4 ) * tab_in_xy ( ii , jj + 1 ) * hx * hy / 4 ! du4/dxdy enddo enddo call calcul_aire_hermite ( tab_in = tab_ou ( 1 : long_new , 1 : larg_new ), & ! long = long_new , & ! larg = larg_new , & ! gw = gw ( 1 : ng ), & ! tab_dnq = tab_dnq ( 1 : ng ), & ! ng = ng , & ! hx = hhx , & ! hy = hhy , & ! width = width , & ! height = height , & ! aire = aire ) ! vec_s ( it + 1 ) = log ( aire ) !~          write(unit_out_her, *) vec_x(it+1), vec_s(it+1) enddo !$OMP END DO !$OMP END PARALLEL deallocate ( x_new , y_new , x , y , tab_ou , tab_in_dx , tab_in_dy , tab_in_xy , tab_dnq , gx , gy , gw ) if ( out_lin ) close ( unit_out_lin ) if ( out_her ) close ( unit_out_her ) !............................................................. k = 1 do i = 1 , npp if ( abs ( vec_s ( i )) > EPS_R8 ) then vec_y ( k ) = vec_s ( i ) vec_x ( k ) = vec_x ( i ) k = k + 1 endif enddo nbpt = k - 1 call interpolate_asfc ( bt = beta ( 1 : nb_beta ), & ! n_bt = nb_beta , & ! n_pt = nbpt , & ! asf = asfc1 , & ! r2 = asfc2 ) ! asfc_res = [ - 1000 * asfc1 , asfc2 ] return contains subroutine interpolate_asfc ( bt , n_bt , n_pt , asf , r2 ) !================================================================================================ !< @note Function that fits the data points for the asfc determination.<br/> !        f\\_boltz(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( out ) :: asf !! *Asfc number* real ( kind = R8 ), intent ( out ) :: r2 !! *correlation number to assess validity of the Asfc calculus* real ( kind = R8 ), dimension ( 1 : n_pt , 1 : n_bt ) :: jacob real ( kind = R8 ), dimension ( 1 : n_pt ) :: v_x , v_y , res_y , pentes integer ( kind = I4 ) :: i0 , i , j , info real ( kind = R8 ) :: delta1 , delta2 , y_mean v_x ( 1 : n_pt ) = vec_x ( 1 : n_pt ) ! smoothing v_y ( 1 ) = vec_y ( 1 ) do i = 1 + 1 , n_pt - 1 v_y ( i ) = 0.25_R8 * ( vec_y ( i - 1 ) + 2 * vec_y ( i ) + vec_y ( i + 1 ) ) enddo v_y ( n_pt ) = vec_y ( n_pt ) call init_beta_boltz ( bt = bt ( 1 : n_bt ), & ! n_bt = n_bt , & ! v_x = v_x ( 1 : n_pt ), & ! v_y = v_y ( 1 : n_pt ), & ! n_pt = n_pt ) ! res_y ( 1 : n_pt ) = 0._R8 jacob ( 1 : n_pt , 1 : n_bt ) = 0._R8 call lmder1 ( fcn = lmder1_f , & ! m = n_pt , & ! n = n_bt , & ! x = bt ( 1 : n_bt ), & ! fvec = res_y ( 1 : n_pt ), & ! fjac = jacob ( 1 : n_pt , 1 : n_bt ), & ! ldfjac = n_pt , & ! tol = 1.0e-8_R8 , & ! info = info ) ! delta1 = 0._R8 delta2 = 0._R8 y_mean = sum ( vec_y ( 1 : n_pt ) ) / n_pt do i = 1 , n_pt delta1 = delta1 + ( vec_y ( i ) - f_boltz ( xi = vec_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt ) & ! ) ** 2 delta2 = delta2 + ( vec_y ( i ) - y_mean ) ** 2 enddo r2 = 1._R8 - delta1 / delta2 !~       if (r2<0) then !~       do i=1,n_pt !~       write(99,*) v_x(i), v_y(i) !~       enddo !~       stop 'error' !~       endif i0 = locate ( n = n_pt , & ! xx = v_x ( 1 : n_pt ), & ! x = bt ( 1 )) ! j = 0 do i = i0 - 5 , i0 + 5 if ( i < 1 . or . i > n_pt ) cycle j = j + 1 pentes ( j ) = + df_boltz ( xi = v_x ( i ), & ! beta = bt ( 1 : n_bt ), & ! n_beta = n_bt , & ! ivar = 0 ) ! enddo asf = sum ( pentes ( 1 : j ) / j ) return endsubroutine interpolate_asfc subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !================================================================================================ !< @note Function called by [[lmder1]] as part of **minpack**, modified by !        [Burkardt](https://people.sc.fsu.edu/~jburkardt/f_src/minpack/minpack.html) <br/> !        According *iflag* value it calculates the function [[f_boltz]] at the data points !        or the jacobian. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: m !! *number of points* integer ( kind = I4 ), intent ( in ) :: n !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ldfjac !! *leading dimension of fjac, which must be at least n* integer ( kind = I4 ), intent ( in ) :: iflag !! *which calculus to perform* real ( kind = R8 ), intent ( out ), dimension ( 1 : m ) :: fvec !! *vector of f_boltz(xi)* real ( kind = R8 ), intent ( out ), dimension ( 1 : ldfjac , 1 : n ) :: fjac !! *jacobian* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n ) :: x !! *parameter values* integer ( kind = I4 ) :: i , k select case ( iflag ) case ( 0 ) continue case ( 1 ) do i = 1 , m fvec ( i ) = f_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! n_beta = n ) & ! - vec_y ( i ) enddo case ( 2 ) do i = 1 , m do k = 1 , n fjac ( i , k ) = df_boltz ( xi = vec_x ( i ), & ! beta = x ( 1 : n ), & ! ivar = k , & ! n_beta = n ) ! enddo enddo case default write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop endselect return endsubroutine lmder1_f subroutine init_aire_hermite ( gx , gy , gw , tab_dnq , ng ) !================================================================================================ !< @note ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: gx real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: gy real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: gw real ( kind = R8 ), intent ( out ), allocatable , dimension (:) :: tab_dnq integer ( kind = I4 ), intent ( out ) :: ng real ( kind = R8 ) :: x1 , x2 , y1 , y2 integer ( kind = I4 ) :: i , k , nb_gauss_1d nb_gauss_1d = 2 ng = nb_gauss_1d ** 2 allocate ( gx ( 1 : ng ), gy ( 1 : ng ), gw ( 1 : ng ) ) select case ( nb_gauss_1d ) case ( 1 ) x1 = 0._R8 y1 = 2._R8 gx ( 1 : ng ) = [ x1 ] gy ( 1 : ng ) = [ x1 ] gw ( 1 : ng ) = [ y1 * y1 ] case ( 2 ) x1 = sqrt ( 1._R8 / 3._R8 ) y1 = UN gx ( 1 : ng ) = [ - x1 , - x1 , + x1 , + x1 ] gy ( 1 : ng ) = [ - x1 , + x1 , - x1 , + x1 ] gw ( 1 : ng ) = [ y1 * y1 , y1 * y1 , y1 * y1 , y1 * y1 ] case ( 3 ) x1 = sqrt ( 3._R8 / 5.0_R8 ) x2 = 0._R8 y1 = 5._R8 / 9._R8 y2 = 8._R8 / 9._R8 gx ( 1 : ng ) = [ - x1 , - x1 , - x1 , x2 , x2 , x2 , + x1 , + x1 , + x1 ] gy ( 1 : ng ) = [ - x1 , x2 , + x1 , - x1 , x2 , + x1 , - x1 , x2 , + x1 ] gw ( 1 : ng ) = [ y1 * y1 , y1 * y2 , y1 * y1 , y1 * y2 , y2 * y2 , y1 * y2 , y1 * y1 , y1 * y2 , y1 * y1 ] endselect allocate ( tab_dnq ( 1 : 32 * ng ) ) i = 1 do k = 1 , ng tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 1 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 2 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 3 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_xi_i ( gx ( k ), gy ( k ), 4 , 4 ) ; i = i + 1 !! tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 1 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 2 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 3 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 1 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 2 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 3 , 4 ) ; i = i + 1 tab_dnq ( i ) = dnq_et_i ( gx ( k ), gy ( k ), 4 , 4 ) ; i = i + 1 enddo return endsubroutine init_aire_hermite subroutine calcul_tabd_hermite ( tab_in , tab_dx , tab_dy , tab_xy , long , larg , hx , hy ) !================================================================================================ !< @note ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long integer ( kind = I4 ), intent ( in ) :: larg real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_dx real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_dy real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_xy real ( kind = R8 ), intent ( in ) :: hx real ( kind = R8 ), intent ( in ) :: hy integer ( kind = I4 ) :: i , im , ip , j , jm , jp real ( kind = R8 ) :: ui , uim , uip , ujm , ujp , upp , ump , upm , umm do j = 1 , larg jm = max ( j - 1 , 1 ) jp = min ( j + 1 , larg ) do i = 1 , long im = max ( i - 1 , 1 ) ip = min ( i + 1 , long ) ui = tab_in ( i , j ) uim = tab_in ( im , j ) uip = tab_in ( ip , j ) ujm = tab_in ( i , jm ) ujp = tab_in ( i , jp ) upp = tab_in ( ip , jp ) ump = tab_in ( im , jp ) upm = tab_in ( ip , jm ) umm = tab_in ( im , jm ) tab_dx ( i , j ) = ( uip - uim ) / ( 2 * hx ) tab_dy ( i , j ) = ( ujp - ujm ) / ( 2 * hy ) tab_xy ( i , j ) = ( upp - ump - upm + umm ) / ( 4 * hx * hy ) enddo enddo tab_dx ( 1 , 1 : larg ) = ( tab_in ( 2 , 1 : larg ) - & ! tab_in ( 1 , 1 : larg ) ) / hx ! tab_dx ( long , 1 : larg ) = ( tab_in ( long , 1 : larg ) - & ! tab_in ( long - 1 , 1 : larg ) ) / hx ! tab_dy ( 1 : long , 1 ) = ( tab_in ( 1 : long , 2 ) - & ! tab_in ( 1 : long , 1 ) ) / hy ! tab_dy ( 1 : long , larg ) = ( tab_in ( 1 : long , larg ) - & ! tab_in ( 1 : long , larg - 1 ) ) / hy ! tab_xy ( 1 , 1 : larg ) = ( tab_dy ( 2 , 1 : larg ) - & ! tab_dy ( 1 , 1 : larg ) ) / hx ! tab_xy ( long , 1 : larg ) = ( tab_dy ( long , 1 : larg ) - & ! tab_dy ( long - 1 , 1 : larg ) ) / hx ! tab_xy ( 1 : long , 1 ) = ( tab_dx ( 1 : long , 2 ) - & ! tab_dx ( 1 : long , 1 ) ) / hy ! tab_xy ( 1 : long , larg ) = ( tab_dx ( 1 : long , larg ) - & ! tab_dx ( 1 : long , larg - 1 ) ) / hy ! return endsubroutine calcul_tabd_hermite subroutine calcul_aire_hermite ( tab_in , long , larg , gw , tab_dnq , ng , hx , hy , width , height , aire ) !================================================================================================ !< @note ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long integer ( kind = I4 ), intent ( in ) :: larg integer ( kind = I4 ), intent ( in ) :: ng real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in real ( kind = R8 ), intent ( in ), dimension ( 1 : ng ) :: gw real ( kind = R8 ), intent ( in ), dimension ( 1 : 32 * ng ) :: tab_dnq real ( kind = R8 ), intent ( in ) :: hx real ( kind = R8 ), intent ( in ) :: hy real ( kind = R8 ), intent ( in ) :: width real ( kind = R8 ), intent ( in ) :: height real ( kind = R8 ), intent ( out ) :: aire integer ( kind = I4 ) :: i , j , k , i1 , i2 , j1 , j2 real ( kind = R8 ) :: aire_tmp real ( kind = R8 ), allocatable , dimension (:) :: dfx real ( kind = R8 ), allocatable , dimension (:) :: dfy real ( kind = R8 ), allocatable , dimension (:,:) :: tab_dx ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_dy ! new grid function evaluations real ( kind = R8 ), allocatable , dimension (:,:) :: tab_xy ! new grid function evaluations allocate ( dfx ( 1 : ng ), & ! dfy ( 1 : ng ) ) ! allocate ( tab_dx ( 1 : long , 1 : larg ), & ! tab_dy ( 1 : long , 1 : larg ), & ! tab_xy ( 1 : long , 1 : larg ) ) ! call calcul_tabd_hermite ( tab_in = tab_in ( 1 : long , 1 : larg ), & ! tab_dx = tab_dx ( 1 : long , 1 : larg ), & ! tab_dy = tab_dy ( 1 : long , 1 : larg ), & ! tab_xy = tab_xy ( 1 : long , 1 : larg ), & ! long = long , & ! larg = larg , & ! hx = hx , & ! hy = hy ) ! aire_tmp = 0._R8 do j = 1 , larg - 1 j1 = j ; j2 = j + 1 do i = 1 , long - 1 i1 = i ; i2 = i + 1 do k = 1 , ng dfx ( k ) = ( 2._R8 / hx ) * ( & ! tab_dnq ( 32 * ( k - 1 ) + 01 ) * tab_in ( i1 , j1 ) + & !  u1 tab_dnq ( 32 * ( k - 1 ) + 02 ) * tab_in ( i2 , j1 ) + & !  u2 tab_dnq ( 32 * ( k - 1 ) + 03 ) * tab_in ( i2 , j2 ) + & !  u3 tab_dnq ( 32 * ( k - 1 ) + 04 ) * tab_in ( i1 , j2 ) + & !  u4 tab_dnq ( 32 * ( k - 1 ) + 05 ) * tab_dx ( i1 , j1 ) * hx / 2 + & ! du1/dx tab_dnq ( 32 * ( k - 1 ) + 06 ) * tab_dx ( i2 , j1 ) * hx / 2 + & ! du2/dx tab_dnq ( 32 * ( k - 1 ) + 07 ) * tab_dx ( i2 , j2 ) * hx / 2 + & ! du3/dx tab_dnq ( 32 * ( k - 1 ) + 08 ) * tab_dx ( i1 , j2 ) * hx / 2 + & ! du4/dx tab_dnq ( 32 * ( k - 1 ) + 09 ) * tab_dy ( i1 , j1 ) * hy / 2 + & ! du1/dy tab_dnq ( 32 * ( k - 1 ) + 10 ) * tab_dy ( i2 , j1 ) * hy / 2 + & ! du2/dy tab_dnq ( 32 * ( k - 1 ) + 11 ) * tab_dy ( i2 , j2 ) * hy / 2 + & ! du3/dy tab_dnq ( 32 * ( k - 1 ) + 12 ) * tab_dy ( i1 , j2 ) * hy / 2 + & ! du4/dy tab_dnq ( 32 * ( k - 1 ) + 13 ) * tab_xy ( i1 , j1 ) * hx * hy / 4 + & ! du1/dxdy tab_dnq ( 32 * ( k - 1 ) + 14 ) * tab_xy ( i2 , j1 ) * hx * hy / 4 + & ! du2/dxdy tab_dnq ( 32 * ( k - 1 ) + 15 ) * tab_xy ( i2 , j2 ) * hx * hy / 4 + & ! du3/dxdy tab_dnq ( 32 * ( k - 1 ) + 16 ) * tab_xy ( i1 , j2 ) * hx * hy / 4 ) ! du4/dxdy dfy ( k ) = ( 2._R8 / hy ) * ( & ! tab_dnq ( 32 * ( k - 1 ) + 17 ) * tab_in ( i1 , j1 ) + & !  u1 tab_dnq ( 32 * ( k - 1 ) + 18 ) * tab_in ( i2 , j1 ) + & !  u2 tab_dnq ( 32 * ( k - 1 ) + 19 ) * tab_in ( i2 , j2 ) + & !  u3 tab_dnq ( 32 * ( k - 1 ) + 20 ) * tab_in ( i1 , j2 ) + & !  u4 tab_dnq ( 32 * ( k - 1 ) + 21 ) * tab_dx ( i1 , j1 ) * hx / 2 + & ! du1/dx tab_dnq ( 32 * ( k - 1 ) + 22 ) * tab_dx ( i2 , j1 ) * hx / 2 + & ! du2/dx tab_dnq ( 32 * ( k - 1 ) + 23 ) * tab_dx ( i2 , j2 ) * hx / 2 + & ! du3/dx tab_dnq ( 32 * ( k - 1 ) + 24 ) * tab_dx ( i1 , j2 ) * hx / 2 + & ! du4/dx tab_dnq ( 32 * ( k - 1 ) + 25 ) * tab_dy ( i1 , j1 ) * hy / 2 + & ! du1/dy tab_dnq ( 32 * ( k - 1 ) + 26 ) * tab_dy ( i2 , j1 ) * hy / 2 + & ! du2/dy tab_dnq ( 32 * ( k - 1 ) + 27 ) * tab_dy ( i2 , j2 ) * hy / 2 + & ! du3/dy tab_dnq ( 32 * ( k - 1 ) + 28 ) * tab_dy ( i1 , j2 ) * hy / 2 + & ! du4/dy tab_dnq ( 32 * ( k - 1 ) + 29 ) * tab_xy ( i1 , j1 ) * hx * hy / 4 + & ! du1/dxdy tab_dnq ( 32 * ( k - 1 ) + 30 ) * tab_xy ( i2 , j1 ) * hx * hy / 4 + & ! du2/dxdy tab_dnq ( 32 * ( k - 1 ) + 31 ) * tab_xy ( i2 , j2 ) * hx * hy / 4 + & ! du3/dxdy tab_dnq ( 32 * ( k - 1 ) + 32 ) * tab_xy ( i1 , j2 ) * hx * hy / 4 ) ! du4/dxdy enddo do k = 1 , ng aire_tmp = aire_tmp + gw ( k ) * sqrt ( UN + dfx ( k ) ** 2 + dfy ( k ) ** 2 ) enddo enddo enddo aire = aire_tmp * ( hx / 2 ) * ( hy / 2 ) aire = aire / ( width * height ) deallocate ( tab_dx , & ! tab_dy , & ! tab_xy ) ! deallocate ( dfx , dfy ) return endsubroutine calcul_aire_hermite endsubroutine calcul_asfc_hermite subroutine calcul_asfc ( tab_in , scal , asfc_res , omp ) !================================================================================================ !! Return the *asfc* of a surface regarding the default parameter *method_asfc* implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *surface characteristics* real ( kind = R8 ), intent ( in ), dimension ( 1 : scal % xres , 1 : scal % yres ) :: tab_in !! *input surface* real ( kind = R8 ), intent ( out ), dimension ( 1 : 2 ) :: asfc_res !! *result: asfc, adjustment factor* logical ( kind = I4 ), intent ( in ) :: omp !! *with openmp ?* if ( out_lin ) call get_unit ( unit_out_lin ) if ( out_spl ) call get_unit ( unit_out_spl ) select case ( method_asfc ) case ( lin_all ) call calcul_asfc_lin_all ( tab_in , scal , asfc_res ) case ( spl_all ) call calcul_asfc_spl_all ( tab_in , scal , asfc_res ) case ( hermite ) call calcul_asfc_hermite ( tab_in , scal , asfc_res , omp ) case default stop 'no valid method' endselect return endsubroutine calcul_asfc integer ( kind = I4 ) function locate ( n , xx , x ) !================================================================================================ !< @note Function that returns the location of an element in a vector. !< !< Given an array xx(1: n) , and given a value x , it returns a value j such that x is between !< xx( j ) and xx( j + 1 ). !< !< xx must be monotonic, either increasing or decreasing. j = 0 or j = n is returned to indicate !< that x is out of range. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *vector length* real ( kind = R8 ), intent ( in ) :: x !! *value to locate* real ( kind = R8 ), intent ( in ), dimension ( 1 : n ) :: xx !! *vector* integer ( kind = I4 ) :: jl , jm , ju logical ( kind = I4 ) :: ascnd ascnd = ( xx ( n ) >= xx ( 1 )) !  true if ascending order of table, false otherwise. jl = 0 ! initialize lower ju = n + 1 !  and upper limits. do if ( ju - jl <= 1 ) exit ! repeat until this condition is satisfied. jm = ( ju + jl ) / 2 ! compute a midpoint, if ( ascnd . eqv . ( x >= xx ( jm ))) then jl = jm ! and replace either the lower limit else ju = jm ! or the upper limit, as appropriate. endif enddo if ( x <= xx ( 1 ) ) then ! then set the output, being careful with the endpoints. locate = 1 elseif ( x >= xx ( n ) ) then locate = n - 1 else locate = jl endif return endfunction locate integer ( kind = I4 ) function locate2 ( n , xx , x , eps ) !================================================================================================ !< @note Function that returns the location of an element in a vector. !< !< Given an array xx(1: n) , and given a value x , it returns a value j such that x is between !< xx( j ) and xx( j + 1 ). !< !< xx must be monotonic, either increasing or decreasing. j = 0 or j = n is returned to indicate !< that x is out of range. !< !< The difference with [[locate]] is the use of *eps* for comparisons of reals. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *vector length* real ( kind = R8 ), intent ( in ) :: x !! *value to locate* real ( kind = R8 ), intent ( in ) :: eps !! *small value for comparisons of reals* real ( kind = R8 ), intent ( in ), dimension ( 1 : n ) :: xx !! *vector* integer ( kind = I4 ) :: jl , jm , ju jl = 0 ! initialize lower ju = n + 1 !  and upper limits. do if ( ju - jl <= 1 ) exit ! repeat until this condition is satisfied. jm = ( ju + jl ) / 2 ! compute a midpoint, if ( x - xx ( jm ) > - eps ) then jl = jm ! and replace either the lower limit else ju = jm ! or the upper limit, as appropriate. endif enddo if ( abs ( x - xx ( 1 )) < eps ) then ! then set the output, being careful with the endpoints. locate2 = 1 elseif ( abs ( x - xx ( n )) < eps ) then locate2 = n - 1 else locate2 = jl endif return endfunction locate2 subroutine init_beta_boltz ( bt , n_bt , v_x , v_y , n_pt ) !================================================================================================ !< @note Function that initializes the fitting *tanh* function [[f_boltz]] parameters. !< !<   f_{boltz}(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_bt !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: n_pt !! *data vector length* real ( kind = R8 ), intent ( out ), dimension ( 1 : n_bt ) :: bt !! *vector \\beta of parameters* real ( kind = R8 ), intent ( in ), dimension ( 1 : n_pt ) :: v_x !! *x data to fit* real ( kind = R8 ), intent ( in ), dimension ( 1 : n_pt ) :: v_y !! *y data to fit* real ( kind = R8 ) :: a , pente bt ( 1 ) = 0. !v_x(1) +(v_x(n_pt) -v_x(1))/3 bt ( 2 ) = ( sum ( v_y ( n_pt - 9 : n_pt ) ) + sum ( v_y ( 1 : 10 ) ) ) / ( 2 * 10 ) bt ( 3 ) = ( sum ( v_y ( n_pt - 1 : n_pt ) ) - sum ( v_y ( 1 : 02 ) ) ) / ( 2 * 2 ) !;  a = bt(3) !pente = (v_y(n_pt/2) -v_y(n_pt/4))/(v_x(n_pt/2) -v_x(n_pt/4)) bt ( 4 ) = 1. !a/pente return endsubroutine init_beta_boltz real ( kind = R8 ) function f_boltz ( xi , beta , n_beta ) !================================================================================================ !< @note Fitting function. !< !<   f_{boltz}(x_i)=\\beta_2 + \\beta_3 \\tanh \\left( \\dfrac{x_i -\\beta_1}{\\beta_4} \\right)  !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_beta !! *number of parameters* real ( kind = R8 ), intent ( in ) :: xi !! *data point* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n_beta ) :: beta !! *parameter vector* real ( kind = R8 ) :: x , x0 , y0 , a , b x0 = beta ( 1 ) ; y0 = beta ( 2 ) ; a = beta ( 3 ) ; b = beta ( 4 ) !; c = beta(5) ; d = beta(6) x = xi - x0 f_boltz = y0 + a * tanh ( x / b ) !+c*x +d*x*x return endfunction f_boltz real ( kind = R8 ) function df_boltz ( xi , beta , n_beta , ivar ) !================================================================================================ !! Fitting function partial derivatives. implicit none integer ( kind = I4 ), intent ( in ) :: n_beta !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ivar !! *parameter number* real ( kind = R8 ), intent ( in ) :: xi !! *data point* real ( kind = R8 ), intent ( inout ), dimension ( 1 : n_beta ) :: beta !! *parameter vector* real ( kind = R8 ) :: x0 , y0 , a , b , x , th x0 = beta ( 1 ) ; y0 = beta ( 2 ) ; a = beta ( 3 ) ; b = beta ( 4 ) !; c = beta(5) ; d = beta(6) x = xi - x0 ; th = tanh ( x / b ) select case ( ivar ) case ( 0 ) df_boltz = + ( a / b ) * ( UN - th ** 2 ) !+c +2*d*x  ! special case: derivative regarding xi case ( 1 ) df_boltz = - ( a / b ) * ( UN - th ** 2 ) case ( 2 ) df_boltz = UN case ( 3 ) df_boltz = th case ( 4 ) df_boltz = - ( a * x / b ** 2 ) * ( UN - th ** 2 ) !case(5) !   df_boltz = x !case(6) !   df_boltz = x*x case default stop 'df_boltz, bad choice' endselect return endfunction df_boltz real ( kind = R8 ) function n_i ( xi , i ) !================================================================================================ !! 1D shape function, quadratic case. implicit none real ( kind = R8 ), intent ( in ) :: xi integer ( kind = I4 ), intent ( in ) :: i select case ( i ) case ( 1 ) n_i = 0.250_R8 * ( ( + UN - xi ) ** 2 ) * ( 2._R8 + xi ) case ( 2 ) n_i = 0.250_R8 * ( ( + UN - xi ) ** 2 ) * ( UN + xi ) case ( 3 ) n_i = 0.250_R8 * ( ( + UN + xi ) ** 2 ) * ( 2._R8 - xi ) case ( 4 ) n_i = 0.250_R8 * ( ( + UN + xi ) ** 2 ) * ( - UN + xi ) case default stop 'n_i, bad node ddl' endselect return endfunction n_i real ( kind = R8 ) function dn_i ( xi , i ) !================================================================================================ !! 1D shape function derivative, quadratic case. implicit none real ( kind = R8 ), intent ( in ) :: xi integer ( kind = I4 ), intent ( in ) :: i select case ( i ) case ( 1 ) dn_i = 0.250_R8 * ( - 3 * ( + UN - xi ** 2 ) ) case ( 2 ) dn_i = 0.250_R8 * ( ( + UN - xi ) * ( - UN - 3 * xi )) case ( 3 ) dn_i = 0.250_R8 * ( + 3 * ( + UN - xi ** 2 ) ) case ( 4 ) dn_i = 0.250_R8 * ( ( + UN + xi ) * ( - UN + 3 * xi )) case default stop 'dn_i, bad node ddl' endselect return endfunction dn_i real ( kind = R8 ) function nq_i ( xi , et , i , j ) !================================================================================================ !! 2D shape function, quadratic case. implicit none real ( kind = R8 ), intent ( in ) :: xi , et integer ( kind = I4 ), intent ( in ) :: i , j integer ( kind = I4 ) :: k k = 4 * ( i - 1 ) + j select case ( k ) case ( 1 ) nq_i = n_i ( xi , 1 ) * n_i ( et , 1 ) ! node 1 : u case ( 2 ) nq_i = n_i ( xi , 2 ) * n_i ( et , 1 ) ! node 1 : du/dx case ( 3 ) nq_i = n_i ( xi , 1 ) * n_i ( et , 2 ) ! node 1 : du/dy case ( 4 ) nq_i = n_i ( xi , 2 ) * n_i ( et , 2 ) ! node 1 : d2u/dxdy case ( 5 ) nq_i = n_i ( xi , 3 ) * n_i ( et , 1 ) ! node 2 : u case ( 6 ) nq_i = n_i ( xi , 4 ) * n_i ( et , 1 ) ! node 2 : du/dx case ( 7 ) nq_i = n_i ( xi , 3 ) * n_i ( et , 2 ) ! node 2 : du/dy case ( 8 ) nq_i = n_i ( xi , 4 ) * n_i ( et , 2 ) ! node 2 : d2u/dxdy case ( 9 ) nq_i = n_i ( xi , 3 ) * n_i ( et , 3 ) ! node 3 : u case ( 10 ) nq_i = n_i ( xi , 4 ) * n_i ( et , 3 ) ! node 3 : du/dx case ( 11 ) nq_i = n_i ( xi , 3 ) * n_i ( et , 4 ) ! node 3 : du/dy case ( 12 ) nq_i = n_i ( xi , 4 ) * n_i ( et , 4 ) ! node 3 : d2u/dxdy case ( 13 ) nq_i = n_i ( xi , 1 ) * n_i ( et , 3 ) ! node 4 : u case ( 14 ) nq_i = n_i ( xi , 2 ) * n_i ( et , 3 ) ! node 4 : du/dx case ( 15 ) nq_i = n_i ( xi , 1 ) * n_i ( et , 4 ) ! node 4 : du/dy case ( 16 ) nq_i = n_i ( xi , 2 ) * n_i ( et , 4 ) ! node 4 : d2u/dxdy case default stop 'nq_i, bad node ddl' endselect return endfunction nq_i real ( kind = R8 ) function dnq_xi_i ( xi , et , i , j ) !================================================================================================ !! 2D shape function \\xi derivative, quadratic case. implicit none real ( kind = R8 ), intent ( in ) :: xi , et integer ( kind = I4 ), intent ( in ) :: i , j integer ( kind = I4 ) :: k k = 4 * ( i - 1 ) + j select case ( k ) case ( 1 ) dnq_xi_i = dn_i ( xi , 1 ) * n_i ( et , 1 ) case ( 2 ) dnq_xi_i = dn_i ( xi , 2 ) * n_i ( et , 1 ) case ( 3 ) dnq_xi_i = dn_i ( xi , 1 ) * n_i ( et , 2 ) case ( 4 ) dnq_xi_i = dn_i ( xi , 2 ) * n_i ( et , 2 ) case ( 5 ) dnq_xi_i = dn_i ( xi , 3 ) * n_i ( et , 1 ) case ( 6 ) dnq_xi_i = dn_i ( xi , 4 ) * n_i ( et , 1 ) case ( 7 ) dnq_xi_i = dn_i ( xi , 3 ) * n_i ( et , 2 ) case ( 8 ) dnq_xi_i = dn_i ( xi , 4 ) * n_i ( et , 2 ) case ( 9 ) dnq_xi_i = dn_i ( xi , 3 ) * n_i ( et , 3 ) case ( 10 ) dnq_xi_i = dn_i ( xi , 4 ) * n_i ( et , 3 ) case ( 11 ) dnq_xi_i = dn_i ( xi , 3 ) * n_i ( et , 4 ) case ( 12 ) dnq_xi_i = dn_i ( xi , 4 ) * n_i ( et , 4 ) case ( 13 ) dnq_xi_i = dn_i ( xi , 1 ) * n_i ( et , 3 ) case ( 14 ) dnq_xi_i = dn_i ( xi , 2 ) * n_i ( et , 3 ) case ( 15 ) dnq_xi_i = dn_i ( xi , 1 ) * n_i ( et , 4 ) case ( 16 ) dnq_xi_i = dn_i ( xi , 2 ) * n_i ( et , 4 ) case default stop 'dnq_xi_i, bad node ddl' endselect return endfunction dnq_xi_i real ( kind = R8 ) function dnq_et_i ( xi , et , i , j ) !================================================================================================ !! 2D shape function \\eta derivative, quadratic case. implicit none real ( kind = R8 ), intent ( in ) :: xi , et integer ( kind = I4 ), intent ( in ) :: i , j integer ( kind = I4 ) :: k k = 4 * ( i - 1 ) + j select case ( k ) case ( 1 ) dnq_et_i = n_i ( xi , 1 ) * dn_i ( et , 1 ) case ( 2 ) dnq_et_i = n_i ( xi , 2 ) * dn_i ( et , 1 ) case ( 3 ) dnq_et_i = n_i ( xi , 1 ) * dn_i ( et , 2 ) case ( 4 ) dnq_et_i = n_i ( xi , 2 ) * dn_i ( et , 2 ) case ( 5 ) dnq_et_i = n_i ( xi , 3 ) * dn_i ( et , 1 ) case ( 6 ) dnq_et_i = n_i ( xi , 4 ) * dn_i ( et , 1 ) case ( 7 ) dnq_et_i = n_i ( xi , 3 ) * dn_i ( et , 2 ) case ( 8 ) dnq_et_i = n_i ( xi , 4 ) * dn_i ( et , 2 ) case ( 9 ) dnq_et_i = n_i ( xi , 3 ) * dn_i ( et , 3 ) case ( 10 ) dnq_et_i = n_i ( xi , 4 ) * dn_i ( et , 3 ) case ( 11 ) dnq_et_i = n_i ( xi , 3 ) * dn_i ( et , 4 ) case ( 12 ) dnq_et_i = n_i ( xi , 4 ) * dn_i ( et , 4 ) case ( 13 ) dnq_et_i = n_i ( xi , 1 ) * dn_i ( et , 3 ) case ( 14 ) dnq_et_i = n_i ( xi , 2 ) * dn_i ( et , 3 ) case ( 15 ) dnq_et_i = n_i ( xi , 1 ) * dn_i ( et , 4 ) case ( 16 ) dnq_et_i = n_i ( xi , 2 ) * dn_i ( et , 4 ) case default stop 'dnq_xi_i, bad node ddl' endselect return endfunction dnq_et_i real ( kind = R8 ) function dnq_xi_et_i ( xi , et , i , j ) !================================================================================================ !! 2D shape function \\xi, \\eta derivative, quadratic case. implicit none real ( kind = R8 ), intent ( in ) :: xi , et integer ( kind = I4 ), intent ( in ) :: i , j integer ( kind = I4 ) :: k k = 4 * ( i - 1 ) + j select case ( k ) case ( 1 ) dnq_xi_et_i = dn_i ( xi , 1 ) * dn_i ( et , 1 ) case ( 2 ) dnq_xi_et_i = dn_i ( xi , 2 ) * dn_i ( et , 1 ) case ( 3 ) dnq_xi_et_i = dn_i ( xi , 1 ) * dn_i ( et , 2 ) case ( 4 ) dnq_xi_et_i = dn_i ( xi , 2 ) * dn_i ( et , 2 ) case ( 5 ) dnq_xi_et_i = dn_i ( xi , 3 ) * dn_i ( et , 1 ) case ( 6 ) dnq_xi_et_i = dn_i ( xi , 4 ) * dn_i ( et , 1 ) case ( 7 ) dnq_xi_et_i = dn_i ( xi , 3 ) * dn_i ( et , 2 ) case ( 8 ) dnq_xi_et_i = dn_i ( xi , 4 ) * dn_i ( et , 2 ) case ( 9 ) dnq_xi_et_i = dn_i ( xi , 3 ) * dn_i ( et , 3 ) case ( 10 ) dnq_xi_et_i = dn_i ( xi , 4 ) * dn_i ( et , 3 ) case ( 11 ) dnq_xi_et_i = dn_i ( xi , 3 ) * dn_i ( et , 4 ) case ( 12 ) dnq_xi_et_i = dn_i ( xi , 4 ) * dn_i ( et , 4 ) case ( 13 ) dnq_xi_et_i = dn_i ( xi , 1 ) * dn_i ( et , 3 ) case ( 14 ) dnq_xi_et_i = dn_i ( xi , 2 ) * dn_i ( et , 3 ) case ( 15 ) dnq_xi_et_i = dn_i ( xi , 1 ) * dn_i ( et , 4 ) case ( 16 ) dnq_xi_et_i = dn_i ( xi , 2 ) * dn_i ( et , 4 ) case default stop 'dnq_xi_i, bad node ddl' endselect return endfunction dnq_xi_et_i subroutine indice_fractal ( tab_in , long , larg , indf ) !================================================================================================ !! Function that returns the fractal dimension with the box counting method implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface array length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* real ( kind = R8 ), intent ( out ), dimension ( 3 ) :: indf !! *result: ordinate at origin, slope, R2* integer ( kind = I4 ) :: i , j , k , ib , nbhmax , nni , nb , dec_i , dec_j , ri , rj real ( kind = R8 ) :: lboite , hhmax , hhmin , ddh , t1 , t2 , t3 , t4 , hmax , hmin real ( kind = R8 ) :: yibarr , yi_m_yichap , yi_m_yibarr , r2adj real ( kind = R8 ), dimension ( 1 : 2 ) :: var real ( kind = R8 ), allocatable , dimension (:,:) :: tab , Jf real ( kind = R8 ), allocatable , dimension (:) :: tab_nni integer ( kind = I4 ), allocatable , dimension (:,:) :: pas_i , pas_j integer ( kind = I4 ), allocatable , dimension (:) :: nnb type ( moment_stat ) :: mom call calc_moments ( tab = reshape ( tab_in ( 1 : long , 1 : larg ), [ long * larg ] ), & ! mx = mom , & ! nb_mom = 2 ) ! allocate ( tab ( 1 : long , 1 : larg )) tab ( 1 : long , 1 : larg ) = ( tab_in ( 1 : long , 1 : larg ) - mom % mu ) / mom % si hhmin = minval ( tab ( 1 : long , 1 : larg )) ! hauteur min de la surface tab ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) + hhmin + 1._R8 hhmax = maxval ( tab ( 1 : long , 1 : larg )) ! hauteur max de la surface hhmin = minval ( tab ( 1 : long , 1 : larg )) ! hauteur min de la surface ddh = hhmax - hhmin ! amplitude nbhmax = nint ( log ( UN * min ( long - 1 , larg - 1 ) ) / log ( 2. ) ) ! nbre max de comptages, attention il y a n-1 intervalles pour n points if ( 2 ** nbhmax > min ( long - 1 , larg - 1 )) nbhmax = nbhmax - 1 allocate ( Jf ( 1 : nbhmax , 1 : 2 ) ) allocate ( tab_nni ( 1 : nbhmax ) ) nb = 2 ** nbhmax ! nombre de boîtes dans une direction allocate ( pas_i ( 1 : nb , 1 : nbhmax ), pas_j ( 1 : nb , 1 : nbhmax ) ) allocate ( nnb ( 1 : nb ) ) pas_i = 0 pas_j = 0 pas_i ( 1 : nb , nbhmax ) = ( long - 1 ) / nb ! longueur moyenne d'UN pas selon x (le pas n'est pas forcément constant : nbpts /= 2**n +1, par exemple) pas_j ( 1 : nb , nbhmax ) = ( larg - 1 ) / nb ! id selon y ri = mod ( long - 1 , nb ) ! si la division au-dessus ne tombe pas juste, c'est le reste selon x rj = mod ( larg - 1 , nb ) ! id selon y if ( ri > 0 ) then ! s'il y a un résidu, répartition régulière de ce résidu sur le découpage le plus fin do i = 1 , ri pas_i ( ( i - 1 ) * ( nb / ri ) + 1 , nbhmax ) = pas_i ( ( i - 1 ) * ( nb / ri ) + 1 , nbhmax ) + 1 enddo endif if ( rj > 0 ) then do j = 1 , rj pas_j ( ( j - 1 ) * ( nb / rj ) + 1 , nbhmax ) = pas_j ( ( j - 1 ) * ( nb / rj ) + 1 , nbhmax ) + 1 enddo endif do ib = nbhmax - 1 , 1 , - 1 ! agglomération des pas 2 à 2 pour former le pas de la boîte englobante do k = 1 , 2 ** ib pas_i ( k , ib ) = pas_i ( 2 * ( k - 1 ) + 1 , ib + 1 ) + pas_i ( 2 * k , ib + 1 ) pas_j ( k , ib ) = pas_j ( 2 * ( k - 1 ) + 1 , ib + 1 ) + pas_j ( 2 * k , ib + 1 ) enddo enddo do ib = 1 , nbhmax ! niveau de découpage nb = 2 ** ib ! nombre de boîtes dans une direction pour ce découpage lboite = ( ddh - 2 * EPS_R8 ) / nb ! taille z de la boîte nni = 0 dec_i = 1 do i = 1 , nb ! numéro i de la colonne de boîtes dec_j = 1 do j = 1 , nb ! numéro j de la colonne de boîtes ! on considère le plan résultant de la coupe de la colonne par la surface t1 = tab ( dec_i , dec_j ) t2 = tab ( dec_i + pas_i ( i , ib ), dec_j ) t3 = tab ( dec_i + pas_i ( i , ib ), dec_j + pas_j ( j , ib )) t4 = tab ( dec_i , dec_j + pas_j ( j , ib )) ! ce plan traverse plusieurs boîtes, il suffit de les compter hmax = max ( t1 , t2 , t3 , t4 ) hmin = min ( t1 , t2 , t3 , t4 ) nni = nni + ceiling ( hmax / lboite ) & - floor ( hmin / lboite ) dec_j = dec_j + pas_j ( j , ib ) enddo dec_i = dec_i + pas_i ( i , ib ) enddo tab_nni ( ib ) = log ( UN * nni ) Jf ( ib , 1 ) = UN Jf ( ib , 2 ) = log ( UN / lboite ) enddo call moindres_carres_lineaire ( nb_var = 2 , & ! nb_pts = nbhmax , & ! hij = tab_nni ( 1 : nbhmax ), & ! beta = var ( 1 : 2 ), & ! Jf = Jf ( 1 : nbhmax , 1 : 2 ) ) ! yibarr = sum ( tab_nni ( 1 : nbhmax ) ) / ( nbhmax ) yi_m_yichap = 0 yi_m_yibarr = 0 do i = 1 , nbhmax yi_m_yichap = yi_m_yichap + ( tab_nni ( i ) - ( Jf ( i , 1 ) * var ( 1 ) + Jf ( i , 2 ) * var ( 2 ) ) ) ** 2 yi_m_yibarr = yi_m_yibarr + ( tab_nni ( i ) - yibarr ) ** 2 enddo r2adj = UN - ( yi_m_yichap / ( nbhmax - 2 )) / ( yi_m_yibarr / ( nbhmax - 1 )) indf = [ var ( 2 ), var ( 1 ), r2adj ] ! fractal index first deallocate ( tab , tab_nni , Jf , pas_i , pas_j , nnb ) return endsubroutine indice_fractal endmodule asfc","tags":"","loc":"sourcefile/mod_asfc.f90.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~4~~EfferentGraph sourcefile~prg.f90~4 prg.f90 sourcefile~mod_asfc.f90 mod_asfc.f90 sourcefile~prg.f90~4->sourcefile~mod_asfc.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_asfc.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: may, 03 2019 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Asfc. Example of use** !<  </span> program test_asfc use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use surfile , only : read_surf , SCALE_SURF use asfc , only : calcul_asfc_hermite , indice_fractal use files , only : list_files , clean_scratch implicit none type ( SCALE_SURF ) :: scal_surf !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension (:,:), allocatable :: tab_surf !! *height array* real ( kind = R8 ), dimension ( 1 : 2 ) :: res_asfc !! *result: asfc, adjustment factor* real ( kind = R8 ), dimension ( 1 : 3 ) :: ind_frac !! *result: indice fractal* character ( len = 512 ), allocatable , dimension (:) :: list_sur character ( len = 512 ), allocatable , dimension (:) :: list_sur1 character ( len = 512 ), allocatable , dimension (:) :: list_sur2 integer ( kind = I4 ) :: i_g , n_g , n1_g , n2_g , nx , ny call clean_scratch () call list_files ( dir = \"sur\" , list = list_sur1 , ext = \"sur\" ) call list_files ( dir = \"sur\" , list = list_sur2 , ext = \"SUR\" ) n1_g = ubound ( list_sur1 , 1 ) n2_g = ubound ( list_sur2 , 1 ) n_g = n1_g + n2_g allocate ( list_sur ( 1 : n_g ) ) list_sur ( 1 : n1_g ) = list_sur1 ( 1 : n1_g ) list_sur ( n1_g + 1 : n_g ) = list_sur2 ( 1 : n2_g ) do i_g = 1 , n_g write ( * , * ) '===============================================' write ( * , * ) trim ( list_sur ( i_g ) ) call read_surf ( nom_fic = trim ( list_sur ( i_g ) ), & ! IN mu = 0._R8 , & ! IN , OPT tab_s = tab_surf , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres call calcul_asfc_hermite ( tab_in = tab_surf , & ! scal = scal_surf , & ! asfc_res = res_asfc , & ! omp = . true .) ! call indice_fractal ( tab_in = tab_surf ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! indf = ind_frac ( 1 : 3 ) ) ! write ( * , * ) 'Asfc2 (asfc2 + correlation):             ' , res_asfc ( 1 : 2 ) write ( * , * ) 'Box counting (frac. ind. + correlation): ' , ind_frac ( 1 ), ind_frac ( 3 ) enddo deallocate ( list_sur , list_sur1 , list_sur2 ) endprogram test_asfc","tags":"","loc":"sourcefile/prg.f90~4.html"},{"title":"mod_grad_curv.f90 – TPGLIB","text":"This file depends on sourcefile~~mod_grad_curv.f90~~EfferentGraph sourcefile~mod_grad_curv.f90 mod_grad_curv.f90 sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_grad_curv.f90->sourcefile~mod_filter.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_grad_curv.f90~~AfferentGraph sourcefile~mod_grad_curv.f90 mod_grad_curv.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_grad_curv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: may, 3 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Routines to calculate surface gradients and curvatures** !<  </span> module grad_curv use data_arch , only : I4 , R8 , UN , PI_R8 use sort_arrays , only : sort_array2 use surfile , only : read_surf , write_surf , SCALE_SURF , unit2IUf , init_scal use filter , only : fft_filter use fftw3 , only : fftw_plan_with_nthreads , init_fftw3 , end_fftw3 , PAD_FFT !$ use omp_lib implicit none private public :: gradient , gauss_curv , curv2 , curvature , label_surf_summits , peaks_and_pits_curvatures public :: test_labelize_point , test_label_surf_summits , test_peaks_and_pits_curvatures contains subroutine gradient ( tab , nx , ny , dx , dy , gradx , grady ) !================================================================================================ !< @note Function to calculate the gradient of a 2D array !< !<  It implements the details given in ISO 25178. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *Input 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradx !! *derivative along x 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: grady !! *derivative along y 2D array* integer ( kind = I4 ) :: i , j !------------------------------------------------------------------ GRADX i = 1 gradx ( 1 , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( - 147 * tab ( i + 0 , 1 : ny ) & ! + 360 * tab ( i + 1 , 1 : ny ) & ! - 450 * tab ( i + 2 , 1 : ny ) & ! + 400 * tab ( i + 3 , 1 : ny ) & ! - 225 * tab ( i + 4 , 1 : ny ) & ! + 072 * tab ( i + 5 , 1 : ny ) & ! - 010 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradx ( 2 , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( - 010 * tab ( i + 0 , 1 : ny ) & ! - 077 * tab ( i + 1 , 1 : ny ) & ! + 150 * tab ( i + 2 , 1 : ny ) & ! - 100 * tab ( i + 3 , 1 : ny ) & ! + 050 * tab ( i + 4 , 1 : ny ) & ! - 015 * tab ( i + 5 , 1 : ny ) & ! + 002 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradx ( 3 , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( + 002 * tab ( i + 0 , 1 : ny ) & ! - 024 * tab ( i + 1 , 1 : ny ) & ! - 035 * tab ( i + 2 , 1 : ny ) & ! + 080 * tab ( i + 3 , 1 : ny ) & ! - 030 * tab ( i + 4 , 1 : ny ) & ! + 008 * tab ( i + 5 , 1 : ny ) & ! - 001 * tab ( i + 6 , 1 : ny ) ) ! do i = 4 , nx - 3 gradx ( i , 1 : ny ) = ( UN / ( 60 * dx ) ) * ( + 01 * tab ( i + 3 , 1 : ny ) & ! - 09 * tab ( i + 2 , 1 : ny ) & ! + 45 * tab ( i + 1 , 1 : ny ) & ! - 45 * tab ( i - 1 , 1 : ny ) & ! + 09 * tab ( i - 2 , 1 : ny ) & ! - 01 * tab ( i - 3 , 1 : ny ) ) ! enddo i = nx gradx ( nx , 1 : ny ) = - ( UN / ( 60 * dx ) ) * ( - 147 * tab ( i - 0 , 1 : ny ) & ! + 360 * tab ( i - 1 , 1 : ny ) & ! - 450 * tab ( i - 2 , 1 : ny ) & ! + 400 * tab ( i - 3 , 1 : ny ) & ! - 225 * tab ( i - 4 , 1 : ny ) & ! + 072 * tab ( i - 5 , 1 : ny ) & ! - 010 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradx ( nx - 1 , 1 : ny ) = - ( UN / ( 60 * dx ) ) * ( - 010 * tab ( i - 0 , 1 : ny ) & ! - 077 * tab ( i - 1 , 1 : ny ) & ! + 150 * tab ( i - 2 , 1 : ny ) & ! - 100 * tab ( i - 3 , 1 : ny ) & ! + 050 * tab ( i - 4 , 1 : ny ) & ! - 015 * tab ( i - 5 , 1 : ny ) & ! + 002 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradx ( nx - 2 , 1 : ny ) = - ( UN / ( 60 * dx ) ) * ( + 002 * tab ( i - 0 , 1 : ny ) & ! - 024 * tab ( i - 1 , 1 : ny ) & ! - 035 * tab ( i - 2 , 1 : ny ) & ! + 080 * tab ( i - 3 , 1 : ny ) & ! - 030 * tab ( i - 4 , 1 : ny ) & ! + 008 * tab ( i - 5 , 1 : ny ) & ! - 001 * tab ( i - 6 , 1 : ny ) ) ! !------------------------------------------------------------------ GRADY j = 1 grady ( 1 : nx , 1 ) = ( UN / ( 60 * dy ) ) * ( - 147 * tab ( 1 : nx , j + 0 ) & ! + 360 * tab ( 1 : nx , j + 1 ) & ! - 450 * tab ( 1 : nx , j + 2 ) & ! + 400 * tab ( 1 : nx , j + 3 ) & ! - 225 * tab ( 1 : nx , j + 4 ) & ! + 072 * tab ( 1 : nx , j + 5 ) & ! - 010 * tab ( 1 : nx , j + 6 ) ) ! j = 1 grady ( 1 : nx , 2 ) = ( UN / ( 60 * dy ) ) * ( - 010 * tab ( 1 : nx , j + 0 ) & ! - 077 * tab ( 1 : nx , j + 1 ) & ! + 150 * tab ( 1 : nx , j + 2 ) & ! - 100 * tab ( 1 : nx , j + 3 ) & ! + 050 * tab ( 1 : nx , j + 4 ) & ! - 015 * tab ( 1 : nx , j + 5 ) & ! + 002 * tab ( 1 : nx , j + 6 ) ) ! j = 1 grady ( 1 : nx , 3 ) = ( UN / ( 60 * dy ) ) * ( + 002 * tab ( 1 : nx , j + 0 ) & ! - 024 * tab ( 1 : nx , j + 1 ) & ! - 035 * tab ( 1 : nx , j + 2 ) & ! + 080 * tab ( 1 : nx , j + 3 ) & ! - 030 * tab ( 1 : nx , j + 4 ) & ! + 008 * tab ( 1 : nx , j + 5 ) & ! - 001 * tab ( 1 : nx , j + 6 ) ) ! do j = 4 , ny - 3 grady ( 1 : nx , j ) = ( UN / ( 60 * dy ) ) * ( + 01 * tab ( 1 : nx , j + 3 ) & ! - 09 * tab ( 1 : nx , j + 2 ) & ! + 45 * tab ( 1 : nx , j + 1 ) & ! - 45 * tab ( 1 : nx , j - 1 ) & ! + 09 * tab ( 1 : nx , j - 2 ) & ! - 01 * tab ( 1 : nx , j - 3 ) ) ! enddo j = ny grady ( 1 : nx , ny ) = - ( UN / ( 60 * dy ) ) * ( - 147 * tab ( 1 : nx , j - 0 ) & ! + 360 * tab ( 1 : nx , j - 1 ) & ! - 450 * tab ( 1 : nx , j - 2 ) & ! + 400 * tab ( 1 : nx , j - 3 ) & ! - 225 * tab ( 1 : nx , j - 4 ) & ! + 072 * tab ( 1 : nx , j - 5 ) & ! - 010 * tab ( 1 : nx , j - 6 ) ) ! j = ny grady ( 1 : nx , ny - 1 ) = - ( UN / ( 60 * dy ) ) * ( - 010 * tab ( 1 : nx , j - 0 ) & ! - 077 * tab ( 1 : nx , j - 1 ) & ! + 150 * tab ( 1 : nx , j - 2 ) & ! - 100 * tab ( 1 : nx , j - 3 ) & ! + 050 * tab ( 1 : nx , j - 4 ) & ! - 015 * tab ( 1 : nx , j - 5 ) & ! + 002 * tab ( 1 : nx , j - 6 ) ) ! j = ny grady ( 1 : nx , ny - 2 ) = - ( UN / ( 60 * dy ) ) * ( + 002 * tab ( 1 : nx , j - 0 ) & ! - 024 * tab ( 1 : nx , j - 1 ) & ! - 035 * tab ( 1 : nx , j - 2 ) & ! + 080 * tab ( 1 : nx , j - 3 ) & ! - 030 * tab ( 1 : nx , j - 4 ) & ! + 008 * tab ( 1 : nx , j - 5 ) & ! - 001 * tab ( 1 : nx , j - 6 ) ) ! return endsubroutine gradient subroutine gauss_curv ( gradx , grady , nx , ny , dx , dy , gradxx , gradyy , gradxy ) !================================================================================================ !! Function to calculate the double derivatives of a 2D array implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: gradx !! *derivative along x 2D array* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: grady !! *derivative along y 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradxx !! *double derivative along x, x 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradyy !! *double derivative along y, y 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradxy !! *double derivative along x, y 2D array* call gradient ( tab = gradx ( 1 : nx , 1 : ny ), & ! IN gradx = gradxx ( 1 : nx , 1 : ny ), & ! OUT grady = gradxy ( 1 : nx , 1 : ny ), & ! OUT nx = nx , & ! IN ny = ny , & ! IN dx = dx , & ! IN dy = dy ) ! IN call gradient ( tab = grady ( 1 : nx , 1 : ny ), & !IN gradx = gradxy ( 1 : nx , 1 : ny ), & !OUT grady = gradyy ( 1 : nx , 1 : ny ), & !OUT nx = nx , & !IN ny = ny , & !IN dx = dx , & !IN dy = dy ) !IN return endsubroutine gauss_curv subroutine curv2 ( tab , nx , ny , dx , dy , gradxx , gradyy ) !================================================================================================ !< @note Function to calculate the double derivatives of a 2D array !< !<  It implements the details given in ISO 25178. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *input 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradxx !! *double derivative along x, x 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gradyy !! *double derivative along y, y 2D array* integer ( kind = I4 ) :: i , j !------------------------------------------------------------------ GRADXX i = 1 gradxx ( 1 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0812 * tab ( i + 0 , 1 : ny ) & ! - 3132 * tab ( i + 1 , 1 : ny ) & ! + 5265 * tab ( i + 2 , 1 : ny ) & ! - 5080 * tab ( i + 3 , 1 : ny ) & ! + 2970 * tab ( i + 4 , 1 : ny ) & ! - 0972 * tab ( i + 5 , 1 : ny ) & ! + 0137 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradxx ( 2 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0137 * tab ( i + 0 , 1 : ny ) & ! - 0147 * tab ( i + 1 , 1 : ny ) & ! - 0255 * tab ( i + 2 , 1 : ny ) & ! + 0470 * tab ( i + 3 , 1 : ny ) & ! - 0285 * tab ( i + 4 , 1 : ny ) & ! + 0093 * tab ( i + 5 , 1 : ny ) & ! - 0013 * tab ( i + 6 , 1 : ny ) ) ! i = 1 gradxx ( 3 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( - 0013 * tab ( i + 0 , 1 : ny ) & ! + 0228 * tab ( i + 1 , 1 : ny ) & ! - 0420 * tab ( i + 2 , 1 : ny ) & ! + 0200 * tab ( i + 3 , 1 : ny ) & ! + 0015 * tab ( i + 4 , 1 : ny ) & ! - 0012 * tab ( i + 5 , 1 : ny ) & ! + 0002 * tab ( i + 6 , 1 : ny ) ) ! do i = 4 , nx - 3 gradxx ( i , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 002 * tab ( i + 3 , 1 : ny ) & ! - 027 * tab ( i + 2 , 1 : ny ) & ! + 270 * tab ( i + 1 , 1 : ny ) & ! - 490 * tab ( i , 1 : ny ) & ! + 270 * tab ( i - 1 , 1 : ny ) & ! - 027 * tab ( i - 2 , 1 : ny ) & ! + 002 * tab ( i - 3 , 1 : ny ) ) ! enddo i = nx gradxx ( nx , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0812 * tab ( i - 0 , 1 : ny ) & ! - 3132 * tab ( i - 1 , 1 : ny ) & ! + 5265 * tab ( i - 2 , 1 : ny ) & ! - 5080 * tab ( i - 3 , 1 : ny ) & ! + 2970 * tab ( i - 4 , 1 : ny ) & ! - 0972 * tab ( i - 5 , 1 : ny ) & ! + 0137 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradxx ( nx - 1 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( + 0137 * tab ( i - 0 , 1 : ny ) & ! - 0147 * tab ( i - 1 , 1 : ny ) & ! - 0255 * tab ( i - 2 , 1 : ny ) & ! + 0470 * tab ( i - 3 , 1 : ny ) & ! - 0285 * tab ( i - 4 , 1 : ny ) & ! + 0093 * tab ( i - 5 , 1 : ny ) & ! - 0013 * tab ( i - 6 , 1 : ny ) ) ! i = nx gradxx ( nx - 2 , 1 : ny ) = ( UN / ( 180 * dx ** 2 ) ) * ( - 0013 * tab ( i - 0 , 1 : ny ) & ! + 0228 * tab ( i - 1 , 1 : ny ) & ! - 0420 * tab ( i - 2 , 1 : ny ) & ! + 0200 * tab ( i - 3 , 1 : ny ) & ! + 0015 * tab ( i - 4 , 1 : ny ) & ! - 0012 * tab ( i - 5 , 1 : ny ) & ! + 0002 * tab ( i - 6 , 1 : ny ) ) ! !------------------------------------------------------------------ GRADYY j = 1 gradyy ( 1 : nx , 1 ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0812 * tab ( 1 : nx , j + 0 ) & ! - 3132 * tab ( 1 : nx , j + 1 ) & ! + 5265 * tab ( 1 : nx , j + 2 ) & ! - 5080 * tab ( 1 : nx , j + 3 ) & ! + 2970 * tab ( 1 : nx , j + 4 ) & ! - 0972 * tab ( 1 : nx , j + 5 ) & ! + 0137 * tab ( 1 : nx , j + 6 ) ) ! j = 1 gradyy ( 1 : nx , 2 ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0137 * tab ( 1 : nx , j + 0 ) & ! - 0147 * tab ( 1 : nx , j + 1 ) & ! - 0255 * tab ( 1 : nx , j + 2 ) & ! + 0470 * tab ( 1 : nx , j + 3 ) & ! - 0285 * tab ( 1 : nx , j + 4 ) & ! + 0093 * tab ( 1 : nx , j + 5 ) & ! - 0013 * tab ( 1 : nx , j + 6 ) ) ! j = 1 gradyy ( 1 : nx , 3 ) = ( UN / ( 180 * dy ** 2 ) ) * ( - 0013 * tab ( 1 : nx , j + 0 ) & ! + 0228 * tab ( 1 : nx , j + 1 ) & ! - 0420 * tab ( 1 : nx , j + 2 ) & ! + 0200 * tab ( 1 : nx , j + 3 ) & ! + 0015 * tab ( 1 : nx , j + 4 ) & ! - 0012 * tab ( 1 : nx , j + 5 ) & ! + 0002 * tab ( 1 : nx , j + 6 ) ) ! do j = 4 , ny - 3 gradyy ( 1 : nx , j ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 002 * tab ( 1 : nx , j + 3 ) & ! - 027 * tab ( 1 : nx , j + 2 ) & ! + 270 * tab ( 1 : nx , j + 1 ) & ! - 490 * tab ( 1 : nx , j ) & ! + 270 * tab ( 1 : nx , j - 1 ) & ! - 027 * tab ( 1 : nx , j - 2 ) & ! + 002 * tab ( 1 : nx , j - 3 ) ) ! enddo j = ny gradyy ( 1 : nx , ny ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0812 * tab ( 1 : nx , j - 0 ) & ! - 3132 * tab ( 1 : nx , j - 1 ) & ! + 5265 * tab ( 1 : nx , j - 2 ) & ! - 5080 * tab ( 1 : nx , j - 3 ) & ! + 2970 * tab ( 1 : nx , j - 4 ) & ! - 0972 * tab ( 1 : nx , j - 5 ) & ! + 0137 * tab ( 1 : nx , j - 6 ) ) ! j = ny gradyy ( 1 : nx , ny - 1 ) = ( UN / ( 180 * dy ** 2 ) ) * ( + 0137 * tab ( 1 : nx , j - 0 ) & ! - 0147 * tab ( 1 : nx , j - 1 ) & ! - 0255 * tab ( 1 : nx , j - 2 ) & ! + 0470 * tab ( 1 : nx , j - 3 ) & ! - 0285 * tab ( 1 : nx , j - 4 ) & ! + 0093 * tab ( 1 : nx , j - 5 ) & ! - 0013 * tab ( 1 : nx , j - 6 ) ) ! j = ny gradyy ( 1 : nx , ny - 2 ) = ( UN / ( 180 * dy ** 2 ) ) * ( - 0013 * tab ( 1 : nx , j - 0 ) & ! + 0228 * tab ( 1 : nx , j - 1 ) & ! - 0420 * tab ( 1 : nx , j - 2 ) & ! + 0200 * tab ( 1 : nx , j - 3 ) & ! + 0015 * tab ( 1 : nx , j - 4 ) & ! - 0012 * tab ( 1 : nx , j - 5 ) & ! + 0002 * tab ( 1 : nx , j - 6 ) ) ! return endsubroutine curv2 subroutine curvature ( tab , nx , ny , dx , dy , S_param_grad , S_param_curv , gcurvt ) !================================================================================================ !! Function to calculate the gaussian curvature of a 2D array, !!        its mean quadratic value and the gradient mean quadratic value implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( out ) :: S_param_grad !! *mean quadratic gradient value* real ( kind = R8 ), intent ( out ) :: S_param_curv !! *mean quadratic curvature value* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *input 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx , 1 : ny ) :: gcurvt !! *gaussian curvature  2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradx !! *derivative along x 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: grady !! *derivative along y 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradxx !! *double derivative along x, x 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradyy !! *double derivative along y, y 2D array* real ( kind = R8 ), allocatable , dimension (:,:) :: gradxy !! *double derivative along x, y 2D array* allocate ( gradx ( 1 : nx , 1 : ny ) ) allocate ( grady ( 1 : nx , 1 : ny ) ) allocate ( gradxx ( 1 : nx , 1 : ny ) ) allocate ( gradxy ( 1 : nx , 1 : ny ) ) allocate ( gradyy ( 1 : nx , 1 : ny ) ) call gradient ( tab = tab ( 1 : nx , 1 : ny ), & ! IN nx = nx , & ! IN ny = ny , & ! IN dx = dx , & ! IN dy = dy , & ! IN gradx = gradx ( 1 : nx , 1 : ny ), & ! OUT grady = grady ( 1 : nx , 1 : ny )) ! OUT !~       S_param_grad = sum( sqrt( gradx(1:nx, 1:ny)**2 + grady(1:nx, 1:ny)**2 ) ) / (nx * ny) S_param_grad = sqrt ( sum ( gradx ( 1 : nx , 1 : ny ) ** 2 + grady ( 1 : nx , 1 : ny ) ** 2 ) ) / ( nx * ny ) call gauss_curv ( gradx = gradx ( 1 : nx , 1 : ny ), & ! IN grady = grady ( 1 : nx , 1 : ny ), & ! IN gradxx = gradxx ( 1 : nx , 1 : ny ), & ! OUT gradxy = gradxy ( 1 : nx , 1 : ny ), & ! OUT gradyy = gradyy ( 1 : nx , 1 : ny ), & ! OUT nx = nx , & ! IN ny = ny , & ! IN dx = dx , & ! IN dy = dy ) ! IN gcurvt ( 1 : nx , 1 : ny ) = ( gradxx ( 1 : nx , 1 : ny ) * gradyy ( 1 : nx , 1 : ny ) - gradxy ( 1 : nx , 1 : ny ) ** 2 ) / ( UN + gradx ( 1 : nx , 1 : ny ) ** 2 + grady ( 1 : nx , 1 : ny ) ** 2 ) ** 2 !~       S_param_curv = sum( sqrt( gradxx(1:nx, 1:ny)**2 + gradyy(1:nx, 1:ny)**2 ) ) / (nx * ny) S_param_curv = sqrt ( sum ( gradxx ( 1 : nx , 1 : ny ) ** 2 + gradyy ( 1 : nx , 1 : ny ) ** 2 ) ) / ( nx * ny ) deallocate ( gradx , grady , gradxy , gradxx , gradyy ) return endsubroutine curvature subroutine deriv_N ( x , y , mat_d ) !================================================================================================ !< @note Function to provide the interpolation functions of a QU9 element, as well as its derivatives !< !<  It implements the details given in code ASTER r3.01.01.pdf doc !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: x !! *abscissa between -1 and +1* real ( kind = R8 ), intent ( in ) :: y !! *ordinate between -1 and +1* real ( kind = R8 ), intent ( out ), dimension ( 1 : 9 , 1 : 6 ) :: mat_d !! *array containing N, dN/di, d2N/di2* real ( kind = R8 ) :: xm1 , xp1 , xm12 , xp12 , umx2 , dxm1 , dxp1 , xy real ( kind = R8 ) :: ym1 , yp1 , ym12 , yp12 , umy2 , dyp1 , dym1 xm1 = x - 1 ; xp1 = x + 1 ; xm12 = x - 1 / 2._R8 ; xp12 = x + 1 / 2._R8 ; umx2 = 1 - x ** 2 ; dxm1 = 2 * x - 1 ; dxp1 = 2 * x + 1 ; xy = x * y ym1 = y - 1 ; yp1 = y + 1 ; ym12 = y - 1 / 2._R8 ; yp12 = y + 1 / 2._R8 ; umy2 = 1 - y ** 2 ; dym1 = 2 * y - 1 ; dyp1 = 2 * y + 1 !     Nodes order: ! !     4---7---3 !     |   |   | !     8---9-- 6 !     |   |   | !     1---5---2 !     mat_d(1:6, .) = [ N(1:9), dNdx(1:9), dNdy(1:9), d2Ndx2(1:9), d2Ndxdy(1:9), d2Ndy2(1:9) ] mat_d ( 1 : 9 , 1 ) = [ xy * xm1 * ym1 / 4 , & ! 1 xy * xp1 * ym1 / 4 , & ! 2 xy * xp1 * yp1 / 4 , & ! 3 xy * xm1 * yp1 / 4 , & ! 4 y * umx2 * ym1 / 2 , & ! 5 x * umy2 * xp1 / 2 , & ! 6 y * umx2 * yp1 / 2 , & ! 7 x * umy2 * xm1 / 2 , & ! 8 umx2 * umy2 ] ! 9 mat_d ( 1 : 9 , 2 ) = [ dxm1 * y * ym1 / 4 , & ! 1 dxp1 * y * ym1 / 4 , & ! 2 dxp1 * y * yp1 / 4 , & ! 3 dxm1 * y * yp1 / 4 , & ! 4 - xy * ym1 , & ! 5 dxp1 * umy2 / 2 , & ! 6 - xy * yp1 , & ! 7 dxm1 * umy2 / 2 , & ! 8 - 2 * x * umy2 ] ! 9 mat_d ( 1 : 9 , 3 ) = [ x * xm1 * dym1 / 4 , & ! 1 x * xp1 * dym1 / 4 , & ! 2 x * xp1 * dyp1 / 4 , & ! 3 x * xm1 * dyp1 / 4 , & ! 4 umx2 * dym1 / 2 , & ! 5 - xy * xp1 , & ! 6 umx2 * dyp1 / 2 , & ! 7 - xy * xm1 , & ! 8 - 2 * y * umx2 ] ! 9 mat_d ( 1 : 9 , 4 ) = [ y * ym1 / 2 , & ! 1 y * ym1 / 2 , & ! 2 y * yp1 / 2 , & ! 3 y * yp1 / 2 , & ! 4 - y * ym1 , & ! 5 umy2 , & ! 6 - y * yp1 , & ! 7 umy2 , & ! 8 - 2 * umy2 ] ! 9 mat_d ( 1 : 9 , 5 ) = [ xm12 * ym12 , & ! 1 xp12 * ym12 , & ! 2 xp12 * yp12 , & ! 3 xm12 * yp12 , & ! 4 - x * dym1 , & ! 5 - y * dxp1 , & ! 6 - x * dyp1 , & ! 7 - y * dxm1 , & ! 8 + 4 * xy ] ! 9 mat_d ( 1 : 9 , 6 ) = [ x * xm1 / 2 , & ! 1 x * xp1 / 2 , & ! 2 x * xp1 / 2 , & ! 3 x * xm1 / 2 , & ! 4 + umx2 , & ! 5 - x * xp1 , & ! 6 + umx2 , & ! 7 - x * xm1 , & ! 8 - 2 * umx2 ] ! 9 return endsubroutine deriv_N subroutine gradient_corner ( hgt , gdx , gdy ) !================================================================================================ !< @note Function that gives the nodal height gradients !< !< gdx : (2,1)----(2,2)----(2,3) : QU9 notation !< !< gdy : (1,2)----(2,2)----(3,2) : QU9 notation !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 , 1 : 3 ) :: hgt !! *local height 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : 3 ) :: gdx !! *nodal x gradient* real ( kind = R8 ), intent ( out ), dimension ( 1 : 3 ) :: gdy !! *nodal x gradient* !~       real(kind=R8), dimension(1:9) :: tab !~       tab(1:9) = [ hgt(1, 1), & 1 !  (3,1)----(3,2)----(3,3) !~                    hgt(1, 3), & 2 !    |        |        | !~                    hgt(3, 3), & 3 !    |        |        | !~                    hgt(3, 1), & 4 !  (2,1)----(2,2)----(2,3) !~                    hgt(1, 2), & 5 !    |        |        | !~                    hgt(2, 3), & 6 !    |        |        | !~                    hgt(3, 2), & 7 !  (1,1)----(1,2)----(1,3) !~                    hgt(2, 1), & 8 ! !~                    hgt(2, 2) ]  9 ! ! (3,1)----(3,2)----(3,3) !   |        |        | !   |        |        | ! (2,1)----(2,2)----(2,3) !   |        |        | !   |        |        | ! (1,1)----(1,2)----(1,3) gdx ( 1 : 3 ) = [ - 1.5_R8 * hgt ( 2 , 1 ), & ! + 0.0_R8 * hgt ( 2 , 2 ), & ! + 1.5_R8 * hgt ( 2 , 3 ) ] ! gdy ( 1 : 3 ) = [ - 1.5_R8 * hgt ( 1 , 2 ), & ! + 0.0_R8 * hgt ( 2 , 2 ), & ! + 1.5_R8 * hgt ( 3 , 2 ) ] ! !~       gdx(1:9) = [ -1.5_R8 * tab(1), &  ! !~                    +1.5_R8 * tab(2), &  ! !~                    +1.5_R8 * tab(3), &  ! !~                    -1.5_R8 * tab(4), &  ! !~                    +0.0_R8 * tab(5), &  ! !~                    +1.5_R8 * tab(6), &  ! !~                    +0.0_R8 * tab(7), &  ! !~                    -1.5_R8 * tab(8), &  ! !~                    +0.0_R8 * tab(9) ]   ! !~       gdy(1:9) = [ -1.5_R8 * tab(1), &  ! !~                    -1.5_R8 * tab(2), &  ! !~                    +1.5_R8 * tab(3), &  ! !~                    +1.5_R8 * tab(4), &  ! !~                    -1.5_R8 * tab(5), &  ! !~                    +0.0_R8 * tab(6), &  ! !~                    +1.5_R8 * tab(7), &  ! !~                    +0.0_R8 * tab(8), &  ! !~                    +0.0_R8 * tab(9) ]   ! return endsubroutine gradient_corner subroutine labelize_point ( height , label , x , y ) !================================================================================================ !! Function to label a point as: peak, valley, saddle or nothing particular implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 , 1 : 3 ) :: height !! *nodal height values as a 2D array* character ( len = 1 ), intent ( out ) :: label !! *kind of point* real ( kind = R8 ), intent ( out ), optional :: x , y !! *coordinates of the extremum found* real ( kind = R8 ), dimension ( 1 : 9 ) :: tab real ( kind = R8 ), dimension ( 1 : 9 , 1 : 6 ) :: derivatives real ( kind = R8 ) :: h , dhdx , dhdy , d2hdx2 , d2hdy2 , d2hdxdy , delta , dx , dy real ( kind = R8 ) :: xs , ys real ( kind = R8 ), parameter :: eps = 1.0e-8_R8 integer ( kind = I4 ) :: k , status ! following QU9 node notation: tab ( 1 : 9 ) = [ height ( 1 , 1 ), & !  (3,1)----(3,2)----(3,3) height ( 1 , 3 ), & !    |        |        | height ( 3 , 3 ), & !    |        |        | height ( 3 , 1 ), & !  (2,1)----(2,2)----(2,3) height ( 1 , 2 ), & !    |        |        | height ( 2 , 3 ), & !    |        |        | height ( 3 , 2 ), & !  (1,1)----(1,2)----(1,3) height ( 2 , 1 ), & ! height ( 2 , 2 ) ] ! ! Newton Raphson to locate the null first derivatives, which means an extremum ! Intiate with the center of the square [-1,1]X[-1,1] and initalize the counting ! xs = 0 ; ys = 0 ; k = 0 do ! for the current coordinates, what are the surface height and its derivatives: call deriv_N ( x = xs , y = ys , mat_d = derivatives ( 1 : 9 , 1 : 6 )) dhdx = sum ( derivatives ( 1 : 9 , 2 ) * tab ( 1 : 9 ) ) dhdy = sum ( derivatives ( 1 : 9 , 3 ) * tab ( 1 : 9 ) ) d2hdx2 = sum ( derivatives ( 1 : 9 , 4 ) * tab ( 1 : 9 ) ) d2hdxdy = sum ( derivatives ( 1 : 9 , 5 ) * tab ( 1 : 9 ) ) d2hdy2 = sum ( derivatives ( 1 : 9 , 6 ) * tab ( 1 : 9 ) ) ! jacobian denominator delta = d2hdx2 * d2hdy2 - d2hdxdy ** 2 if ( abs ( dhdx ) < eps . and . abs ( dhdy ) < eps ) then ! converge ok status = 0 ! extremum found, whatever its kind exit ! nothing more to do endif if ( abs ( xs ) >= 5._R8 . or . abs ( ys ) >= 5._R8 ) then ! during the convergence process, the point is far from the square, so exit status = 1 ! with the appropriate status exit ! endif ! k = k + 1 if ( k > 1000 ) then ! limit the number of iterations status = 1 exit endif dx = ( - 1. / delta ) * ( + d2hdy2 * dhdx - d2hdxdy * dhdy ) dy = ( - 1. / delta ) * ( - d2hdxdy * dhdx + d2hdx2 * dhdy ) xs = xs + 0.9 * dx ys = ys + 0.9 * dy enddo ! outside the square [-0.5,0.5]X[-0.5,0.5] the extremum belongs to another node if ( abs ( xs ) > 0.5_R8 . or . abs ( ys ) > 0.5_R8 ) status = 1 ! if derivatives are null, what kind of point is it ? !     Nodes order: ! !     4---7---3 !     |   |   | !     8---9-- 6 !     |   |   | !     1---5---2 if ( status == 0 ) then call deriv_N ( x = xs , y = ys , mat_d = derivatives ( 1 : 9 , 1 : 6 )) ! height at the extremum point xs, ys h = sum ( derivatives ( 1 : 9 , 1 ) * tab ( 1 : 9 ) ) if ( all ( tab ( 1 : 8 ) >= h ) ) then ; label = 'V' ! valley or pit elseif ( all ( tab ( 1 : 8 ) <= h ) ) then ; label = 'P' ! hill or peak else ; label = 'S' ! saddle endif else label = 'N' ! nothing particular endif if ( present ( x ) ) then x = xs y = ys endif return endsubroutine labelize_point subroutine label_surf_summits ( tab , nx , ny , valleys , peaks , saddles , nb_summits ) !================================================================================================ !! Function to output the extrema of a 2D array, as peaks, valleys or saddles. implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab !! *input 2D array* integer ( kind = I4 ), intent ( out ), dimension ( 1 : 3 ) :: nb_summits !! *number of extrema of each kind* integer ( kind = I4 ), intent ( out ), dimension (:,:), allocatable :: valleys !! *list of valley coordinates* integer ( kind = I4 ), intent ( out ), dimension (:,:), allocatable :: peaks !! *list of peaks coordinates* integer ( kind = I4 ), intent ( out ), dimension (:,:), allocatable :: saddles !! *list of saddles coordinates* integer ( kind = I4 ) :: i , j integer ( kind = I4 ) :: ip ! peak counter integer ( kind = I4 ) :: iv ! valley counter integer ( kind = I4 ) :: is ! saddle counter character ( len = 1 ) :: label integer ( kind = I4 ), dimension ( 1 : 3 , 1 : 3 ) :: tp integer ( kind = I4 ), dimension (:,:), allocatable :: topo ! point kind 2D array real ( kind = R8 ), dimension ( 1 : 3 , 1 : 3 ) :: ht real ( kind = R8 ), dimension ( 1 : 3 ) :: gdx , gdy ! gradient vectors allocate ( topo ( 1 : nx , 1 : ny ) ) topo ( 1 : nx , 1 : ny ) = 0 ! Loop through each point in the surface ip = 1 ; iv = 1 ; is = 1 do i = 1 + 1 , nx - 1 do j = 1 + 1 , ny - 1 tp ( 1 : 3 , 1 : 3 ) = topo ( i - 1 : i + 1 , j - 1 : j + 1 ) ht ( 1 : 3 , 1 : 3 ) = tab ( i - 1 : i + 1 , j - 1 : j + 1 ) ! if the gradients along x (resp. y) have the same sign, there is no extremum in the middle node call gradient_corner ( hgt = ht ( 1 : 3 , 1 : 3 ), & ! in gdx = gdx ( 1 : 3 ), & ! out gdy = gdy ( 1 : 3 ) ) ! out !~             if ( all( [gdx(6) > 0, gdx(8) > 0, gdx(9) > 0] ) .or. all( [gdy(5) > 0, gdy(7) > 0, gdy(9) > 0] ) ) cycle !~             if ( all( [gdx(6) > 0, gdx(8) > 0, gdx(9) > 0] ) .or. all( [gdy(5) < 0, gdy(7) < 0, gdy(9) < 0] ) ) cycle !~             if ( all( [gdx(6) < 0, gdx(8) < 0, gdx(9) < 0] ) .or. all( [gdy(5) < 0, gdy(7) < 0, gdy(9) < 0] ) ) cycle !~             if ( all( [gdx(6) < 0, gdx(8) < 0, gdx(9) < 0] ) .or. all( [gdy(5) > 0, gdy(7) > 0, gdy(9) > 0] ) ) cycle if ( all ( gdx ( 1 : 3 ) > 0 ) . or . all ( gdy ( 1 : 3 ) > 0 ) ) cycle if ( all ( gdx ( 1 : 3 ) > 0 ) . or . all ( gdy ( 1 : 3 ) < 0 ) ) cycle if ( all ( gdx ( 1 : 3 ) < 0 ) . or . all ( gdy ( 1 : 3 ) < 0 ) ) cycle if ( all ( gdx ( 1 : 3 ) < 0 ) . or . all ( gdy ( 1 : 3 ) > 0 ) ) cycle ! condition to avoid summits glued to each other: if a summit has been found in the neighborhood, cycle. if ( any ( [ tp ( 1 , 1 ) > 0 , & ! tp ( 1 , 2 ) > 0 , & ! tp ( 1 , 3 ) > 0 , & ! tp ( 2 , 1 ) > 0 ] ) ) cycle call labelize_point ( height = ht ( 1 : 3 , 1 : 3 ), & ! in label = label ) ! out selectcase ( label ) case ( 'V' ) ; topo ( i , j ) = 1 ; iv = iv + 1 ! one valley more detected case ( 'S' ) ; topo ( i , j ) = 2 ; is = is + 1 ! one saddle more detected case ( 'P' ) ; topo ( i , j ) = 3 ; ip = ip + 1 ! one peak   more detected endselect enddo enddo nb_summits = [ iv - 1 , is - 1 , ip - 1 ] ! now the number of extrema is known allocate ( valleys ( 1 : nb_summits ( 1 ), 1 : 2 ) ) allocate ( saddles ( 1 : nb_summits ( 2 ), 1 : 2 ) ) allocate ( peaks ( 1 : nb_summits ( 3 ), 1 : 2 ) ) ip = 1 ; iv = 1 ; is = 1 do i = 1 + 1 , nx - 1 do j = 1 + 1 , ny - 1 selectcase ( topo ( i , j ) ) case ( 1 ) ; valleys ( iv , 1 ) = i ; valleys ( iv , 2 ) = j ; iv = iv + 1 case ( 2 ) ; saddles ( is , 1 ) = i ; saddles ( is , 2 ) = j ; is = is + 1 case ( 3 ) ; peaks ( ip , 1 ) = i ; peaks ( ip , 2 ) = j ; ip = ip + 1 endselect enddo enddo deallocate ( topo ) return endsubroutine label_surf_summits subroutine peaks_and_pits_curvatures ( heights , nx , ny , dx , dy , S_param_grad , S_param_curv , peak_curv , pits_curv ) !================================================================================================ !! Function to calculate and output the peaks and pits curvatures as well as then mean quadratic !!        gradient value and the mean quadratic curvature value. implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along x* real ( kind = R8 ), intent ( in ) :: dx !! *x lag* real ( kind = R8 ), intent ( in ) :: dy !! *y lag* real ( kind = R8 ), intent ( out ) :: peak_curv !! *3 first peaks mean curvature* real ( kind = R8 ), intent ( out ) :: pits_curv !! *3 first pits  mean curvature* real ( kind = R8 ), intent ( out ) :: S_param_grad !! *mean quadratic gradient value* real ( kind = R8 ), intent ( out ) :: S_param_curv !! *mean quadratic curvature value* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: heights !! *input 2D array* integer ( kind = I4 ) :: i , npeak , npits real ( kind = R8 ) :: spg , spc , adim integer ( kind = I4 ), allocatable , dimension (:,:) :: vall , peak , sadd integer ( kind = I4 ), dimension ( 1 : 3 ) :: nb_extr real ( kind = R8 ), dimension ( 1 : nx * ny ) :: tpits real ( kind = R8 ), dimension ( 1 : nx * ny ) :: tpeak real ( kind = R8 ), allocatable , dimension (:,:) :: cvt allocate ( cvt ( 1 : nx , 1 : ny ) ) ! first determine the surface curvature call curvature ( tab = heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in S_param_grad = spg , & ! out S_param_curv = spc , & ! out gcurvt = cvt ( 1 : nx , 1 : ny )) ! out ! OUTPUT S_param_grad = spg S_param_curv = spc ! no need to carry very high/low values, so normalize curvature adim = maxval ( abs ( cvt ( 1 : nx , 1 : ny )) ) cvt ( 1 : nx , 1 : ny ) = cvt ( 1 : nx , 1 : ny ) / adim call label_surf_summits ( tab = cvt ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in valleys = vall , & ! out peaks = peak , & ! out saddles = sadd , & ! out nb_summits = nb_extr ( 1 : 3 )) ! out !..................................................... npits = nb_extr ( 1 ) do i = 1 , npits tpits ( i ) = cvt ( vall ( i , 1 ), vall ( i , 2 ) ) ! first values needed, so ascending sort is OK enddo call sort_array2 ( tab_inout = tpits ( 1 : npits ), & ! inout n = npits ) ! in ! OUTPUT pits_curv = adim * sum ( tpits ( 1 : 3 ) ) / 3. ! mean of first 3 values, with the right dimension !..................................................... npeak = nb_extr ( 3 ) do i = 1 , npeak tpeak ( i ) = - cvt ( peak ( i , 1 ), peak ( i , 2 ) ) ! top values of peak needed, so reverse for ascending sort enddo call sort_array2 ( tab_inout = tpeak ( 1 : npeak ), & ! inout n = npeak ) ! in ! OUTPUT peak_curv = - adim * sum ( tpeak ( 1 : 3 ) ) / 3 ! mean of first 3 values, with the right dimension and the right sign deallocate ( cvt , vall , peak , sadd ) return endsubroutine peaks_and_pits_curvatures subroutine test_labelize_point () !================================================================================================ !! Function to test the function \"labelize_point\" on a QU9 domain with a 2nd order polynomial !!        along x and y implicit none real ( kind = R8 ) :: x , y , x0 , y0 real ( kind = R8 ) :: aax , aay character ( len = 1 ) :: point_kind , label real ( kind = R8 ), parameter :: xx0 = - 0.1_R8 , fxx0 = + 2._R8 real ( kind = R8 ), parameter :: yy0 = + 0.2_R8 , fyy0 = + 1._R8 real ( kind = R8 ), dimension ( 1 : 9 ) :: Ni , dNidx , dNidy , d2Nidx2 , d2Nidxdy , d2Nidy2 , tab real ( kind = R8 ), dimension ( 1 : 9 , 1 : 6 ) :: derivatives real ( kind = R8 ), dimension ( 1 : 3 , 1 : 3 ) :: height ! select what kind of point to check point_kind = 'S' selectcase ( point_kind ) case ( 'V' ) ; aax = + 1._R8 ; aay = + 1._R8 case ( 'P' ) ; aax = - 1._R8 ; aay = - 1._R8 case ( 'S' ) ; aax = + 1._R8 ; aay = - 1._R8 case default ; stop endselect ! \"tab\" is given row wise: !     Nodes order: ! !     4---7---3 !     |   |   | !     8---9-- 6 !     |   |   | !     1---5---2 ! tab ( 1 : 9 ) = [ f ( x = - 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = - 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 1 f ( x = + 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = - 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 5 f ( x = + 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = + 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 2 f ( x = - 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = + 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 8 f ( x = 0._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = - 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 9 f ( x = + 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = 0._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 6 f ( x = 0._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = + 1._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 4 f ( x = - 1._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = 0._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ), & ! 7 f ( x = 0._R8 , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = 0._R8 , x0 = yy0 , a = aay , fx0 = fyy0 ) ] ! 3 ! stack is done column wise for reshape height ( 1 : 3 , 1 : 3 ) = reshape ( [ tab ( 1 ), & ! tab ( 8 ), & ! tab ( 4 ), & ! tab ( 5 ), & ! tab ( 9 ), & ! tab ( 7 ), & ! tab ( 2 ), & ! tab ( 6 ), & ! tab ( 3 ) ], [ 3 , 3 ] ) ! random point to compare the analytic function to the quadratic approx x = - 0.35_R8 y = + 0.52_R8 call deriv_N ( x = x , y = y , mat_d = derivatives ( 1 : 9 , 1 : 6 )) Ni ( 1 : 9 ) = derivatives ( 1 : 9 , 1 ) dNidx ( 1 : 9 ) = derivatives ( 1 : 9 , 2 ) dNidy ( 1 : 9 ) = derivatives ( 1 : 9 , 3 ) d2Nidx2 ( 1 : 9 ) = derivatives ( 1 : 9 , 4 ) d2Nidxdy ( 1 : 9 ) = derivatives ( 1 : 9 , 5 ) d2Nidy2 ( 1 : 9 ) = derivatives ( 1 : 9 , 6 ) write ( * , * ) 'numerical h      : ' , sum ( tab * Ni ) , ' ; theoretical h      : ' , f ( x = x , x0 = xx0 , a = aax , fx0 = fxx0 ) * f ( x = y , x0 = yy0 , a = aay , fx0 = fyy0 ) write ( * , * ) 'numerical dhdx   : ' , sum ( tab * dNidx ) , ' ; theoretical dhdx   : ' , df ( x = x , x0 = xx0 , a = aax ) * f ( x = y , x0 = yy0 , a = aay , fx0 = fyy0 ) write ( * , * ) 'numerical dhdy   : ' , sum ( tab * dNidy ) , ' ; theoretical dhdy   : ' , f ( x = x , x0 = xx0 , a = aax , fx0 = fxx0 ) * df ( x = y , x0 = yy0 , a = aay ) write ( * , * ) 'numerical d2hdx2 : ' , sum ( tab * d2Nidx2 ) , ' ; theoretical d2hdx2 : ' , d2f ( a = aax ) * f ( x = y , x0 = yy0 , a = aay , fx0 = fyy0 ) write ( * , * ) 'numerical d2hdy2 : ' , sum ( tab * d2Nidy2 ) , ' ; theoretical d2hdy2 : ' , f ( x = x , x0 = xx0 , a = aax , fx0 = fxx0 ) * d2f ( a = aay ) write ( * , * ) 'numerical d2hdxdy: ' , sum ( tab * d2Nidxdy ) , ' ; theoretical d2hdxdy: ' , df ( x = x , x0 = xx0 , a = aax ) * df ( x = y , x0 = yy0 , a = aay ) !=========================================== call labelize_point ( height = height ( 1 : 3 , 1 : 3 ), label = label , x = x0 , y = y0 ) write ( * , * ) 'theoretical xx0: ' , xx0 , 'numerical xx0: ' , x0 write ( * , * ) 'theoretical yy0: ' , yy0 , 'numerical yy0: ' , y0 write ( * , * ) 'theoretical point: ' , point_kind , ' numerical point: ' , label contains real ( kind = R8 ) function f ( x , x0 , a , fx0 ) implicit none real ( kind = R8 ), intent ( in ) :: x real ( kind = R8 ), intent ( in ) :: x0 real ( kind = R8 ), intent ( in ) :: a real ( kind = R8 ), intent ( in ) :: fx0 real ( kind = R8 ) :: b , c ! 2nd order polynomial defined by: ! ->   a : +1 or -1 (curvature sign) ! ->  x0 : the extremum abscissa ! -> fx0 : the extremum value b = - 2 * a * x0 c = fx0 + a * x0 ** 2 f = a * x ** 2 + b * x + c return endfunction f real ( kind = R8 ) function df ( x , x0 , a ) implicit none real ( kind = R8 ), intent ( in ) :: x real ( kind = R8 ), intent ( in ) :: x0 real ( kind = R8 ), intent ( in ) :: a real ( kind = R8 ) :: b b = - 2 * a * x0 df = 2 * a * x + b return endfunction df real ( kind = R8 ) function d2f ( a ) implicit none real ( kind = R8 ), intent ( in ) :: a d2f = 2 * a return endfunction d2f endsubroutine test_labelize_point subroutine test_label_surf_summits () !================================================================================================ !! Function to test the capicity in detecting peaks, pits and saddles in a simple double sinus !!        surface. implicit none integer ( kind = I4 ), allocatable , dimension (:,:) :: topo integer ( kind = I4 ), allocatable , dimension (:,:) :: vall , peak , sadd real ( kind = R8 ), allocatable , dimension (:,:) :: heights integer ( kind = I4 ), dimension ( 1 : 3 ) :: nb_null_derivatives integer ( kind = I4 ), parameter :: nx = 750 , ny = 1000 integer ( kind = I4 ) :: i , j , i1 , j1 type ( SCALE_SURF ) :: scal ! create a \"digital surf\" object call init_scal ( scal = scal , & ! out; creates a surface type, containing ... nx = nx , & !  in; ... the number of points along x ... ny = ny , & !  in; ... the number of points along y ... lx = nx * 1.e-6_R8 , & !  in; ... the length (default unit : m) ... ly = ny * 1.e-6_R8 , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. allocate ( heights ( 1 : nx , 1 : ny ) ) allocate ( topo ( 1 : nx , 1 : ny ) ) do i = 1 , nx do j = 1 , ny heights ( i , j ) = sinsin ( i , j , nx , ny ) enddo enddo call write_surf ( nom_fic = \"out/test_sinus.sur\" , & ! tab_s = heights ( 1 : nx , 1 : ny ), & ! scal = scal ) ! call label_surf_summits ( tab = heights ( 1 : nx , 1 : ny ), & ! nx = nx , & ! ny = ny , & ! valleys = vall , & ! peaks = peak , & ! saddles = sadd , & ! nb_summits = nb_null_derivatives ( 1 : 3 ) ) ! write ( * , * ) nb_null_derivatives ( 1 : 3 ) ! csv to compare computed and theoretical values open ( 10 , file = 'out/extrema.csv' ) do i = 1 , nb_null_derivatives ( 1 ) write ( 10 , * ) 'comput,' , vall ( i , 1 ), ',' , vall ( i , 2 ), ',' , '1,VALLEY' enddo do i = 1 , nb_null_derivatives ( 2 ) write ( 10 , * ) 'comput,' , sadd ( i , 1 ), ',' , sadd ( i , 2 ), ',' , '2,SADDLE' enddo do i = 1 , nb_null_derivatives ( 3 ) write ( 10 , * ) 'comput,' , peak ( i , 1 ), ',' , peak ( i , 2 ), ',' , '3,PEAK' enddo do i = 0 , 2 i1 = int ( nx * ( 0.5 + i ) / 3. ) do j = 0 , 5 j1 = int ( ny * ( 0.5 + j ) / 6. ) if ( ( j == 2 * ( j / 2 ) . and . i == 2 * ( i / 2 ) ) . or . & ! ( j == 2 * ( j / 2 ) + 1 . and . i == 2 * ( i / 2 ) + 1 ) ) then ! write ( 10 , * ) 'theory,' , i1 , ',' , j1 , ',' , '3,PEAK' else write ( 10 , * ) 'theory,' , i1 , ',' , j1 , ',' , '1,VALLEY' endif enddo enddo do i = 0 , 2 i1 = int ( nx * ( 1.0 + i ) / 3. ) do j = 0 , 5 j1 = int ( ny * ( 1.0 + j ) / 6. ) if ( j1 /= ny . and . i1 /= nx ) write ( 10 , * ) 'theory,' , i1 , ',' , j1 , ',' , '2,SADDLE' enddo enddo close ( 10 ) deallocate ( heights , topo , vall , peak , sadd ) contains real ( kind = R8 ) function sinsin ( i , j , nx , ny ) implicit none integer ( kind = I4 ), intent ( in ) :: i , j , nx , ny sinsin = sin ( 3 * PI_R8 * i / nx + 1.e-8_R8 ) * sin ( 6 * PI_R8 * j / ny + 2.e-8_R8 ) return endfunction sinsin endsubroutine test_label_surf_summits subroutine test_peaks_and_pits_curvatures () !================================================================================================ !! Function to test the function \"peaks_and_pits_curvatures\" on a real rough surface. !!        Outputs surface gradients and curvatures as 2D arrays or single values. implicit none real ( kind = R8 ), allocatable , dimension (:,:) :: heights , bf_heights real ( kind = R8 ), allocatable , dimension (:,:) :: gradx , grady , gradxx , gradxy , gradyy , cvt real ( kind = R8 ) :: dx , dy , dz , pcurv , pgrad , pmin , pmax , fft_cutoff integer ( kind = I4 ) :: nx , ny , nx2 , ny2 , n_th type ( SCALE_SURF ) :: scal_surf call read_surf ( nom_fic = \"sur/test1.sur\" , & ! IN tab_s = heights , & ! OUT scal = scal_surf ) ! OUT nx = scal_surf % xres ny = scal_surf % yres dx = scal_surf % dx * unit2IUf ( scal_surf % dx_unit ) dy = scal_surf % dy * unit2IUf ( scal_surf % dy_unit ) dz = 0 fft_cutoff = dx / 5.e-6 nx2 = 2 * ( nint ( PAD_FFT * nx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT * ny ) / 2 ) write ( * , * ) 'nx, ny = ' , nx , ny write ( * , * ) 'dx, dy = ' , dx , dy !================================================================= allocate ( bf_heights ( 1 : nx , 1 : ny ) ) allocate ( gradx ( 1 : nx , 1 : ny ) ) allocate ( grady ( 1 : nx , 1 : ny ) ) allocate ( gradxx ( 1 : nx , 1 : ny ) ) allocate ( gradxy ( 1 : nx , 1 : ny ) ) allocate ( gradyy ( 1 : nx , 1 : ny ) ) allocate ( cvt ( 1 : nx , 1 : ny ) ) n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! call fft_filter ( tab = heights ( 1 : nx , 1 : ny ), & ! in long = nx , & ! in larg = ny , & ! in cutoff = fft_cutoff , & ! in bf_tab = bf_heights ( 1 : nx , 1 : ny ), & ! out multi_fft = . FALSE .) ! in call end_fftw3 () call write_surf ( nom_fic = \"out/test_bf_heights.sur\" , & ! in tab_s = bf_heights ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call gradient ( tab = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in gradx = gradx ( 1 : nx , 1 : ny ), & ! out grady = grady ( 1 : nx , 1 : ny )) ! out call write_surf ( nom_fic = \"out/test_gradq.sur\" , & ! in tab_s = gradx ( 1 : nx , 1 : ny ) ** 2 + & ! in grady ( 1 : nx , 1 : ny ) ** 2 , & ! scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradx.sur\" , & ! in tab_s = gradx ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_grady.sur\" , & ! in tab_s = grady ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in !================================================================= call gauss_curv ( gradx = gradx ( 1 : nx , 1 : ny ), & ! grady = grady ( 1 : nx , 1 : ny ), & ! gradxx = gradxx ( 1 : nx , 1 : ny ), & ! gradxy = gradxy ( 1 : nx , 1 : ny ), & ! gradyy = gradyy ( 1 : nx , 1 : ny ), & ! nx = nx , & ! ny = ny , & ! dx = dx , & ! dy = dy ) ! call write_surf ( nom_fic = \"out/test_gradxx_1.sur\" , & ! in tab_s = gradxx ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradxy_1.sur\" , & ! in tab_s = gradxy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradyy_1.sur\" , & ! in tab_s = gradyy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call curv2 ( tab = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in gradxx = gradxx ( 1 : nx , 1 : ny ), & ! out gradyy = gradyy ( 1 : nx , 1 : ny )) ! out call write_surf ( nom_fic = \"out/test_gradxx_2.sur\" , & ! in tab_s = gradxx ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradxy_2.sur\" , & ! in tab_s = gradxy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call write_surf ( nom_fic = \"out/test_gradyy_2.sur\" , & ! in tab_s = gradyy ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in call curvature ( tab = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in S_param_grad = pgrad , & ! out S_param_curv = pcurv , & ! out gcurvt = cvt ( 1 : nx , 1 : ny )) ! out write ( * , * ) \"S_param_grad: \" , pgrad call write_surf ( nom_fic = \"out/test_cvt.sur\" , & ! in tab_s = cvt ( 1 : nx , 1 : ny ), & ! in scal = scal_surf ) ! in !================================================================= call peaks_and_pits_curvatures ( heights = bf_heights ( 1 : nx , 1 : ny ), & ! in nx = nx , & ! in ny = ny , & ! in dx = dx , & ! in dy = dy , & ! in S_param_grad = pgrad , & ! out S_param_curv = pcurv , & ! out peak_curv = pmax , & ! out pits_curv = pmin ) ! out write ( * , * ) \"S_param_curv: \" , pcurv write ( * , * ) \"peak_curv: \" , pmin write ( * , * ) \"pits_curv: \" , pmax !================================================================= deallocate ( heights , bf_heights , gradx , grady , gradxy , gradxx , gradyy , cvt ) return endsubroutine test_peaks_and_pits_curvatures endmodule grad_curv","tags":"","loc":"sourcefile/mod_grad_curv.f90.html"},{"title":"mod_filter.f90 – TPGLIB","text":"This file depends on sourcefile~~mod_filter.f90~~EfferentGraph sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_filter.f90~~AfferentGraph sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_anisotropy.f90 mod_anisotropy.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_filter.f90 sourcefile~mod_grad_curv.f90 mod_grad_curv.f90 sourcefile~mod_grad_curv.f90->sourcefile~mod_filter.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_filter.f90 sourcefile~prg.f90~5 prg.f90 sourcefile~prg.f90~5->sourcefile~mod_anisotropy.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_grad_curv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: april, 06 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Surface smoothers** !<  </span> module filter use data_arch , only : I4 , R8 , HIG_R8 , PI_R8 use stat_mom , only : calc_median , moment_stat , calc_moments use sort_arrays , only : sort_array2 use fftw3 , only : calc_fftw3_real_fwd , tab_calc_fftw3_real_fwd , & ! calc_fftw3_real_bwd , tab_calc_fftw3_real_bwd , PAD_FFT , extend use surfile , only : read_surf , write_surf , init_scal , SCALE_SURF , unit2IUf !$ use omp_lib implicit none real ( kind = R8 ) :: PAD_FFT_FILTER = PAD_FFT ! with 1.5, the results for gaussian filtering are the same as Mountains' private public :: median_filter , median_smooth , morpho_filter , soften , fft_filter , PAD_FFT_FILTER !> {!FILTR/src/inc_doc/comp_filtr.md!} !> {!css/button.html!} contains subroutine morpho_filter ( tabin , tabou , long , larg , scale_xyz , ray , omp , nb_div , mtype ) !================================================================================================ !< @note !< !< Morphological filter: uses combinations of [[roll_smooth]] to provide all kind of transformation : !< !< + closing !< + opening !< + dilation !< + erosion !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: nb_div !! *number of macro elements along an axis* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( in ) :: ray !! *roll radius* character ( len =* ), intent ( in ) :: mtype !! *closing, opening, dilation or erosion* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *lag along x, y and scale z* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tabou !! *2D array out* real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp logical ( kind = I4 ) :: op1 , op2 integer ( kind = I4 ) :: k select case ( mtype ( 1 : 7 ) ) case ( \"closing\" ) op1 = . true . ; op2 = . true . ; k = + 1 case ( \"opening\" ) op1 = . true . ; op2 = . true . ; k = - 1 case ( \"dilatio\" ) op1 = . true . ; op2 = . false . ; k = + 1 case ( \"erosion\" ) op1 = . true . ; op2 = . false . ; k = - 1 case default stop \"bad choice, morpho_filter\" endselect if ( op1 ) then call roll_smooth ( tabin = tabin ( 1 : long , 1 : larg ), & ! IN tabou = tabou ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN scale_xyz = scale_xyz , & ! IN sgn = + k , & ! IN ray = ray , & ! IN omp = omp , & ! IN nb_div = nb_div ) ! IN endif if ( op2 ) then allocate ( tab_tmp ( 1 : long , 1 : larg ) ) call roll_smooth ( tabin = tabou ( 1 : long , 1 : larg ), & ! IN tabou = tab_tmp ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN scale_xyz = scale_xyz , & ! IN sgn = - k , & ! IN ray = ray , & ! IN omp = omp , & ! IN nb_div = nb_div ) ! IN tabou ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp ) endif return endsubroutine morpho_filter subroutine roll_smooth ( tabin , tabou , long , larg , scale_xyz , sgn , ray , omp , nb_div ) !================================================================================================ !< @note !< !< A ball of radius \"ray\" rolls on / below the surface, hence defining a closing or an opening enveloppe. !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: sgn !! *+ 1: dilation, -1:erosion* integer ( kind = I4 ), intent ( in ) :: nb_div !! *number of macro elements along an axis* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( in ) :: ray !! *roll radius* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *lag along x, y and scale z* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tabou !! *2D array out* integer ( kind = I4 ) :: i , j , ii , jj , nb_th integer ( kind = I4 ) :: hw integer ( kind = I4 ) :: ik , jk , idiv , jdiv , ista , iend , jsta , jend real ( kind = R8 ) :: h1 , h2 , ht , tmp , delta_h_max real ( kind = R8 ) :: ech_x , ech_y real ( kind = R8 ), allocatable , dimension (:,:) :: elem , tab_tmp integer ( kind = I4 ), allocatable , dimension (:,:) :: thw ech_x = scale_xyz ( 1 ) !SCALE_IMG%dx * unit2IUf(SCALE_IMG%dx_unit) ech_y = scale_xyz ( 2 ) !SCALE_IMG%dy * unit2IUf(SCALE_IMG%dy_unit) h1 = minval ( tabin ( 1 : long , 1 : larg ) ) h2 = maxval ( tabin ( 1 : long , 1 : larg ) ) delta_h_max = h2 - h1 ht = min ( - abs ( h1 ), - abs ( h2 ) ) h2 = max ( + abs ( h1 ), + abs ( h2 ) ) h1 = ht ! the normal width of the ball is : hw = int( ray / ech_x ) ! However the ball curvature makes the ball height sometimes higher than the surfaces heights hw = int ( sqrt ( 2 * delta_h_max * ray - delta_h_max ** 2 ) / ech_x ) !+ 1 allocate ( elem ( - hw : hw , - hw : hw ) ) allocate ( tab_tmp ( - hw + 1 : hw + long , - hw + 1 : hw + larg ) ) ! surface is extended tab_tmp ( 1 : long , 1 : larg ) = tabin ( 1 : long , 1 : larg ) ! original surface do i = 1 , long tab_tmp ( i , - hw + 1 : 0 ) = tab_tmp ( i , 1 ) tab_tmp ( i , larg + 1 : larg + hw ) = tab_tmp ( i , larg ) enddo do j = - hw + 1 , larg + hw tab_tmp ( - hw + 1 : 0 , j ) = tab_tmp ( 1 , j ) tab_tmp ( long + 1 : long + hw , j ) = tab_tmp ( long , j ) enddo nb_th = 1 if ( omp ) then nb_th = omp_get_num_procs () endif allocate ( thw ( 1 : nb_div , 1 : nb_div ) ) ! number of macro squares on which the ball active width is determined idiv = long / nb_div jdiv = larg / nb_div !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO  SCHEDULE (STATIC, max(nb_div/nb_th, 1)) PRIVATE(jk, ik, delta_h_max, ista, iend, jsta, jend) do jk = 1 , nb_div if ( jk == nb_div ) then ; jend = larg ; else ; jend = jk * jdiv ; endif ; jsta = 1 + jdiv * ( jk - 1 ) do ik = 1 , nb_div if ( ik == nb_div ) then ; iend = long ; else ; iend = ik * idiv ; endif ; ista = 1 + idiv * ( ik - 1 ) delta_h_max = maxval ( tab_tmp ( - hw + ista : hw + iend , - hw + jsta : hw + jend ) ) - & ! minval ( tab_tmp ( - hw + ista : hw + iend , - hw + jsta : hw + jend ) ) ! beyond the present width, the ball height is greater than the surface height thw ( ik , jk ) = int ( sqrt ( 2 * delta_h_max * ray - delta_h_max ** 2 ) / ech_x ) enddo enddo !$OMP END DO !$OMP END PARALLEL if ( sgn == + 1 ) then do jj = - hw , hw do ii = - hw , hw tmp = ray ** 2 - ( ii * ech_x ) ** 2 - ( jj * ech_y ) ** 2 if ( tmp < 0. ) then elem ( ii , jj ) = ray + 1.1 * abs ( h2 ) else ! the ball location is a little above the surface elem ( ii , jj ) = ray - sqrt ( tmp ) endif enddo enddo else do jj = - hw , hw do ii = - hw , hw tmp = ray ** 2 - ( ii * ech_x ) ** 2 - ( jj * ech_y ) ** 2 if ( tmp < 0. ) then elem ( ii , jj ) = - ray - 1.1 * abs ( h1 ) else ! the ball location is a little below the surface elem ( ii , jj ) = - ray + sqrt ( tmp ) endif enddo enddo endif !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO SCHEDULE (STATIC,larg/nb_th) PRIVATE(i, j, jk, ik, hw) do j = 1 , larg ; jk = 1 + j / ( jdiv + 1 ) do i = 1 , long ; ik = 1 + i / ( idiv + 1 ) hw = thw ( ik , jk ) tabou ( i , j ) = - minval ( sgn * ( elem ( - hw : hw , - hw : hw ) - & ! tab_tmp ( - hw + i : hw + i , - hw + j : hw + j ) ) ) enddo enddo !$OMP END DO !$OMP END PARALLEL if ( sgn == + 1 ) then tabou ( 1 : long , 1 : larg ) = + tabou ( 1 : long , 1 : larg ) + ray else tabou ( 1 : long , 1 : larg ) = - tabou ( 1 : long , 1 : larg ) - ray endif deallocate ( elem , tab_tmp , thw ) return endsubroutine roll_smooth subroutine median_smooth ( tab , long , larg , kernel , omp ) !================================================================================================ !! Very classical smoothing !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: kernel !! *kernel size* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array* integer ( kind = I4 ) :: i , j , k , ii , jj , nt , nk , nb_th real ( kind = R8 ) :: md real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp , t real ( kind = R8 ), allocatable , dimension (:) :: vt allocate ( tab_tmp ( 1 : long , 1 : larg ) ) ; tab_tmp = HIG_R8 k = kernel nt = ( 2 * k + 1 ) * ( 2 * k + 1 ) allocate ( t ( - k : k , - k : k ), vt ( 1 :( 2 * k + 1 ) * ( 2 * k + 1 )) ) nb_th = 1 if ( omp ) then nb_th = omp_get_num_procs () endif !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO SCHEDULE (STATIC,larg/nb_th) PRIVATE(i, t, nk, ii, jj, vt, md) do j = 1 , larg do i = 1 , long t ( - k : k , - k : k ) = - HIG_R8 / 10 nk = 0 do jj = - k , + k if ( j + jj < 1 . or . j + jj > larg ) cycle do ii = - k , + k if ( i + ii < 1 . or . i + ii > long ) cycle nk = nk + 1 t ( ii , jj ) = tab ( i + ii , j + jj ) enddo enddo vt ( 1 : nt ) = reshape ( t ( - k : k , - k : k ), [ nt ]) call sort_array2 ( tab_inout = vt ( 1 : nt ), n = nt ) call calc_median ( tab = vt ( nt - nk + 1 : nt ), md = md ) tab_tmp ( i , j ) = md enddo enddo !$OMP END DO !$OMP END PARALLEL tab ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp , t , vt ) return endsubroutine median_smooth subroutine median_filter ( tab , long , larg , snb , kernel , sig , omp ) !================================================================================================ !! A bit more complex filter: the overall height standard deviation is taken into account !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* integer ( kind = I4 ), intent ( in ) :: snb !! *patch number along a direction* integer ( kind = I4 ), intent ( in ) :: kernel !! *kernel size* logical ( kind = I4 ), intent ( in ) :: omp !! *if multithreading* real ( kind = R8 ), intent ( in ) :: sig !! *error std* real ( kind = R8 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: md integer ( kind = I4 ), dimension ( 1 : snb + 1 ) :: li , lj real ( kind = R8 ), dimension ( 1 : snb * snb ) :: ect real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp1 , tab_tmp2 type ( moment_stat ) :: mx_smooth allocate ( tab_tmp1 ( 1 : long , 1 : larg ) ) allocate ( tab_tmp2 ( 1 : long , 1 : larg ) ) ! first determine the difference between the input surface and a median filtered one tab_tmp1 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) call median_smooth ( tab = tab_tmp1 ( 1 : long , 1 : larg ), & ! kernel = kernel , & ! long = long , & ! larg = larg , & ! omp = omp ) ! tab_tmp2 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) - tab_tmp1 ( 1 : long , 1 : larg ) ! bounds when patching domain li ( 1 ) = 1 ; li ( snb + 1 ) = long lj ( 1 ) = 1 ; lj ( snb + 1 ) = larg do i = 2 , snb li ( i ) = li ( i - 1 ) + int ( real ( long , kind = R8 ) / snb , kind = I4 ) lj ( i ) = lj ( i - 1 ) + int ( real ( larg , kind = R8 ) / snb , kind = I4 ) enddo k = 0 do j = 1 , snb do i = 1 , snb call calc_moments ( tab = reshape ( tab_tmp2 ( li ( i ): li ( i + 1 ) - 1 , lj ( j ): lj ( j + 1 ) - 1 ), & ! [( li ( i ) - li ( i + 1 ) ) * ( lj ( j ) - lj ( j + 1 ) )] ), & ! mx = mx_smooth , & ! nb_mom = 2 ) ! k = k + 1 ect ( k ) = mx_smooth % si enddo enddo call calc_median ( tab = ect ( 1 : snb * snb ), & ! md = md ) ! call calc_moments ( tab = reshape ( tab_tmp2 ( 1 : long , 1 : larg ), & ! [ long * larg ] ), & ! mx = mx_smooth , & ! nb_mom = 2 ) ! where ( abs ( tab_tmp2 ( 1 : long , 1 : larg ) - mx_smooth % mu ) > sig * md ) tab ( 1 : long , 1 : larg ) = tab_tmp1 ( 1 : long , 1 : larg ) deallocate ( tab_tmp1 , tab_tmp2 ) return endsubroutine median_filter subroutine soften ( tabin , mask , tabout , long , larg ) !================================================================================================ !< @note Function to smooth out a 2D array: each point is replaced by a weighted mean of its neighbors. !< !<  !<   h_{i,j} = \\frac{1}{16} \\left( 4 h_{i, j} + 2 h_{i + 1, j    } + 2 h_{i - 1, j    } + 2 h_{i    , j + 1} + 2 h_{i    , j - 1} !<                                              + h_{i + 1, j - 1} +   h_{i - 1, j + 1} +   h_{i - 1, j + 1} +   h_{i + 1, j - 1} \\right) !<  !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array width* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tabout !! *2D array out* integer ( kind = I4 ), intent ( in ), dimension ( 1 : long , 1 : larg ), optional :: mask !! *mask* integer ( kind = I4 ) :: i , j tabout ( 1 : long , 1 : larg ) = tabin ( 1 : long , 1 : larg ) if ( present ( mask ) ) then do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 if ( sum ( mask ( i - 1 : i + 1 , j - 1 : j + 1 )) < 9 ) then cycle else tabout ( i , j ) = ( 2 * tabin ( i , j ) + tabin ( i + 1 , j ) + tabin ( i - 1 , j ) + & ! tabin ( i , j + 1 ) + tabin ( i , j - 1 ) + ( tabin ( i + 1 , j - 1 ) + tabin ( i - 1 , j - 1 ) + & ! tabin ( i - 1 , j + 1 ) + tabin ( i + 1 , j + 1 ) ) / 2._R8 ) / 8 endif enddo enddo else do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 tabout ( i , j ) = ( 2 * tabin ( i , j ) + tabin ( i + 1 , j ) + tabin ( i - 1 , j ) + & ! tabin ( i , j + 1 ) + tabin ( i , j - 1 ) + ( tabin ( i + 1 , j - 1 ) + tabin ( i - 1 , j - 1 ) + & ! tabin ( i - 1 , j + 1 ) + tabin ( i + 1 , j + 1 ) ) / 2._R8 ) / 8 enddo enddo endif return endsubroutine soften subroutine fft_filter ( tab , long , larg , cutoff , bf_tab , multi_fft , pad , ext , type_apo ) !================================================================================================ !! Classical Gaussian filter !------------------------------------------------------------------------------------------------ use surfile , only : init_scal , write_surf , SCALE_SURF implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array width* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ) :: cutoff !! *cut-off wavelength* logical ( kind = I4 ), intent ( in ) :: multi_fft !! *multiple fft at once ?* real ( kind = R8 ), intent ( in ), optional :: pad !! *fft padding* character ( len =* ), intent ( in ), optional :: ext !! *extension* character ( len =* ), intent ( in ), optional :: type_apo !! *apodization type* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: bf_tab !! *2D array out* integer ( kind = I4 ) :: nx2 , ny2 , iex , iey , ibx , iby real ( kind = R8 ) :: o_pad logical ( kind = I4 ) :: with_pad character ( len = :), allocatable :: o_ext character ( len = :), allocatable :: o_type_apo complex ( kind = R8 ), dimension (:,:), allocatable :: cmple real ( kind = R8 ), dimension (:,:), allocatable :: tab_ext , gauss_tab , tab_tmp with_pad = . true . if ( . not . present ( ext ) ) then o_ext = 'symmetry' else o_ext = ext endif if ( . not . present ( type_apo ) ) then o_type_apo = 'no_apo' else o_type_apo = type_apo endif if ( . not . present ( pad ) ) then o_pad = PAD_FFT_FILTER else if ( pad < 0. ) then o_pad = 1 nx2 = long ny2 = larg with_pad = . false . else o_pad = pad endif endif if ( with_pad ) then nx2 = 2 * ( nint ( o_pad * long ) / 2 ) ny2 = 2 * ( nint ( o_pad * larg ) / 2 ) endif allocate ( tab_ext ( 1 : nx2 , 1 : ny2 ) ) ! allocate ( tab_tmp ( 1 : nx2 , 1 : ny2 ) ) ! allocate ( cmple ( 1 : nx2 , 1 : ny2 ) ) ! if ( nx2 > long ) then ibx = ceiling ( ( nx2 - long ) / 2. ) ; iex = ibx + long - 1 iby = ceiling ( ( ny2 - larg ) / 2. ) ; iey = iby + larg - 1 call extend ( tab_in = tab ( 1 : long , 1 : larg ), & ! tab_out = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! nx = long , & ! ny = larg , & ! nx2 = nx2 , & ! ny2 = ny2 , & ! ext = o_ext , & ! type_apo = o_type_apo ) ! else tab_ext ( 1 : nx2 , 1 : ny2 ) = tab ( 1 : long , 1 : larg ) endif if ( multi_fft ) then call tab_calc_fftw3_real_fwd ( tab_in = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = cmple ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! else call calc_fftw3_real_fwd ( tab_in = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = cmple ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! endif allocate ( gauss_tab ( 1 : nx2 , 1 : ny2 ) ) call gaussian_filter ( long = nx2 , & ! larg = ny2 , & ! xc = cutoff , & ! gauss_filt = gauss_tab ( 1 : nx2 , 1 : ny2 ) ) ! cmple ( 1 : nx2 , 1 : ny2 ) = cmple ( 1 : nx2 , 1 : ny2 ) * gauss_tab ( 1 : nx2 , 1 : ny2 ) deallocate ( gauss_tab ) if ( multi_fft ) then call tab_calc_fftw3_real_bwd ( tab_in = cmple ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! else call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = tab_ext ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! endif if ( nx2 > long ) then bf_tab ( 1 : long , 1 : larg ) = tab_ext ( ibx : iex , iby : iey ) else bf_tab ( 1 : long , 1 : larg ) = tab_ext ( 1 : nx2 , 1 : ny2 ) endif deallocate ( cmple ) deallocate ( tab_ext , tab_tmp ) return endsubroutine fft_filter subroutine gaussian_filter ( long , larg , xc , gauss_filt ) !================================================================================================ !! Gaussian kernel !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ) :: xc !! *the cut-off wavelength* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: gauss_filt !! *2D array out* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: tmp , xi , xj real ( kind = R8 ), parameter :: const = sqrt ( log ( 2._R8 ) / PI_R8 ) do j = 2 , larg / 2 + 1 do i = 2 , long / 2 + 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) tmp = gaussian_function ( xi , xj , xc ) gauss_filt ( + i , + j ) = tmp gauss_filt ( long + 2 - i , + j ) = tmp gauss_filt ( + i , larg + 2 - j ) = tmp gauss_filt ( long + 2 - i , larg + 2 - j ) = tmp enddo enddo do j = 2 , larg / 2 + 1 i = 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) tmp = gaussian_function ( xi , xj , xc ) gauss_filt ( i , j ) = tmp gauss_filt ( i , larg + 2 - j ) = tmp enddo do i = 2 , long / 2 + 1 j = 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) tmp = gaussian_function ( xi , xj , xc ) gauss_filt ( i , j ) = tmp gauss_filt ( long + 2 - i , j ) = tmp enddo i = 1 j = 1 xi = ( i - 1 ) ; xj = ( j - 1 ) xi = xi / ( long - 1 ) ; xj = xj / ( larg - 1 ) gauss_filt ( i , j ) = gaussian_function ( xi , xj , xc ) contains !----------------------------------------- real ( kind = R8 ) function gaussian_function ( xi , xj , xc ) implicit none real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ) :: xj real ( kind = R8 ), intent ( in ) :: xc ! fréquence de coupure, plus exactement proportion : (freq coup) / (nb points) gaussian_function = exp ( - PI_R8 * const ** 2 * ( xi ** 2 + xj ** 2 ) / ( xc ** 2 ) ) ! sqrt(ln(2)/pi)=0.47 return endfunction gaussian_function !----------------------------------------- endsubroutine gaussian_filter endmodule filter","tags":"","loc":"sourcefile/mod_filter.f90.html"},{"title":"mod_morpho.f90 – TPGLIB","text":"This file depends on sourcefile~~mod_morpho.f90~~EfferentGraph sourcefile~mod_morpho.f90 mod_morpho.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_morpho.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_morpho.f90~~AfferentGraph sourcefile~mod_morpho.f90 mod_morpho.f90 sourcefile~prg.f90~7 prg.f90 sourcefile~prg.f90~7->sourcefile~mod_morpho.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: april, 06 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Morphological operations** !<  </span> module morpho use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use stat_mom , only : calc_median implicit none private public :: count_cell , erode_dilate , def_masque , topology , calcul_normales , surf_area contains subroutine flood ( masque , taille , nx , ny , niv ) !================================================================================================ !< @note !< !< Perform some kind of flood fill or connected component labeling on a grid (masque), !< starting from an initial '1' element found and spreading out to adjacent '1' elements, !< updating them to a specified value or zero if no value (niv) is specified. !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nx , ny !! *Input dimensions* integer ( kind = I4 ), intent ( in ), optional :: niv !! *Optional input level* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : nx , 1 : ny ) :: masque !! *Input/output matrix* integer ( kind = I4 ), intent ( out ) :: taille !! *Output scalar* integer ( kind = I4 ) :: i , j , p , q , k , ind , ival integer ( kind = I4 ) :: nb_traite ! Arrays to hold position indices and a tracking matrix integer ( kind = I4 ), dimension ( nx * ny ) :: liste_x , liste_y integer ( kind = I4 ), dimension ( nx , ny ) :: deja_fait ! Initialize arrays to zero liste_x = 0 liste_y = 0 deja_fait = 0 ! Initial position i = 0 j = 0 ! Find the first occurrence of the element \"1\" in masque o : do i = 1 , nx do j = 1 , ny if ( masque ( i , j ) == 1 ) exit o enddo enddo o ! If no element is found, set output size to zero and exit subroutine if ( i == nx + 1 . and . j == ny + 1 ) then taille = 0 return endif ! Initialize processing of found element ind = 1 liste_x ( ind ) = i liste_y ( ind ) = j ! Mark element as processed deja_fait ( i , j ) = 1 ! Start processing of elements nb_traite = 1 ! Explore neighbors in 8 directions (up, down, left, right and combinations) do i = liste_x ( nb_traite ) j = liste_y ( nb_traite ) ! Break the loop if outside bounds if ( i * j == 0 ) exit ! Check south direction k = 1 do p = i q = j - k if ( q < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check south-west direction k = 1 do p = i - k q = j - k if ( p < 1 ) exit if ( q < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check south-east direction k = 1 do p = i + k q = j - k if ( p > nx ) exit if ( q < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check north direction k = 1 do p = i q = j + k if ( q > nx ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check north-west direction k = 1 do p = i - k q = j + k if ( p < 1 ) exit if ( q > ny ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check north-east direction k = 1 do p = i + k q = j + k if ( p > nx ) exit if ( q > ny ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check west direction k = 1 do p = i - k q = j if ( p < 1 ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Check east direction k = 1 do p = i + k q = j if ( p > nx ) exit if ( masque ( p , q ) == 0 ) exit if ( deja_fait ( p , q ) == 0 ) then ind = ind + 1 liste_x ( ind ) = p liste_y ( ind ) = q deja_fait ( p , q ) = 1 endif k = k + 1 enddo ! Increment processed count nb_traite = nb_traite + 1 enddo ! Set output size to number of processed elements taille = ind ! Update masque values based on presence of niv and processed nodes ival = 0 if ( present ( niv ) ) ival = niv where ( deja_fait == 1 ) masque = ival ! Fill the connected region in 'masque' return endsubroutine flood subroutine count_cell ( msk , long , larg , nbr_cell , med_cell ) !================================================================================================ !! Calculate the number of cells in a mask, as well as the cell median size !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* integer ( kind = I4 ), intent ( out ) :: nbr_cell !! *number of cells* real ( kind = R8 ), intent ( out ), optional :: med_cell !! *median size of the cells* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: msk !! *mask* integer ( kind = I4 ) :: i , j , k , nb real ( kind = R8 ), dimension ( 1 : long * larg ) :: cell cell ( 1 : long * larg ) = 0 k = 1 do call flood ( masque = msk ( 1 : long , 1 : larg ), & ! INOUT taille = nb , & ! OUT nx = long , & ! IN ny = larg , & ! IN niv = k + 1 ) ! IN if ( nb == 0 ) exit cell ( k ) = nb k = k + 1 enddo nbr_cell = k - 1 med_cell = 0._R8 if (. not . present ( med_cell )) return if ( k > 0 ) then call calc_median ( tab = cell ( 1 : nbr_cell ), & ! IN md = med_cell ) ! OUT med_cell = 100 * med_cell / ( long * larg ) else med_cell = 0 endif return endsubroutine count_cell subroutine erode_dilate ( msk , long , larg , val , act ) !================================================================================================ !! Perform erosion or dilation on a binary mask depending on the value of act. !! The operations utilize a defined kernel to affect neighboring pixels based on the specified val !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D mask length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D mask height* integer ( kind = I4 ), intent ( in ) :: val !! *size of the structuring element for the erosion/dilation operation* character ( len = 5 ), intent ( in ) :: act !! *action to be performed, either \"erode\" or another operation, presumably \"dilate\".* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: msk !! *2D mask* integer ( kind = I4 ) :: i , j , fin , ival integer ( kind = I4 ), dimension ( - val : val , - val : val ) :: ker ! If the action specified is \"erode\", the mask is inverted (0s become 1s and 1s become 0s). This prepares the mask for the erosion operation. if ( act == \"erode\" ) msk ( 1 : long , 1 : larg ) = 1 - msk ( 1 : long , 1 : larg ) fin = + 2 ! The forall construct fills the kernel with the value fin (2) for all points (i, j) within a circular area defined by the radius val. ! The center of the kernel (ker(0, 0)) is explicitly set to 0. ker ( - val : val , - val : val ) = 0 forall ( i = - val : + val , j = - val : + val , i ** 2 + j ** 2 <= val ** 2 ) ker ( i , j ) = fin ker ( 0 , 0 ) = 0 do j = 1 + val , larg - val do i = 1 + val , long - val ! If the pixel value at position (i, j) in the mask is even, the loop skips any further processing for that pixel and continues to the next iteration. if ( mod ( msk ( i , j ), 2 ) == 0 ) cycle ! If the pixel value is odd, the corresponding area in the mask defined by the kernel is updated by adding the kernel values to it. ! This implements the dilation operation. msk ( i - val : i + val , j - val : j + val ) = msk ( i - val : i + val , j - val : j + val ) + ker ( - val : val , - val : val ) enddo enddo ! This line sets all elements of the mask that are greater than or equal to 1 to 1, effectively binarizing the mask after dilation. where ( msk ( 1 : long , 1 : larg ) >= 1 ) msk = 1 ! If the action specified is \"erode\", the mask is inverted again, restoring it to its original form after dilation. if ( act == \"erode\" ) msk ( 1 : long , 1 : larg ) = 1 - msk ( 1 : long , 1 : larg ) return endsubroutine erode_dilate subroutine topology ( tab , long , larg , res ) !================================================================================================ !< @note !< !< The function performs the following operations on a surface: !< !< + mask the heights heights that are above 85 % of the (100% - 15 %) core, to avoid pits and peaks !< + erode then dilate (opening) the mask !< + count cells and the median size !< !< Reproduce the preceding steps with thresholds 15% and 95%. !< !< The results are put in the vector 'res' !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *heights 2D array* real ( kind = R8 ), intent ( out ), dimension ( 1 : 6 ) :: res !! *results* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ) :: tab_tmp1 integer ( kind = I4 ), dimension ( 1 : long , 1 : larg ) :: msk real ( kind = R8 ) :: mintab , maxtab , top01 , top02 , med_cell01 , med_cell02 integer ( kind = I4 ) :: nbr_cell01 , nbr_cell02 mintab = minval ( tab ( 1 : long , 1 : larg ) ) maxtab = maxval ( tab ( 1 : long , 1 : larg ) ) tab_tmp1 ( 1 : long , 1 : larg ) = ( tab ( 1 : long , 1 : larg ) - mintab ) / ( maxtab - mintab ) call def_masque ( msk = msk , & ! OUT tab = tab_tmp1 , & ! IN long = long , & ! IN larg = larg , & ! IN crit1 = 0.15_R8 , & ! IN crit2 = 0.85_R8 , & ! IN top = top01 ) ! OUT !......................................! call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"erode\" ) ! IN call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"dilat\" ) ! IN call count_cell ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN nbr_cell = nbr_cell01 , & ! IN med_cell = med_cell01 ) ! IN !......................................! call def_masque ( msk = msk , & ! OUT tab = tab_tmp1 , & ! IN long = long , & ! IN larg = larg , & ! IN crit1 = 0.15_R8 , & ! IN crit2 = 0.95_R8 , & ! IN top = top02 ) ! OUT call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"erode\" ) ! IN call erode_dilate ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN val = 5 , & ! IN act = \"dilat\" ) ! IN call count_cell ( msk = msk , & ! INOUT long = long , & ! IN larg = larg , & ! IN nbr_cell = nbr_cell02 , & ! OUT med_cell = med_cell02 ) ! OUT res ( 1 : 6 ) = [ real ( nbr_cell01 , kind = R8 ), med_cell01 , top01 , & ! real ( nbr_cell02 , kind = R8 ), med_cell02 , top02 ] return endsubroutine topology subroutine def_masque ( msk , tab , long , larg , crit1 , crit2 , top ) !================================================================================================ !! Height mask without deepest pits and highest peaks !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* real ( kind = R8 ), intent ( in ) :: crit1 !! *%age for deepest pits to remove* real ( kind = R8 ), intent ( in ) :: crit2 !! *%age for highest peaks to remove* real ( kind = R8 ), intent ( out ) :: top !! *%age of surface masked* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *heights 2D array* integer ( kind = I4 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: msk !! *mask* msk ( 1 : long , 1 : larg ) = 0 ! height masked : height above c1 + c2 * (1 - c1) ! ex: c1 = 15 %, c2 = 85 % -> heights that are above 85 % of the (1 - 15 %) core are masked where ( tab > crit1 + crit2 - crit1 * crit2 ) msk = 1 top = 100 * real ( sum ( msk ( 1 : long , 1 : larg ) ), kind = R8 ) / ( long * larg ) return endsubroutine def_masque subroutine make_mask ( x0 , y0 , a , b , shap , msk , long , larg ) !================================================================================================ !! Mask a region within a given shape (for the moment an ellipsis) !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* integer ( kind = I4 ), intent ( in ) :: x0 !! *mask shape center 1st coordinate* integer ( kind = I4 ), intent ( in ) :: y0 !! *mask shape center 2nd coordinate* integer ( kind = I4 ), intent ( in ) :: a !! *ellipsis semi-length* integer ( kind = I4 ), intent ( in ) :: b !! *ellipsis semi-height* character ( len = 8 ), intent ( in ) :: shap !! *kind of mask shape* integer ( kind = I4 ), intent ( inout ), dimension ( 1 : long , 1 : larg ) :: msk !! *mask* integer ( kind = I4 ) :: i , j select case ( shap ) case ( 'ellipsis' ) forall ( i = 1 : long , j = 1 : larg , ( real ( i - x0 , kind = R8 ) / a ) ** 2 + ( real ( j - y0 , kind = R8 ) / b ) ** 2 < 1. ) msk ( i , j ) = 1 case default stop 'make_mask, bad choice' endselect return endsubroutine make_mask subroutine make_composite_mask ( msk , n_cells , locus , a , b , width , height , shap , long , larg ) !================================================================================================ !< @note !< !< The subroutine generates a composite mask based on specified parameters. !< The mask is filled with a number of shapes (in this case, ellipses) placed randomly within a defined area, while ensuring that the shapes do not overlap. !< !< + If the `locus` is set to 'center', the subroutine immediately centers a single shape in the mask. !< + If not centered, it attempts to randomly place the specified number of shapes (`n_cells`) within the mask. !<   The algorithm limits attempts to place shapes to avoid overlaps. !< + The routine uses random numbers to determine the position of each shape, ensuring that they fit within the given dimensions and do not exceed the boundaries of the mask. !< + A separate temporary mask (`msk_quad`) is used to track where shapes have already been placed, preventing overlaps. !< + The process continues until the desired number of shapes is successfully placed or until a maximum number of attempts is reached (to avoid infinite loops). !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n_cells !! *Number of cells to create in the composite mask* integer ( kind = I4 ), intent ( in ) :: long !! *Length (dimensions) of the mask* integer ( kind = I4 ), intent ( in ) :: larg !! *Width (dimensions) of the mask* integer ( kind = I4 ), intent ( in ) :: width !! *Width of each shape to be drawn in the mask* integer ( kind = I4 ), intent ( in ) :: height !! *Height of each shape to be drawn in the mask* integer ( kind = I4 ), intent ( in ) :: a !! *ellipsis first parameter* integer ( kind = I4 ), intent ( in ) :: b !! *ellipsis second parameter* character ( len = 8 ), intent ( in ) :: shap !! *Type of shape to be drawn (here, 'ellipsis' is used)* character ( len = 6 ), intent ( in ) :: locus !! *Position of the shape (e.g., 'center' for centering)* integer ( kind = I4 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: msk !! *Output mask that will be filled with shapes* ! Declaration of local variables integer ( kind = I4 ) :: icells , x0 , y0 , iter , itry real ( kind = R8 ) :: x , y ! Temporary masks to manage the shapes integer ( kind = I4 ), dimension ( 1 : long , 1 : larg ) :: msk_quad , msk_shap ! Initialize the output mask to zero msk ( 1 : long , 1 : larg ) = 0 ! If the position is centered, calculate the central coordinates if ( locus == 'center' ) then x0 = long / 2 + 1 ! x-coordinate of the center y0 = larg / 2 + 1 ! y-coordinate of the center ! Call the subroutine to create a centered ellipse mask call make_mask ( x0 = x0 , & ! y0 = y0 , & ! a = a , & ! b = b , & ! shap = 'ellipsis' , & ! msk = msk , & ! long = long , & ! larg = larg ) ! return endif ! Initialize the attempt counter for placing cells itry = 0 l1 : do itry = itry + 1 ! Increment the attempt counter if ( itry > 100 ) exit l1 ! Limit the number of tries to 100 msk_quad ( 1 : long , 1 : larg ) = 0 ! Reset the quadrilateral mask msk ( 1 : long , 1 : larg ) = 0 ! Reset the final mask icells = 0 ! Cell placement counter iter = 0 ! Iteration counter for placement l2 : do iter = iter + 1 ! Increment the iteration counter if ( iter > 200 ) cycle l1 ! Limit the number of iterations to 200 ! Display the current state of the iteration and the number of cells write ( * , * ) iter , icells call random_number ( x ) ! Generate a random number for x x0 = width / 2 + 1 + x * ( long - width - 1 ) ! Calculate the x-coordinate of the center of the shape call random_number ( y ) ! Generate a random number for y y0 = height / 2 + 1 + y * ( larg - height - 1 ) ! Calculate the y-coordinate of the center of the shape msk_shap ( 1 : long , 1 : larg ) = 0 ! Reset the temporary shape mask ! Define the shape mask over a square area centered on (x0, y0) msk_shap ( x0 - width / 2 : x0 + width / 2 , & ! y0 - height / 2 : y0 + height / 2 ) = 1 ! ! Check if the shape does not overlap with an already placed shape if ( sum ( msk_quad ( 1 : long , 1 : larg ) * msk_shap ( 1 : long , 1 : larg )) > 0 ) cycle l2 ! Call the subroutine to create an ellipse mask at coordinates (x0, y0) call make_mask ( x0 = x0 , & ! y0 = y0 , & ! a = a , & ! b = b , & ! shap = 'ellipsis' , & ! msk = msk , & ! long = long , & ! larg = larg ) ! msk_quad ( x0 - width / 2 : x0 + width / 2 , & ! y0 - height / 2 : y0 + height / 2 ) = 1 ! Mark the area of the placed shape icells = icells + 1 ! Increment the count of placed cells if ( icells == n_cells ) exit l1 ! Exit if the desired number of cells has been reached enddo l2 enddo l1 return endsubroutine make_composite_mask subroutine calcul_normales ( tab_in , long , larg , scale_xyz , cone_angle , hori , print_mask ) !================================================================================================ !! Function that returns the fraction of surface nearly horizontal (normal less than 5 degrees !!        from a vertical line) !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface array length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface array width* real ( kind = R8 ), intent ( in ) :: cone_angle !! *cone angle* real ( kind = R8 ), intent ( out ) :: hori !! *fraction of facets nearly horizontal* logical ( kind = I4 ), intent ( in ), optional :: print_mask !! *mask output ?* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *lag along x, y and scale z* integer ( kind = I4 ) :: i , j , ino , nb_no , ua real ( kind = R8 ) :: z1 , z2 , z3 , z4 real ( kind = R8 ) :: n1x , n1y , n1z , n2x , n2y , n2z , nx , ny , nz , norme real ( kind = R8 ) :: phi , angle_moy , ech_x , ech_y , ech_z , ech_r , d13 , d24 , d42 character ( len = 16 ) :: str real ( kind = R8 ), allocatable , dimension (:) :: angle real ( kind = R8 ), allocatable , dimension (:,:,:) :: vec nb_no = long * larg !  nombre de noeuds auquels on associera une normale allocate ( angle ( 1 : nb_no ) ) ! recevra les angles à la verticale pour chaque noeud allocate ( vec ( 1 : long , 1 : larg , 1 : 3 ) ) ! recevra pour chaque noeud la contribution des facettes triangulaires connectées ech_x = scale_xyz ( 1 ) !SCALE_IMG%dx * unit2IUf(SCALE_IMG%dx_unit) ech_y = scale_xyz ( 2 ) !SCALE_IMG%dy * unit2IUf(SCALE_IMG%dy_unit) ech_z = scale_xyz ( 3 ) ech_r = ech_x / ech_y d13 = ( 2. / 3. ) * sqrt ( ech_x ** 2 + ech_y ** 2 ) / 2 d42 = ( 2. / 3. ) * sqrt ( ( ech_x / 2 ) ** 2 + ech_y ** 2 ) d24 = ( 2. / 3. ) * sqrt ( ech_x ** 2 + ( ech_y / 2 ) ** 2 ) ! Raisonnement sur chaque carré du domaine vec ( 1 : long , 1 : larg , 1 : 3 ) = 0 do j = 1 , larg - 1 do i = 1 , long - 1 z1 = tab_in ( i , j ) * ech_z z4 = tab_in ( i , j + 1 ) * ech_z z2 = tab_in ( i + 1 , j ) * ech_z z3 = tab_in ( i + 1 , j + 1 ) * ech_z ! Triangle 1 n1x = ( z1 - z2 ) / ech_x n1y = ( z1 - z4 ) / ech_y n1z = 1 norme = sqrt ( n1x ** 2 + n1y ** 2 + n1z ** 2 ) n1x = n1x / norme n1y = n1y / norme n1z = n1z / norme ! Triangle 2 n2x = ( z4 - z3 ) / ech_x n2y = ( z2 - z3 ) / ech_y n2z = 1 norme = sqrt ( n2x ** 2 + n2y ** 2 + n2z ** 2 ) n2x = n2x / norme n2y = n2y / norme n2z = n2z / norme ! triangle 1 vec ( i + 0 , j + 0 , 1 : 3 ) = vec ( i + 0 , j + 0 , 1 : 3 ) + [ n1x , n1y , n1z ] / d13 ! node 1 vec ( i + 0 , j + 1 , 1 : 3 ) = vec ( i + 0 , j + 1 , 1 : 3 ) + [ n1x , n1y , n1z ] / d24 ! node 2 vec ( i + 1 , j + 0 , 1 : 3 ) = vec ( i + 1 , j + 0 , 1 : 3 ) + [ n1x , n1y , n1z ] / d42 ! node 4 ! triangle 2 vec ( i + 1 , j + 1 , 1 : 3 ) = vec ( i + 1 , j + 1 , 1 : 3 ) + [ n2x , n2y , n2z ] / d13 ! node 3 vec ( i + 0 , j + 1 , 1 : 3 ) = vec ( i + 0 , j + 1 , 1 : 3 ) + [ n2x , n2y , n2z ] / d42 ! node 2 vec ( i + 1 , j + 0 , 1 : 3 ) = vec ( i + 1 , j + 0 , 1 : 3 ) + [ n2x , n2y , n2z ] / d24 ! node 4 enddo enddo ino = 0 do j = 1 , larg do i = 1 , long nx = vec ( i , j , 1 ) ny = vec ( i , j , 2 ) nz = vec ( i , j , 3 ) norme = sqrt ( nx ** 2 + ny ** 2 + nz ** 2 ) nx = nx / norme ny = ny / norme nz = nz / norme phi = acos ( nz ) * 18 0. / PI_R8 ino = ino + 1 angle ( ino ) = phi enddo enddo ! angle moyen de la surface angle_moy = 0 !sum( angle(1:nb_no) )/nb_no ! tout ce qui dépasse l'angle moyen (à cone_angle° près) est masqué à 0 where ( abs ( angle - angle_moy ) < cone_angle ) angle = 1. elsewhere angle = 0. endwhere ! pourcentage de facettes quasi horizontales hori = 100 * sum ( angle ( 1 : nb_no ) ) / nb_no if ( present ( print_mask ) ) then str = repeat ( ' ' , len ( str ) ) write ( str , '(I12.12)' ) ino call get_unit ( ua ) open ( unit = ua , file = \"out/mask_angle.txt\" ) write ( ua , '(' // trim ( str ) // 'I2.1)' ) ( int ( angle ( i ) ), i = 1 , long * larg ) close ( ua ) endif deallocate ( angle , vec ) return endsubroutine calcul_normales subroutine surf_area ( tab_in , long , larg , scale_xyz , aire ) !================================================================================================ !! Function that returns the relative area of a surface minus 1. !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: scale_xyz !! *scale along x, y, z* real ( kind = R8 ), intent ( out ) :: aire !! *computed area* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *surface array* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: z1 , z2 , z3 , z4 , hx , hy , hz hx = scale_xyz ( 1 ) hy = scale_xyz ( 2 ) hz = scale_xyz ( 3 ) ! Raisonnement sur chaque carré du domaine aire = 0. do j = 1 , larg - 1 do i = 1 , long - 1 z1 = tab_in ( i , j ) * hz z2 = tab_in ( i , j + 1 ) * hz z3 = tab_in ( i + 1 , j + 1 ) * hz z4 = tab_in ( i + 1 , j ) * hz aire = aire + 0.5_R8 * ( sqrt ( 1._R8 + ( ( z1 - z2 ) / hx ) ** 2 + ( ( z1 - z4 ) / hy ) ** 2 ) + & ! sqrt ( 1._R8 + ( ( z3 - z2 ) / hy ) ** 2 + ( ( z3 - z4 ) / hx ) ** 2 ) ) ! enddo enddo aire = aire / ( ( long - 1 ) * ( larg - 1 ) ) - 1._R8 return endsubroutine surf_area endmodule morpho","tags":"","loc":"sourcefile/mod_morpho.f90.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~5~~EfferentGraph sourcefile~prg.f90~5 prg.f90 sourcefile~mod_anisotropy.f90 mod_anisotropy.f90 sourcefile~prg.f90~5->sourcefile~mod_anisotropy.f90 sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_filter.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: november, 01 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Anisotropy detection. Example of use** !<  </span> program test_anisotropy use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use surfile , only : init_scal , read_surf , write_surf , SCALE_SURF , unit2IUf use fftw3 use anisotropy !$ use omp_lib implicit none integer ( kind = I4 ), parameter :: nx = 800 , ny = 400 real ( kind = R8 ), allocatable , dimension (:,:) :: array , array_tmp real ( kind = R8 ), dimension ( 1 : 3 ) :: ell_param real ( kind = R8 ), dimension ( 1 : 2 ) :: ech_param real ( kind = R8 ), dimension ( 1 : 8 ) :: param_acv real ( kind = R8 ), dimension ( 1 : 9 ) :: param_ani real ( kind = R8 ), dimension ( 1 : 2 ) :: scale_xy real ( kind = R8 ) :: lx , dx , dy type ( SCALE_SURF ) :: scal_surf integer ( kind = I4 ) :: nnx , nny , n_th , nx2 , ny2 !----------------------------------------------------------------------------------------------------------------- call read_surf ( nom_fic = \"sur/test1.sur\" , & ! tab_s = array , & ! scal = scal_surf ) ! nnx = scal_surf % xres nny = scal_surf % yres scale_xy = [ scal_surf % dx * unit2IUf ( scal_surf % dx_unit ), & ! scal_surf % dy * unit2IUf ( scal_surf % dy_unit ) ] ! n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) nx2 = 2 * ( nint ( PAD_FFT * nnx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT * nny ) / 2 ) call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! call multiple_anisotropy ( tabin = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! scale_xy = scale_xy , & ! multi_fft = . false ., & ! vec_ani = param_ani ( 1 : 9 ) ) ! call end_fftw3 () write ( * , '(e12.4, T20, a)' ) param_ani ( 1 ) , 'bmp, maximum over [0,179°] of the peaks mean width' write ( * , '(e12.4, T20, a)' ) param_ani ( 2 ) , 'smp, minimum over [0,179°] of the peaks mean width' write ( * , '(e12.4, T20, a)' ) param_ani ( 3 ) , 'rmp, ratio bmp/smp' write ( * , '(e12.4, T20, a)' ) param_ani ( 4 ) , 'bml, maximum over [0,179°] of the path length' write ( * , '(e12.4, T20, a)' ) param_ani ( 5 ) , 'sml, minimum over [0,179°] of the path length' write ( * , '(e12.4, T20, a)' ) param_ani ( 6 ) , 'rml, ratio bml/sml' write ( * , '(e12.4, T20, a)' ) param_ani ( 7 ) , 'bms, maximum over [0,179°] of the standard deviation of slope' write ( * , '(e12.4, T20, a)' ) param_ani ( 8 ) , 'sms, minimum over [0,179°] of the standard deviation of slope' write ( * , '(e12.4, T20, a)' ) param_ani ( 9 ) , 'rms, ratio bms/sms' deallocate ( array ) !----------------------------------------------------------------------------------------------------------------- ell_param = [ 4 0.e-6_R8 , 1 0.e-6_R8 , 2 5._R8 ] ! big semi-axis, small semi-axis, angle (°) ech_param = [ 0.25e-6_R8 , 0.25e-6_R8 ] ! scale x (m/pix), scale_y (m/pix) ! domain is (800 * 0.25e-6) X (400 * 0.25e-6) = 200 µm X 100 µm call fake_acv ( acv_array = array , & ! long = nx , & ! larg = ny , & ! param = ell_param ( 1 : 3 ), & ! ech = ech_param ( 1 : 2 ) ) ! call init_scal ( scal = scal_surf , & ! nx = nx , & ! ny = ny , & ! lx = nx * ech_param ( 1 ), & ! ly = ny * ech_param ( 2 ), & ! unit_z = 'm ' ) ! call write_surf ( nom_fic = \"out/fake_acv.sur\" , & ! tab_s = array ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! call ellipse_acf ( tabin = array ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! p_acv = param_acv ( 1 : 8 ), & ! cut = 0.5_R8 , & ! scale_xy = ech_param ( 1 : 2 ), & ! omp = . true . ) ! write ( * , '(    a, T20, a)' ) '************' , '*******************************************************************' write ( * , '(e12.4, T20, a)' ) param_acv ( 1 ) , 'axe_a,                                ellipsis big axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 2 ) , 'axe_b,                                ellipsis small axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 3 ) , 'axe_a/axe_b                           another anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 4 ) , 'nint(angle/inc_a),                    main texture orientation' write ( * , '(e12.4, T20, a)' ) param_acv ( 5 ) , 'ray_pente,                            radius of greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 6 ) , 'max_pente,                            greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 7 ) , 'max_pente/min_pente                   slope anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 8 ) , 'highest curvature/smallest curvature, curvature anisotropy factor' deallocate ( array ) !----------------------------------------------------------------------------------------------------------------- allocate ( array ( 1 : nx , 1 : ny ) ) allocate ( array_tmp ( 1 : nx , 1 : ny ) ) array ( 1 : nx , 1 : ny ) = 1 call apod ( tab_in = array ( 1 : nx , 1 : ny ), & ! tab_out = array_tmp ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! type_apo = 'tuckey' ) ! call write_surf ( nom_fic = \"out/apod_tuckey.sur\" , & ! tab_s = array_tmp ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! call apod ( tab_in = array ( 1 : nx , 1 : ny ), & ! tab_out = array_tmp ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! type_apo = 'blackm' ) ! call write_surf ( nom_fic = \"out/apod_blackman.sur\" , & ! tab_s = array_tmp ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! call apod ( tab_in = array ( 1 : nx , 1 : ny ), & ! tab_out = array_tmp ( 1 : nx , 1 : ny ), & ! long = nx , & ! larg = ny , & ! type_apo = 'hann__' ) ! call write_surf ( nom_fic = \"out/apod_hann.sur\" , & ! tab_s = array_tmp ( 1 : nx , 1 : ny ), & ! scal = scal_surf ) ! deallocate ( array , array_tmp ) !----------------------------------------------------------------------------------------------------------------- allocate ( array_tmp ( 1 : nx , 1 : ny ) ) call read_surf ( nom_fic = \"sur/verif_corr.sur\" , & ! tab_s = array , & ! scal = scal_surf ) ! nnx = scal_surf % xres nny = scal_surf % yres ! let suppose that the length along x is 100 µm lx = 10 0.e-6_R8 ; dx = lx / nnx ; dy = dx n_th = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = n_th ) nx2 = 2 * ( nint ( PAD_FFT * nnx ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT * nny ) / 2 ) call init_fftw3 ( long = nx2 , & ! larg = ny2 ) ! ! results gwyddion : correlation length between 3.7 and 4.2 µm !                    no particular angle call correlation_parameters ( tab = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! res = param_acv ( 1 : 8 ), & ! cut = 0.5_R8 , & ! sub_plane = . true ., & ! scale_xy = [ dx , dy ], & ! omp = . true . ) ! write ( * , '(    a, T20, a)' ) '************' , '*******************************************************************' write ( * , '(e12.4, T20, a)' ) param_acv ( 1 ) , 'axe_a,                                ellipsis big axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 2 ) , 'axe_b,                                ellipsis small axis' write ( * , '(e12.4, T20, a)' ) param_acv ( 3 ) , 'axe_a/axe_b                           another anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 4 ) , 'nint(angle/inc_a),                    main texture orientation' write ( * , '(e12.4, T20, a)' ) param_acv ( 5 ) , 'ray_pente,                            radius of greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 6 ) , 'max_pente,                            greatest slope' write ( * , '(e12.4, T20, a)' ) param_acv ( 7 ) , 'max_pente/min_pente                   slope anisotropy factor' write ( * , '(e12.4, T20, a)' ) param_acv ( 8 ) , 'highest curvature/smallest curvature, curvature anisotropy factor' call end_fftw3 () deallocate ( array ) stop contains subroutine fake_acv ( acv_array , long , larg , param , ech ) implicit none real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: acv_array integer ( kind = I4 ), intent ( in ) :: long , larg real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: param real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: ech integer ( kind = I4 ) :: i , j , ia , ib , i0 , j0 real ( kind = R8 ) :: a , b , ang , c , s , echx , echy allocate ( acv_array ( 1 : long , 1 : larg ) ) a = param ( 1 ) b = param ( 2 ) ang = param ( 3 ) echx = ech ( 1 ) echy = ech ( 2 ) ia = int ( a / echx ) ib = int ( b / echy ) i0 = long / 2 + 1 j0 = larg / 2 + 1 c = cos ( ang * PI_R8 / 180 ) s = sin ( ang * PI_R8 / 180 ) do j = 1 , larg do i = 1 , long acv_array ( i , j ) = exp ( log ( 1. / 2. ) * sqrt ( ( ( + c * ( i - i0 ) + s * ( j - j0 ) ) / ia ) ** 2 + & ! ( ( - s * ( i - i0 ) + c * ( j - j0 ) ) / ib ) ** 2 ) ) ! enddo enddo return endsubroutine fake_acv endprogram test_anisotropy !~ RESULTS --------------------------------------- !~   0.1997E-03       bmp, maximum over [0,179°] of the peaks mean width !~   0.1085E-04       smp, minimum over [0,179°] of the peaks mean width !~   0.1841E+02       rmp, ratio bmp/smp !~   0.2810E-02       bml, maximum over [0,179°] of the path length !~   0.2428E-03       sml, minimum over [0,179°] of the path length !~   0.1157E+02       rml, ratio bml/sml !~   0.1283E-02       bms, maximum over [0,179°] of the standard deviation of slope !~   0.3437E-03       sms, minimum over [0,179°] of the standard deviation of slope !~   0.3734E+01       rms, ratio bms/sms !~   0.3994E-04       axe_a,                                ellipsis big axis !~   0.1000E-04       axe_b,                                ellipsis small axis !~   0.3993E+01       axe_a/axe_b                           another anisotropy factor !~   0.2500E+02       nint(angle/inc_a),                    main texture orientation !~   0.5000E-06       ray_pente,                            radius of greatest slope !~   0.6709E+05       max_pente,                            greatest slope !~   0.3318E+01       max_pente/min_pente                   slope anisotropy factor !~   0.3258E-01       highest curvature/smallest curvature, curvature anisotropy factor !~ ************       ******************************************************************* !~   0.4284E-05       axe_a,                                ellipsis big axis !~   0.3831E-05       axe_b,                                ellipsis small axis !~   0.1118E+01       axe_a/axe_b                           another anisotropy factor !~   0.7700E+02       nint(angle/inc_a),                    main texture orientation !~   0.3906E-06       ray_pente,                            radius of greatest slope !~   0.1893E+06       max_pente,                            greatest slope !~   0.2458E+01       max_pente/min_pente                   slope anisotropy factor !~  -0.2528E+02       highest curvature/smallest curvature, curvature anisotropy factor","tags":"","loc":"sourcefile/prg.f90~5.html"},{"title":"mod_anisotropy.f90 – TPGLIB","text":"This file depends on sourcefile~~mod_anisotropy.f90~~EfferentGraph sourcefile~mod_anisotropy.f90 mod_anisotropy.f90 sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_filter.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_anisotropy.f90->sourcefile~mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_anisotropy.f90~~AfferentGraph sourcefile~mod_anisotropy.f90 mod_anisotropy.f90 sourcefile~prg.f90~5 prg.f90 sourcefile~prg.f90~5->sourcefile~mod_anisotropy.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: april, 08 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Subroutines for anisotropy detection in surfaces** !<  </span> module anisotropy use data_arch , only : I4 , R4 , R8 , PI_R8 , EPS_R8 , UN use miscellaneous , only : trans_corner2center , trans_center2corner , get_unit use sort_arrays , only : sort_array2 use tchebychev , only : least_squares_tcheby use fftw3 , only : apod , fftw_plan_with_nthreads , PAD_FFT , extend , calc_fftw3_real_fwd , calc_fftw3_real_bwd use stat_mom , only : calc_moments , MOMENT_STAT use filter , only : fft_filter use surfile , only : init_scal , write_surf , SCALE_SURF !$ use omp_lib implicit none real ( kind = R8 ) :: PAD_FFT_ANI !! *dimension multiplier for 0-padding* character ( len = 6 ) :: APO_FFT_ANI !! *dimension multiplier for 0-padding* !> {!ANISO/src/inc_doc/analyses.md!} !> {!css/button.html!} contains subroutine simple_anisotropy ( tabin , long , larg , vec_len , vec_pks , vec_slp , scale_xy , multi_fft ) !================================================================================================ !< @note Function that returns some anisotropy parameters calculated on a polar representation, !< for each angle from 0 to 179 !< !< + the excess of length !< + the RMS slope !< + the mean peak width !< !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface width* logical ( kind = I4 ), intent ( in ) :: multi_fft !! *parallel ffts?* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *surface acf array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x, y* real ( kind = R8 ), intent ( out ), dimension ( 0 : 179 ) :: vec_len !! *vector containing path length ratios* real ( kind = R8 ), intent ( out ), dimension ( 0 : 179 ) :: vec_pks !! *vector containing peak mean width* real ( kind = R8 ), intent ( out ), dimension ( 0 : 179 ) :: vec_slp !! *vector containing RMS slopes* integer ( kind = I4 ) :: lo , la , ll , nx , ny , ird integer ( kind = I4 ) :: p , q , k , nb_cross , nb_peak real ( kind = R8 ) :: scx , scy , dr , s , c real ( kind = R8 ) :: mx , my , reg_a , reg_b real ( kind = R8 ) :: h1 , h2 , h3 , h4 , hh real ( kind = R8 ) :: inc_a , theta , x , y , xb , yb , xm , ym , xp , yp , tmp real ( kind = R8 ), allocatable , dimension (:,:) :: height_disc real ( kind = R8 ), allocatable , dimension (:) :: vec_tmp , slope integer ( kind = I4 ), allocatable , dimension (:) :: cross , peaks ! lags in micron scx = scale_xy ( 1 ) ! x lag scy = scale_xy ( 2 ) ! y lag ! define the surface center location if ( long == 2 * ( long / 2 ) ) then ; lo = long / 2 + 1 ; else ; lo = long / 2 ; endif if ( larg == 2 * ( larg / 2 ) ) then ; la = larg / 2 + 1 ; else ; la = larg / 2 ; endif ! define the square length embedded in the surface ll = min ( lo , la ) - 1 allocate ( height_disc ( 0 : ll , 0 : 359 ) ) allocate ( vec_tmp ( 0 : 2 * ll ) ) allocate ( cross ( 1 : 2 * ll ) ) allocate ( slope ( 1 : 2 * ll ) ) allocate ( peaks ( 1 : 2 * ll ) ) ! angle increment inc_a = 2 * PI_R8 / 360 ! determination of heights on a diameter of the rosette, obtained by linear interpolation: ! a point \"falls\" into a rectangular element [h1,h2,h3,h4], its height is determined by linear interpolation. !* Calculate heights along the radius for each angular position. do p = 0 , ll ! point number on a radius ird = p ! point radius do q = 0 , 359 ! point angular location (°) theta = q * inc_a ! angular location (rad) ! projection on x and y of the point determined by its radius and angle ! by taking the floor, we get the number of the lower row and the left column of the rectangle ! the remainder (x-nx) thus represents the abscissa of the point in the rectangle with sides=1 x = lo + ird * cos ( theta ) if ( abs ( x - nint ( x )) < 1.e-3_R8 ) then nx = nint ( x ) else nx = floor ( x ) endif xb = x - nx y = la + ird * sin ( theta ) if ( abs ( y - nint ( y )) < 1.e-3_R8 ) then ny = nint ( y ) else ny = floor ( y ) endif yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= long . and . ny + 1 <= larg . and . & ! nx >= 1 . and . ny >= 1 ) then ! note ird may be greater than lo or la h1 = tabin ( nx , ny ) h2 = tabin ( nx + 1 , ny ) h3 = tabin ( nx + 1 , ny + 1 ) h4 = tabin ( nx , ny + 1 ) hh = h1 * xm * ym + & ! h2 * xp * ym + & ! h3 * xp * yp + & ! h4 * xm * yp ! height_disc ( p , q ) = hh endif enddo ! q = 0, 359 enddo ! p = 0, ll ! centering tmp = sum ( height_disc ( 0 : ll , 0 : 359 ) ) / ( ( ll + 1 ) * 360 ) height_disc ( 0 : ll , 0 : 359 ) = height_disc ( 0 : ll , 0 : 359 ) - tmp ! for each degree, determine the mean peak width and the path length ratio do q = 0 , 359 - 180 do p = ll , 1 , - 1 ; vec_tmp ( ll - p ) = height_disc ( p , q + 180 ) ; enddo ! left part of the height vector do p = 0 , ll , + 1 ; vec_tmp ( ll + p ) = height_disc ( p , q ) ; enddo ! right part theta = q * inc_a ; s = sin ( theta ) ; c = cos ( theta ) ! element length, usually scx=scy dr = sqrt ( ( s * scx ) ** 2 + ( c * scy ) ** 2 ) ! path relative length  ----------------------------------------------------------------------------------------------- ! tmp = 0. do p = 1 , 2 * ll tmp = tmp + sqrt ( dr ** 2 + ( vec_tmp ( p ) - vec_tmp ( p - 1 )) ** 2 ) enddo vec_len ( q ) = tmp / ( 2 * ll * dr ) - 1. ! path absolute slope  ------------------------------------------------------------------------------------------------ ! do p = 1 , 2 * ll slope ( p ) = ( vec_tmp ( p ) - vec_tmp ( p - 1 ) ) / dr enddo tmp = sum ( slope ( 1 : 2 * ll ) ) / ( 2 * ll ) slope ( 1 : 2 * ll ) = slope ( 1 : 2 * ll ) - tmp vec_slp ( q ) = sqrt ( sum ( slope ( 1 : 2 * ll ) ** 2 ) ) / ( 2 * ll ) ! find each abscissa point where the height crosses z=0 ----------------------------------------------------------------- ! !------- subtract mean profile (least square) mx = ( ll + 1 ) * dr ! x mean x = 0, dr, 2*dr, ..., 2*ll*dr my = sum ( vec_tmp ( 0 : 2 * ll ) ) / ( 2 * ll + 1 ) ! y mean reg_a = 0 tmp = 0 do p = 0 , 2 * ll reg_a = reg_a + ( p * dr - mx ) * ( vec_tmp ( p ) - my ) tmp = tmp + ( p * dr - mx ) ** 2 enddo reg_a = reg_a / tmp ! first regressor reg_b = my - reg_a * mx ! second regressor do p = 0 , 2 * ll vec_tmp ( p ) = vec_tmp ( p ) - ( reg_a * p * dr + reg_b ) enddo !------- find peaks cross ( 1 : 2 * ll ) = 0 peaks ( 1 : 2 * ll ) = 0 k = 1 cross ( k ) = 0 do p = 1 , 2 * ll if ( vec_tmp ( p - 1 ) * vec_tmp ( p ) < 0. ) then ! the height crosses z=0 k = k + 1 cross ( k ) = p endif enddo k = k + 1 cross ( k ) = 2 * ll nb_cross = k ! determine the peak width ! k = 0 do p = 1 , nb_cross - 1 if ( vec_tmp ( ( cross ( p + 1 ) + cross ( p )) / 2 ) > 0 ) then ! it must be a peak k = k + 1 peaks ( k ) = cross ( k + 1 ) - cross ( k ) endif enddo nb_peak = k ! mean peak width ! if ( nb_peak > 0 ) then vec_pks ( q ) = dr * sum ( peaks ( 1 : nb_peak ) ) / nb_peak else vec_pks ( q ) = dr * 2 * ll endif enddo deallocate ( height_disc , vec_tmp , cross , peaks , slope ) return endsubroutine simple_anisotropy subroutine multiple_anisotropy ( tabin , long , larg , scale_xy , multi_fft , vec_ani ) !================================================================================================ !< @note Function that returns simple_anisotropy min, max and max/min for different Gaussian filter !< cutoff !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface width* logical ( kind = I4 ), intent ( in ) :: multi_fft !! *parallel ffts?* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *surface acf array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x and y* real ( kind = R8 ), intent ( out ), dimension ( 1 : 9 ) :: vec_ani !! *anisotropy parameters* integer ( kind = I4 ) :: icut , i real ( kind = R8 ) :: dx , dy , fft_cutoff , length real ( kind = R8 ) :: max_mean_pks , min_mean_pks , rat_mean_pks , max_mean_len real ( kind = R8 ) :: min_mean_len , rat_mean_len , max_mean_slp , min_mean_slp , rat_mean_slp character ( len = 2 ) :: str real ( kind = R8 ), dimension ( 0 : 179 ) :: mean_len , mean_pks , mean_slp real ( kind = R8 ), allocatable , dimension (:,:) :: bf_tab real ( kind = R8 ), allocatable , dimension (:,:) :: mat_len !! *array containing anisotropy outputs* real ( kind = R8 ), allocatable , dimension (:,:) :: mat_pks !! *array containing anisotropy outputs* real ( kind = R8 ), allocatable , dimension (:,:) :: mat_slp !! *array containing anisotropy outputs* type ( SCALE_SURF ) :: scal_surf allocate ( bf_tab ( 1 : long , 1 : larg ) ) dx = scale_xy ( 1 ) ! x lag dy = scale_xy ( 2 ) ! y lag length = dx / 1.e-6 ! base cutoff = 1 µm allocate ( mat_len ( 0 : 179 , 1 : 10 ) ) allocate ( mat_pks ( 0 : 179 , 1 : 10 ) ) allocate ( mat_slp ( 0 : 179 , 1 : 10 ) ) call init_scal ( scal = scal_surf , & ! nx = long , & ! ny = larg , & ! lx = long * dx , & ! ly = larg * dy , & ! unit_z = 'nm' ) ! do icut = 1 , 10 fft_cutoff = length / icut call fft_filter ( tab = tabin ( 1 : long , 1 : larg ), & ! in long = long , & ! in larg = larg , & ! in cutoff = fft_cutoff , & ! in bf_tab = bf_tab ( 1 : long , 1 : larg ), & ! out multi_fft = multi_fft ) ! in write ( str , '(i2.2)' ) icut if (. false .) then call write_surf ( nom_fic = \"out/bf_tab\" // str // \".sur\" , & ! tab_s = bf_tab ( 1 : long , 1 : larg ), & ! scal = scal_surf ) ! endif call simple_anisotropy ( tabin = bf_tab ( 1 : long , 1 : larg ), & ! in long = long , & ! in larg = larg , & ! in vec_len = mat_len ( 0 : 179 , icut ), & ! out   path length ratios vec_pks = mat_pks ( 0 : 179 , icut ), & ! out   peak mean width vec_slp = mat_slp ( 0 : 179 , icut ), & ! out   RMS slopes scale_xy = scale_xy ( 1 : 2 ), & ! in multi_fft = multi_fft ) ! in enddo do i = 0 , 179 mean_pks ( i ) = sum ( mat_pks ( i , 06 : 10 ) ) / 5. ! mean on smoother profiles mean_len ( i ) = sum ( mat_len ( i , 01 : 05 ) ) / 5. mean_slp ( i ) = sum ( mat_slp ( i , 01 : 05 ) ) / 5. enddo deallocate ( bf_tab , mat_len , mat_pks , mat_slp ) max_mean_pks = maxval ( mean_pks ( 0 : 179 ) ) ! robust maximum of the peak mean width min_mean_pks = minval ( mean_pks ( 0 : 179 ) ) !        minimum rat_mean_pks = max_mean_pks / min_mean_pks ! ratio max_mean_len = maxval ( mean_len ( 0 : 179 ) ) ! robust maximum of the path length ratio min_mean_len = minval ( mean_len ( 0 : 179 ) ) !        minimum rat_mean_len = max_mean_len / min_mean_len ! ratio max_mean_slp = maxval ( mean_slp ( 0 : 179 ) ) ! robust maximum of the RMS slopes min_mean_slp = minval ( mean_slp ( 0 : 179 ) ) !        minimum rat_mean_slp = max_mean_slp / min_mean_slp ! ratio vec_ani ( 1 : 9 ) = [ max_mean_pks , min_mean_pks , rat_mean_pks , & ! max_mean_len , min_mean_len , rat_mean_len , & ! max_mean_slp , min_mean_slp , rat_mean_slp ] ! return endsubroutine multiple_anisotropy subroutine ellipse_acf ( tabin , long , larg , p_acv , cut , scale_xy , omp ) !================================================================================================ !< @note Function that returns p_acv which contains parameters on anisotropy. !< !<  - p_acv(1) = axe_a,                                ellipsis big axis !<  - p_acv(2) = axe_b,                                ellipsis small axis !<  - p_acv(3) = axe_a/axe_b                           another anisotropy factor !<  - p_acv(4) = nint(angle/inc_a),                    main texture orientation !<  - p_acv(5) = ray_pente,                            radius of greatest slope !<  - p_acv(6) = max_pente,                            greatest slope !<  - p_acv(7) = max_pente/min_pente                   slope anisotropy factor !<  - p_acv(8) = highest curvature/smallest curvature, curvature anisotropy factor !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface width* logical ( kind = I4 ), intent ( in ) :: omp !! *multithreaded ?* real ( kind = R8 ), intent ( in ), optional :: cut !! *cut height* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tabin !! *surface acf array* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x and y in micrometers* real ( kind = R8 ), intent ( out ), dimension ( 1 : 8 ) :: p_acv !! *vector containing anisotropy outputs* integer ( kind = I4 ) :: i , k , ll , p , q , qp , qm , nb_p , nx , ny , lo2 , la2 , funit , nb_th logical ( kind = I4 ) :: verif real ( kind = R8 ) :: x , y , xb , yb , xm , ym , xp , yp , inc_a real ( kind = R8 ) :: r , r1 , rc , theta , h0 , hh , h1 , h2 , h3 , h4 , coupe , pente_locale , pente_locale_precede real ( kind = R8 ) :: angle , axe_a , axe_b , ech_x , ech_y , ech_z , ech_r real ( kind = R8 ) :: min_pente , max_pente , ray_pente real ( kind = R8 ) :: c , s integer ( kind = I4 ), dimension ( 0 : 179 ) :: p_min , e_angle integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max !, imax_acv real ( kind = R8 ), dimension ( 0 : 179 ) :: pente_max real ( kind = R8 ), dimension ( 0 : 359 ) :: ellipse real ( kind = R8 ), allocatable , dimension (:,:) :: tabou , tab_tmp real ( kind = R8 ), allocatable , dimension (:) :: courbure ech_x = scale_xy ( 1 ) !SCALE_IMG%dx * unit2IUf(SCALE_IMG%dx_unit) / 1.e-6  ! x lag in micron ech_y = scale_xy ( 2 ) !SCALE_IMG%dy * unit2IUf(SCALE_IMG%dy_unit) / 1.e-6  ! y lag in micron ech_z = 1. ! acf(0,0) = 1 loc_max ( 1 : 2 ) = maxloc ( tabin ( 1 : long , 1 : larg ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) !  on prend une surface carrée inscrite ll = min ( lo2 , la2 ) - 1 allocate ( tabou ( 0 : ll , 0 : 359 ) ) allocate ( courbure ( 0 : 359 ) ) tabou = EPS_R8 courbure = EPS_R8 !~       ! avec fftw, il faut mettre le max de l'acv en (lo2,la2) !~       imax_acv = maxloc( tabin(1:long, 1:larg) ) allocate ( tab_tmp ( 1 : long , 1 : larg ) ) tab_tmp ( 1 : long , 1 : larg ) = tabin ( 1 : long , 1 : larg ) verif = . false . if ( verif ) then ! sortie xyz call get_unit ( funit ) open ( funit , file = 'out/test_pol.dat' ) endif !  angle increment for polar representation of the rosette inc_a = 2 * PI_R8 / 360 !  determination of heights on a rosette diameter, obtained by linear interpolation : !  a point “falls” into a rectangular element [h1,h2,h3,h4], its height is determined by lin. interp. nb_p = 0 nb_th = 1 if ( omp ) nb_th = omp_get_num_procs () !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) IF (omp) !$OMP DO SCHEDULE (STATIC,(ll+1)/nb_th) PRIVATE(p,r,q,theta,x,y,xm,ym,h1,h2,h3,h4,hh) do p = 0 , ll !  identifying a point on the diameter r = p !  corresponding algebraic radius do q = 0 , 359 !  angular increment identification theta = q * inc_a !  projection on x and y of the point marked by its radius and angle, taking the lower integer, !  gives the number of the bottom line and left-hand column of the rectangle !  the remainder (x-nx) represents the abscissa of the point in the rectangle with sides=1 !  the 0.9999 coefficient is used to avoid falling right on an existing point x = lo2 + r * cos ( theta ) * 0.9999_R8 ; nx = floor ( x ) ; xb = x - nx y = la2 + r * sin ( theta ) * 0.9999_R8 ; ny = floor ( y ) ; yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= long . and . ny + 1 <= larg . and . & nx >= 1 . and . ny >= 1 ) then ! attention r may be greater than lo2 or la2 h1 = tab_tmp ( nx , ny ) h2 = tab_tmp ( nx + 1 , ny ) h3 = tab_tmp ( nx + 1 , ny + 1 ) h4 = tab_tmp ( nx , ny + 1 ) hh = h1 * xm * ym + h2 * xp * ym + h3 * xp * yp + h4 * xm * yp tabou ( p , q ) = hh nb_p = nb_p + 1 else hh = 0. endif if ( verif ) write ( funit , * ) real ( x , kind = R4 ), real ( y , kind = R4 ), real ( hh , kind = R4 ) enddo enddo !$OMP END DO !$OMP END PARALLEL deallocate ( tab_tmp ) if ( verif ) close ( funit ) if ( present ( cut ) ) then coupe = cut else coupe = 0.5 endif do q = 0 , 359 !  angle en deg theta = q * inc_a !  angle en rad ech_r = sqrt ( ( ech_x * cos ( theta )) ** 2 + & ! ( ech_y * sin ( theta )) ** 2 ) !  unit according to angle q ellipse ( q ) = ( ll - 1 ) * ech_r !  max value of ellipse radius do p = 0 , ll - 1 !  identifying a point on the diameter r1 = p !  algebraic radius h1 = tabou ( p , q ) h2 = tabou ( p + 1 , q ) if ( abs ( h2 ) < 10 * EPS_R8 ) exit !  useful for ll = floor(sqrt(UN*(lo2**2 +la2**2))) -1 if ( h1 > coupe . and . h2 < coupe ) then rc = r1 + ( h1 - coupe ) / ( h1 - h2 ) ellipse ( q ) = rc * ech_r exit ! if you don't pass here: no intersection with the cutting plane -> max value taken by default endif enddo ! curvature averaged over 3 points rc = 0 do p = 1 , 3 h0 = tabou ( p - 1 , q ) h1 = tabou ( p , q ) h2 = tabou ( p + 1 , q ) if ( abs ( h2 ) < 10 * EPS_R8 ) exit !  useful for ll = floor(sqrt(UN*(lo2**2 +la2**2))) -1 rc = rc + ( h0 - 2 * h1 + h2 ) enddo courbure ( q ) = - ( rc / ( 2 * ech_r ** 2 ) ) / 3. enddo do q = 0 , 179 e_angle ( q ) = 2 * q ! angle doubled for the continuity of sin and cos enddo call sort_array2 ( tab_inout = ellipse ( 0 : 179 ), & ! tab1 = e_angle ( 0 : 179 ), & ! n = 180 ) ! axe_b = sum ( ellipse ( 0 : 2 )) / 3. axe_a = sum ( ellipse ( 177 : 179 )) / 3. c = sum ( cos ( e_angle ( 175 : 179 ) * PI_R8 / 180 ) ) / 5. s = sum ( sin ( e_angle ( 175 : 179 ) * PI_R8 / 180 ) ) / 5. angle = atan2 ( s , c ) * 180 / PI_R8 / 2 ! angle halfed (see above) p_acv ( 1 ) = axe_a p_acv ( 2 ) = axe_b p_acv ( 3 ) = axe_a / axe_b p_acv ( 4 ) = nint ( angle ) !----------------------------------------------- p_min ( 0 : 179 ) = ll - 1 do q = 0 , 179 !  incrément angulaire qp = q + 1 ; if ( qp > 179 ) qp = 0 qm = q - 1 ; if ( qm < 0 ) qm = 179 theta = q * inc_a ech_r = sqrt ( ( ech_x * cos ( theta )) ** 2 + & ! ( ech_y * sin ( theta )) ** 2 ) !  unit according to angle q pente_locale_precede = 0._R8 do p = 1 , ll - 1 pente_locale = ( ( tabou ( p + 1 , q ) - tabou ( p - 1 , q )) / 2 ) ** 2 + & ! ( ( tabou ( p , qp ) - tabou ( p , qm )) / ( 2 * p * inc_a ) ) ** 2 ! pente_locale = sqrt ( pente_locale ) * ech_z / ech_r if ( abs ( pente_locale ) < abs ( pente_locale_precede ) ) then p_min ( q ) = p !  the steepest slope distance is recorded exit else pente_locale_precede = pente_locale endif enddo enddo call sort_array2 ( tab_inout = p_min ( 0 : 179 ), & ! n = 180 ) ! k = int ( sum ( p_min ( 0 : 4 ) ) / 5. , kind = I4 ) !  the minimum distance do q = 0 , 179 !  angular increment qp = q + 1 ; if ( qp > 179 ) qp = 0 qm = q - 1 ; if ( qm < 0 ) qm = 179 theta = q * inc_a ech_r = sqrt ( ( ech_x * cos ( theta ) ) ** 2 + & ! ( ech_y * sin ( theta ) ) ** 2 ) !  unit according to angle q pente_locale = ( ( tabou ( k + 1 , q ) - tabou ( k - 1 , q )) / 2 ) ** 2 + & ! ( ( tabou ( k , qp ) - tabou ( k , qm )) / ( 2 * k * inc_a ) ) ** 2 ! pente_locale = sqrt ( pente_locale ) * ech_z / ech_r pente_max ( q ) = abs ( pente_locale ) !  for angle q, greater slope enddo do q = 0 , 179 e_angle ( q ) = q enddo call sort_array2 ( tab_inout = pente_max ( 0 : 179 ), & ! tab1 = e_angle ( 0 : 179 ), & ! n = 180 ) ! angle = sum ( e_angle ( 175 : 179 ) ) / 5. theta = angle * inc_a ech_r = sqrt ( ( ech_x * cos ( theta ) ) ** 2 + & ! ( ech_y * sin ( theta ) ) ** 2 ) !  unit according to angle q min_pente = sum ( pente_max ( 0 : 2 ) ) / 3. max_pente = sum ( pente_max ( 177 : 179 ) ) / 3. ray_pente = k * ech_r p_acv ( 5 ) = ray_pente p_acv ( 6 ) = max_pente p_acv ( 7 ) = max_pente / min_pente !  anisotropy indicator p_acv ( 8 ) = maxval ( courbure ( 0 : 359 ) ) / minval ( courbure ( 0 : 359 ) ) deallocate ( tabou , courbure ) return endsubroutine ellipse_acf subroutine acv ( tab_in , tab_out , long , larg ) !================================================================================================ !< @note Function that returns the *acf* of an array. !< !<  !< \\begin{align*} !<    acf(i,j) &= (z \\ast z)(i,j) = \\sum_{k,l}&#94;{n,n} z(k+1-i,l+1-j)z(k,l)  \\\\ !<    TF(acf)  &= ACF = Z \\cdot Z                                          \\\\ !<    acf      &= TF&#94;{-1}(ACF) = TF&#94;{-1}(Z&#94;2) !< \\end{align*} !<  !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *acf of the input array* integer ( kind = I4 ) :: nx2 , ny2 , iex , iey , ibx , iby , i , j , lo2 , la2 real ( kind = R8 ) :: tmp integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max complex ( kind = R8 ), dimension (:,:), allocatable :: cmpl real ( kind = R8 ), dimension (:,:), allocatable :: tab_ext1 , tab_ext2 type ( SCALE_SURF ) :: scal_surf type ( MOMENT_STAT ) :: m_res ! 0-padding if ( PAD_FFT_ANI < 0 ) then nx2 = long ny2 = larg ibx = 1 ; iex = long iby = 1 ; iey = larg else nx2 = 2 * ( nint ( PAD_FFT_ANI * long ) / 2 ) ny2 = 2 * ( nint ( PAD_FFT_ANI * larg ) / 2 ) ibx = max ( ceiling ( ( nx2 - long ) / 2. ), 1 ) ; iex = ibx + long - 1 iby = max ( ceiling ( ( ny2 - larg ) / 2. ), 1 ) ; iey = iby + larg - 1 endif allocate ( tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! tab_ext2 ( 1 : nx2 , 1 : ny2 ) ) ! allocate ( cmpl ( 1 : nx2 , 1 : ny2 ) ) ! tab_ext1 ( 1 : nx2 , 1 : ny2 ) = 0 call calc_moments ( tab = tab_in ( 1 : long , 1 : larg ), & ! mx = m_res , & ! nb_mom = 2 ) ! tab_ext1 ( ibx : iex , iby : iey ) = ( tab_in ( 1 : long , 1 : larg ) - m_res % mu ) / m_res % si if ( APO_FFT_ANI /= \"no_apo\" ) then call apod ( tab_in = tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! tab_out = tab_ext2 ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 , & ! type_apo = trim ( APO_FFT_ANI ), & ! param = 0.1_R8 ) ! else tab_ext2 ( 1 : nx2 , 1 : ny2 ) = tab_ext1 ( 1 : nx2 , 1 : ny2 ) endif !---------------- call calc_fftw3_real_fwd ( tab_in = tab_ext2 ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = cmpl ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! cmpl ( 1 : nx2 , 1 : ny2 ) = cmplx ( abs ( cmpl ( 1 : nx2 , 1 : ny2 ) ) ** 2 , 0 , kind = R8 ) ! théorème de wiener call calc_fftw3_real_bwd ( tab_in = cmpl ( 1 : nx2 , 1 : ny2 ), & ! tab_ou = tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! call trans_corner2center ( tab_in = tab_ext1 ( 1 : nx2 , 1 : ny2 ), & ! tab_out = tab_ext2 ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 ) ! tab_out ( 1 : long , 1 : larg ) = tab_ext2 ( ibx : iex , iby : iey ) ! normalisation loc_max ( 1 : 2 ) = maxloc ( tab_out ( 1 : long , 1 : larg ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) tmp = tab_out ( lo2 , la2 ) tab_out ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) / tmp if (. true .) then call init_scal ( scal = scal_surf , & ! nx = long , & ! ny = larg , & ! lx = 1._R8 , & ! ly = 1._R8 , & ! unit_z = 'm ' ) ! call write_surf ( nom_fic = \"test_acv.sur\" , & ! tab_s = tab_out ( 1 : long , 1 : larg ), & ! scal = scal_surf ) ! endif deallocate ( cmpl ) deallocate ( tab_ext1 , tab_ext2 ) return endsubroutine acv subroutine correlation_parameters ( tab , long , larg , res , cut , sub_plane , scale_xy , omp ) !================================================================================================ !< @note Function that returns [[ellipse_acf]] parameters calculated on the autocorrelation !< function. But prior to the acf calculation, the mean plane is subtracted. !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array height* logical ( kind = I4 ), intent ( in ) :: sub_plane !! *subtract least square plane ?* logical ( kind = I4 ), intent ( in ) :: omp !! *multithreaded ?* real ( kind = R8 ), intent ( in ), optional :: cut !! *cut height* real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: scale_xy !! *lag along x and y in micrometers* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab !! *2D array in* real ( kind = R8 ), intent ( out ), dimension ( 1 : 8 ) :: res !! *correlation parameters* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ) :: tab_tmp1 , tab_tmp2 if ( sub_plane ) then ! mean plane subtracted call least_squares_tcheby ( tab_in = tab ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp1 ( 1 : long , 1 : larg ), & ! OUT long1 = long , & ! IN long2 = larg , & ! IN nvarx = 1 , & ! IN nvary = 1 ) ! IN tab_tmp1 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) - tab_tmp1 ( 1 : long , 1 : larg ) else tab_tmp1 ( 1 : long , 1 : larg ) = tab ( 1 : long , 1 : larg ) endif call acv ( tab_in = tab_tmp1 ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp2 ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg ) ! IN call ellipse_acf ( tabin = tab_tmp2 ( 1 : long , 1 : larg ), & ! IN long = long , & ! IN larg = larg , & ! IN p_acv = res ( 1 : 8 ), & ! OUT cut = cut , & ! IN scale_xy = scale_xy , & ! IN omp = omp ) ! IN return endsubroutine correlation_parameters endmodule anisotropy","tags":"","loc":"sourcefile/mod_anisotropy.f90.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~6~~EfferentGraph sourcefile~prg.f90~6 prg.f90 sourcefile~mod_grad_curv.f90 mod_grad_curv.f90 sourcefile~prg.f90~6->sourcefile~mod_grad_curv.f90 sourcefile~mod_filter.f90 mod_filter.f90 sourcefile~mod_grad_curv.f90->sourcefile~mod_filter.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~mod_filter.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: may, 3 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Surface gradients and curvatures. Example of use.** !<  </span> program test_grad_curv use grad_curv , only : test_labelize_point , test_label_surf_summits , test_peaks_and_pits_curvatures implicit none call test_label_surf_summits () call test_labelize_point () call test_peaks_and_pits_curvatures () stop !~  expected output: !~            9          10           9 !~  numerical h      :    1.8512999999999997       ; theoretical h      :    1.8512999999999999 !~  numerical dhdx   :  -0.44879999999999987       ; theoretical dhdx   :  -0.44879999999999992 !~  numerical dhdy   :   -1.3200000000000001       ; theoretical dhdy   :   -1.3200000000000001 !~  numerical d2hdx2 :    1.7952000000000008       ; theoretical d2hdx2 :    1.7951999999999999 !~  numerical d2hdy2 :   -4.1249999999999991       ; theoretical d2hdy2 :   -4.1250000000000000 !~  numerical d2hdxdy:   0.31999999999999984       ; theoretical d2hdxdy:   0.31999999999999995 !~  theoretical xx0:  -0.10000000000000001      numerical xx0:   -9.9999999744180723E-002 !~  theoretical yy0:   0.20000000000000001      numerical yy0:   0.19999999780599384 !~  theoretical point: S numerical point: S !~  nx, ny =         1551        1555 !~  dx, dy =    1.2899998437499999E-007   1.2899998437499999E-007 !~  S_param_grad:    9.1818702650203546E-002 !~  S_param_curv:    32734.346139266941 !~  peak_curv:   -15965527969.430788 !~  pits_curv:    66825282090.434196 endprogram test_grad_curv","tags":"","loc":"sourcefile/prg.f90~6.html"},{"title":"prg.f90 – TPGLIB","text":"This file depends on sourcefile~~prg.f90~7~~EfferentGraph sourcefile~prg.f90~7 prg.f90 sourcefile~mod_morpho.f90 mod_morpho.f90 sourcefile~prg.f90~7->sourcefile~mod_morpho.f90 sourcefile~mod_stat_mom.f90 mod_stat_mom.f90 sourcefile~prg.f90~7->sourcefile~mod_stat_mom.f90 sourcefile~mod_morpho.f90->sourcefile~mod_stat_mom.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: april, 06 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<        **Morphological operations.  Example of use.** !<  </span> program test_morpho use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use surfile , only : init_scal , read_surf , write_surf , SCALE_SURF use sort_arrays , only : sort_array2 use stat_mom , only : calc_moments , moment_stat use morpho , only : calcul_normales , surf_area , count_cell , erode_dilate , def_masque implicit none real ( kind = R8 ), allocatable , dimension (:,:) :: mask , array real ( kind = R8 ), allocatable , dimension (:) :: vec , vec_tmp integer ( kind = I4 ), allocatable , dimension (:,:) :: imask type ( SCALE_SURF ) :: scal_surf integer ( kind = I4 ) :: i , nnx , nny , nb_cells real ( kind = R8 ) :: median_size , c1 , c2 , topo , mintab , maxtab integer ( kind = I4 ) :: ni , nj , ii , jj , j , k , ua real ( kind = R8 ) :: angle , dx , dy , t , cp , sp , res_hori , area type ( moment_stat ) :: mom !---------------------------------------------------------------------------------- !---------- Returns the number of cells of a given mask --------------------------- !---------------------------------------------------------------------------------- call read_surf ( nom_fic = \"sur/mask.sur\" , & ! tab_s = mask , & ! scal = scal_surf ) ! nnx = scal_surf % xres nny = scal_surf % yres allocate ( imask ( 1 : nnx , 1 : nny ) ) imask ( 1 : nnx , 1 : nny ) = nint ( mask ( 1 : nnx , 1 : nny ) ) call count_cell ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! nbr_cell = nb_cells , & ! med_cell = median_size ) ! call write_surf ( nom_fic = \"out/res_count_cell.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! write ( * , '(a, T25, I3, a, E12.4, a)' ) 'initial mask:' , nb_cells , ' cells, ' , median_size , ' % surface' !---------------------------------------------------------------------------------- !---- Returns the number of cells of a given mask after erosion ------------------- !---------------------------------------------------------------------------------- imask ( 1 : nnx , 1 : nny ) = nint ( mask ( 1 : nnx , 1 : nny ) ) call erode_dilate ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! val = 6 , & ! act = 'erode' ) ! call count_cell ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! nbr_cell = nb_cells , & ! med_cell = median_size ) ! call write_surf ( nom_fic = \"out/res_count_cell_erode.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! write ( * , '(a, T25, I3, a, E12.4, a)' ) 'mask after erode:' , nb_cells , ' cells, ' , median_size , ' % surface' !---------------------------------------------------------------------------------- !----- Returns the number of cells of a given mask after erosion and dilation ----- !---------------------------------------------------------------------------------- where ( imask ( 1 : nnx , 1 : nny ) >= 1 ) imask ( 1 : nnx , 1 : nny ) = 1 call erode_dilate ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! val = 6 , & ! act = 'dilat' ) ! call count_cell ( msk = imask ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! nbr_cell = nb_cells , & ! med_cell = median_size ) ! call write_surf ( nom_fic = \"out/res_count_cell_erode_dilat.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! write ( * , '(a, T25, I3, a, E12.4, a)' ) 'mask erode + dilate:' , nb_cells , ' cells, ' , median_size , ' % surface' write ( * , * ) '--------------------------------------------------------' !---------------------------------------------------------------------------------- !---------- Returns the % age of heights above c2, once c1 heights are removed ---- !---------------------------------------------------------------------------------- allocate ( array ( 1 : nnx , 1 : nny ) ) allocate ( vec ( 1 : nnx * nny ), vec_tmp ( 1 : nnx * nny ) ) ! thresholds c1 = 0.15_R8 c2 = 0.85_R8 ! surface made of increasing integers vec ( 1 : nnx * nny ) = [ ( i , i = 1 , nnx * nny ) ] mintab = minval ( vec ( 1 : nnx * nny ) ) maxtab = maxval ( vec ( 1 : nnx * nny ) ) ! heights rescaled between 0 and 1 vec_tmp ( 1 : nnx * nny ) = ( vec ( 1 : nnx * nny ) - mintab ) / ( maxtab - mintab ) ! shuffle heights call random_number ( vec ( 1 : nnx * nny ) ) call sort_array2 ( tab_inout = vec ( 1 : nnx * nny ), & ! tab1 = vec_tmp ( 1 : nnx * nny ), & ! n = nnx * nny ) ! array ( 1 : nnx , 1 : nny ) = reshape ( vec_tmp ( 1 : nnx * nny ), [ nnx , nny ] ) ! mask heights above c2, when heights below c1 are ignored call def_masque ( msk = imask ( 1 : nnx , 1 : nny ), & ! tab = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! crit1 = c1 , & ! crit2 = c2 , & ! top = topo ) ! call write_surf ( nom_fic = \"out/mask_after_threshold.sur\" , & ! tab_s = real ( imask ( 1 : nnx , 1 : nny ), kind = R8 ), & ! scal = scal_surf ) ! ! topo is the fraction of heights that are involved write ( * , * ) 'percentage of heights abobe 85%, without the first 15%: ' , topo ! = 100. - 100 * ( c1 + c2 * (1. - c1) ) write ( * , * ) '--------------------------------------------------------' deallocate ( array , mask , imask , vec , vec_tmp ) !---------------------------------------------------------------------------------- !--------- Returns the % age of surface nearly horizontal ------------------------- !---------------------------------------------------------------------------------- nnx = 512 ; nny = 512 allocate ( array ( 1 : nnx , 1 : nny ) ) allocate ( vec ( 1 : nnx * nny ) ) ! the domain is divided into 4x4 patches ni = 512 / 4 nj = 512 / 4 ! cone half angle angle = 5._R8 ! lag along x and y dx = 1.e-7_R8 dy = 1.e-7_R8 k = 0 do i = 1 , 4 do j = 1 , 4 k = k + 1 ! subdomain number ! the subdomain is a plane of equation: z = -a.x -b.y -c ! the normal coordinates are (-a, -b, +1)/sqrt(a**2 + b**2 + 1) ! and the scalar product with \\vec{k} is 1/sqrt(a**2 + b**2 + 1) ! which is also cos(\\theta). ! Therefore a**2 + b**2 = tan(\\theta)**2, so if a = cos(\\phi).tan(\\theta) ! b = sin(\\phi).tan(\\theta), the relationship is satisfied (whatever \\phi). ! With \\theta = k * 0.11 * angle, 9 subdomains are concerned. t = tan ( k * 0.11 * angle * PI_R8 / 180 ) call random_number ( cp ) cp = 2 * ( cp - 0.5 ) call random_number ( sp ) if ( sp > 0.5_R8 ) then sp = + sqrt ( 1._R8 - cp ** 2 ) else sp = - sqrt ( 1._R8 - cp ** 2 ) endif do ii = ( i - 1 ) * ni + 1 , i * ni do jj = ( j - 1 ) * nj + 1 , j * nj array ( ii , jj ) = plane ( a = cp * t , & ! b = sp * t , & ! c = 0._R8 , & ! x = ii * dx , & ! y = jj * dy ) ! enddo enddo enddo enddo call calc_moments ( tab = reshape ( array ( 1 : nnx , 1 : nny ), [ nnx * nny ] ), & ! mx = mom , & ! nb_mom = 2 ) ! array ( 1 : nnx , 1 : nny ) = ( array ( 1 : nnx , 1 : nny ) - mom % mu ) / mom % si call init_scal ( scal = scal_surf , & ! nx = nnx , & ! ny = nny , & ! lx = nnx * dx , & ! ly = nny * dy , & ! unit_z = 'm ' ) ! call write_surf ( nom_fic = \"out/hori.sur\" , & ! tab_s = array ( 1 : nnx , 1 : nny ), & ! scal = scal_surf ) ! call calcul_normales ( tab_in = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! scale_xyz = [ dx , dy , mom % si ], & ! cone_angle = angle , & ! print_mask = . true ., & ! hori = res_hori ) ! call surf_area ( tab_in = array ( 1 : nnx , 1 : nny ), & ! long = nnx , & ! larg = nny , & ! scale_xyz = [ dx , dy , mom % si ], & ! aire = area ) ! call get_unit ( ua ) open ( unit = ua , file = \"out/mask_angle.txt\" ) read ( ua , * ) ( vec ( i ), i = 1 , nnx * nny ) close ( ua ) call write_surf ( nom_fic = \"out/mask_hori.sur\" , & ! tab_s = reshape ( vec ( 1 : nnx * nny ), [ nnx , nny ] ), & ! scal = scal_surf ) ! write ( * , * ) 'Percentage of nearly horizontal surface (+/- 5°): ' , res_hori write ( * , * ) 'Relativea area minus 1 and z scale:               ' , area , mom % si deallocate ( array , vec ) contains real ( kind = R8 ) function plane ( a , b , c , x , y ) implicit none real ( kind = R8 ), intent ( in ) :: a , b , c , x , y plane = a * x + b * y + c return endfunction plane endprogram test_morpho","tags":"","loc":"sourcefile/prg.f90~7.html"}]}